<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="正式开始学习8051及C51。 Cx51 的数据类型摘自Cx51 User’s Guide">
<meta property="og:type" content="article">
<meta property="og:title" content="MCS 51">
<meta property="og:url" content="http://wangyuyang.me/2019/08/06/MCS-51/index.html">
<meta property="og:site_name" content="Y.-Y. Wang&#39;s blog">
<meta property="og:description" content="正式开始学习8051及C51。 Cx51 的数据类型摘自Cx51 User’s Guide">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-05T13:20:03.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MCS 51">
<meta name="twitter:description" content="正式开始学习8051及C51。 Cx51 的数据类型摘自Cx51 User’s Guide">



  <link rel="alternate" href="/atom.xml" title="Y.-Y. Wang's blog" type="application/atom+xml"/>




  <link rel="canonical" href="http://wangyuyang.me/2019/08/06/MCS-51/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MCS 51 | Y.-Y. Wang's blog</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=UA-112074623-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-112074623-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Y.-Y. Wang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wangyuyang.me/2019/08/06/MCS-51/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Y.-Y. Wang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Y.-Y. Wang's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MCS 51

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-06 08:29:51" itemprop="dateCreated datePublished" datetime="2019-08-06T08:29:51+08:00">2019-08-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-05 21:20:03" itemprop="dateModified" datetime="2019-12-05T21:20:03+08:00">2019-12-05</time>
              
            
          </span>

          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>正式开始学习8051及C51。</p>
<h2 id="Cx51-的数据类型"><a href="#Cx51-的数据类型" class="headerlink" title="Cx51 的数据类型"></a>Cx51 的数据类型</h2><p>摘自<a href="http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm" target="_blank" rel="noopener">Cx51 User’s Guide</a><br><a id="more"></a> </p>
<table>
<thead>
<tr>
<th>Data Types</th>
<th>Bits</th>
<th>Bytes</th>
<th>Value Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>bit</td>
<td>1</td>
<td></td>
<td>0 to 1</td>
</tr>
<tr>
<td>signed char</td>
<td>8</td>
<td>1</td>
<td>-128 — +127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>8</td>
<td>1</td>
<td>0 — 255</td>
</tr>
<tr>
<td>enum</td>
<td>8 / 16</td>
<td>1 or 2</td>
<td>-128 — +127 or -32768 — +32767</td>
</tr>
<tr>
<td>signed short int</td>
<td>16</td>
<td>2</td>
<td>-32768 — +32767</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>16</td>
<td>2</td>
<td>0 — 65535</td>
</tr>
<tr>
<td>signed int</td>
<td>16</td>
<td>2</td>
<td>-32768 — +32767</td>
</tr>
<tr>
<td>unsigned int</td>
<td>16</td>
<td>2</td>
<td>0 — 65535</td>
</tr>
<tr>
<td>signed long int</td>
<td>32</td>
<td>4</td>
<td>-2147483648 — +2147483647</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>32</td>
<td>4</td>
<td>0 — 4294967295</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>±1.175494E-38 — ±3.402823E+38</td>
</tr>
<tr>
<td>double</td>
<td>32</td>
<td>4</td>
<td>±1.175494E-38 — ±3.402823E+38</td>
</tr>
<tr>
<td>sbit</td>
<td>1</td>
<td></td>
<td>0 or 1</td>
</tr>
<tr>
<td>sfr</td>
<td>8</td>
<td>1</td>
<td>0 — 255</td>
</tr>
<tr>
<td>sfr16</td>
<td>16</td>
<td>2</td>
<td>0 — 65535</td>
</tr>
</tbody>
</table>
<p>仔细看一下表，实际上Cx51对ANSI C是做了简化，在Cx51中，有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int = short int</span><br><span class="line">double = float</span><br></pre></td></tr></table></figure></p>
<p>2019年8月6日</p>
<hr>
<h2 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器 / 计数器"></a>定时器 / 计数器</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>51单片机内有两个16位定时器/计数器T0和T1，与之相关的特殊功能寄存器有三个，分别是：</p>
<ul>
<li>定时值存储寄存器 TH / TL</li>
<li>定时器控制寄存器 TCON</li>
<li>定时器模式寄存器 TMOD</li>
</ul>
<p>三种寄存器的功能也比较明显，看名字就知道，第一个用来设定定时器开始计数的初值；第二个控制定时器的启动/停止，此外还可以指示定时器是否发生溢出；最后一个寄存器指定定时器的工作模式，比如定时器模式和计数器模式、8/16位定时器等。</p>
<p>显然，由三个寄存器的功能可以看出，使用定时器的步骤（不使用中断）：</p>
<ol>
<li>设定TMOD参数    （指定是定时器还是计数器，以及定时器/计数器的工作模式，一般16位工作模式即可满足需求）</li>
<li>设定TH / TL的初始值    （有点类似数电课程设计里用74LS90和74LS192芯片做计数器）</li>
<li>设定TCON参数    （让定时器开始计数）</li>
<li>校验TCON参数</li>
</ol>
<p>事实上前三步已经实现了定时计数功能，但是，只通过前三步我们并不能知道计时是否已经结束。而TCON中的TF位可以指示定时器是否溢出（有点像计数器芯片里的借位输出端BO），通过检测TF变量的变化次数，就可以知道定时器发生了多少次溢出。而发生一次溢出所需要的时间是确定的（与TH / TL初值和时钟信号频率有关），因此很容易就知道定时器已经计数了多长时间。</p>
<p>其它补充知识：</p>
<ul>
<li>三个寄存器各位的复位值均为0。</li>
<li>TMOD不可位寻址，另外两种寄存器可位寻址。</li>
<li>TMOD中GATE置为0禁用定时器，置为1解除禁用状态。</li>
<li>16位定时器可应付几乎所有场景，此时直接令 TMOD = 0x01 即可。 </li>
<li>TCON的TR置为1后开始计数，置为0后暂停计数。</li>
<li>每次计数时，每经过一个机器周期，定时器值会增加1。</li>
<li>暂停计数时定时器的值不会被重置，还会保持暂停前的状态。</li>
</ul>
<p>附代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">char delay(unsigned int time)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入参数单位为毫秒</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;               <span class="comment">//清零TMOD低四位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;               <span class="comment">//设定T0为16位模式定时器</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;</span><br><span class="line">    TL0 = <span class="number">0x18</span>;                 <span class="comment">//设置定时器初始值，满足每次循环用时1ms</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                    <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF0 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;</span><br><span class="line">            TH0 = <span class="number">0xFC</span>;</span><br><span class="line">            TL0 = <span class="number">0x18</span>;         <span class="comment">//设置每次溢出后定时器初始值</span></span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面是使用查询法实现定时器定时功能，下面是利用中断来实现定时功能的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED0 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    TMOD = <span class="number">0x01</span>;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt_timer</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与查询法相比较，主要有以下几点不同之处：</p>
<ol>
<li>查询法中TF位需要在程序中手动置0，而在中断法中，一旦程序进入了中断函数，TF位会被自动置0。</li>
<li>查询法中用于统计溢出次数的变量count可以和定时函数封装在同一个函数中，而中断法中应将之申明为全局变量（因为中断函数禁止传参，见下文）。</li>
<li>中断函数不需要声明。</li>
</ol>
<p>2019年8月6日</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>就本质上来讲，定时器和计数器并没有太大的区别。唯一的区别在于，定时器是对机器周期进行计数，而计数器是对输入Tn的脉冲进行计数，二者使用方法几乎完全相同，只需将TMOD中的C/T位置1即可。<br>下附代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BEEP = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;           <span class="comment">//清零TMOD高四位</span></span><br><span class="line">    TMOD |= <span class="number">0x60</span>;           <span class="comment">//设定T1为8位自动重装模式计数器</span></span><br><span class="line">    TH1 = <span class="number">256</span> - number;</span><br><span class="line">    TL1 = <span class="number">256</span> - number;     <span class="comment">//设置计数器初始值，满足每计数十次即溢出</span></span><br><span class="line">    TR1 = <span class="number">1</span>;                <span class="comment">//开始计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF1 = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            TH1 = <span class="number">256</span> - number;</span><br><span class="line">            TL1 = <span class="number">256</span> - number;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == number)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                BEEP = <span class="number">0</span>;   <span class="comment">//计数number次后蜂鸣提示</span></span><br><span class="line">                delay(<span class="number">50</span>);</span><br><span class="line">                BEEP = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end of if (TF1 == 1) </span></span><br><span class="line">    &#125;<span class="comment">//end of while (1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2019年8月10日</p>
<hr>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断的优先级有两种，当程序执行时，若低优先级中断执行时，发生了高优先级中断，则：</p>
<ul>
<li>固有优先级：处理完低优先级中断后才进入高优先级中断，即不发生中断嵌套。</li>
<li>抢占优先级：打断低优先级中断并立刻进入高优先级中断，处理完高优先级中断后，返回低优先级中断。</li>
</ul>
<p>根据<a href="http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm" target="_blank" rel="noopener">Cx51 User’s Guide</a>，8051内置六个标准中断源：</p>
<table>
<thead>
<tr>
<th>InterruptNumber</th>
<th>Description</th>
<th>Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>EXTERNAL INT 0</td>
<td>0003h</td>
</tr>
<tr>
<td>1</td>
<td>TIMER/COUNTER 0</td>
<td>000Bh</td>
</tr>
<tr>
<td>2</td>
<td>EXTERNAL INT 1</td>
<td>0013h</td>
</tr>
<tr>
<td>3</td>
<td>TIMER/COUNTER 1</td>
<td>001Bh</td>
</tr>
<tr>
<td>4</td>
<td>SERIAL PORT</td>
<td>0023h</td>
</tr>
<tr>
<td>5</td>
<td>TIMER/COUNTER 2 (8052)</td>
<td>002Bh</td>
</tr>
</tbody>
</table>
<p>与之相关的寄存器有两个（参考STC89C52的datasheet中 图6-1 STC89C52系列中断系统结构图）：</p>
<ul>
<li>中断允许控制寄存器        IE，XICON寄存器</li>
<li>中断优先级控制寄存器      IP，XICON，IPH寄存器</li>
</ul>
<blockquote><p>注：XICON，IPH寄存器为STC89C52独有，可实现4个中断优先级，而传统的8051单片机只能实现2级中断优先级</p>
</blockquote>
<p>显然，由中断相关寄存器的名称可以知道，要想使用中断，首先要在中断允许寄存器中启用中断功能，然后调整中断优先级寄存器中优先级的设定（也可不调整直接使用默认优先级）。</p>
<p>当单片机收到中断信息后，应当转去执行中断信息的处理程序，但是单片机是如何根据中断信息找到处理程序的入口呢？显然，在单片机内部，中断信息和其处理程序建立了某种联系。上表中每一个中断源都对应唯一的一个InterruptNumber——中断类型码，单片机会根据中断类型码，在中断向量表中找到对应的处理程序入口地址，进而开始执行中断服务程序。</p>
<p><em>2019年10月22日更新</em><br>这里中断向量实际上就是指中断服务程序的入口地址（知乎上有对中断向量为什么叫中断向量的讨论），满足：<code>中断向量 = 中断号 * 8 + 3</code>，加3是为了为LJMP指令（三字节指令）留出足够的空间，从而使单片机复位后能通过0000H处的LJMP指令正确的跳转到程序的起始位置，否则复位后就会进入中断。</p>
<p>至于为什么中断向量全部间隔8个单元而不是3个，这个问题有待以后了解。</p>
<h3 id="中断允许控制寄存器"><a href="#中断允许控制寄存器" class="headerlink" title="中断允许控制寄存器"></a>中断允许控制寄存器</h3><p><em>IE: Interrupt Enable  中断允许寄存器  可位寻址</em><br><em>Adress: A8H</em></p>
<p>单片机对任意中断源是否做出响应均由该寄存器进行控制。</p>
<ul>
<li>EA 总中断控制位</li>
<li>ET0 定时器/计数器 0 中断允许位</li>
<li>ET1 定时器/计数器 1 中断允许位</li>
<li>EX0 外部中断 0 中断允许位</li>
<li>EX1 外部中断 1 中断允许位</li>
<li>ES 串行口中断允许位</li>
</ul>
<p>置1为允许中断，置0为禁止中断。</p>
<h3 id="中断优先级控制寄存器"><a href="#中断优先级控制寄存器" class="headerlink" title="中断优先级控制寄存器"></a>中断优先级控制寄存器</h3><p><em>IP: Interrupt Priority  中断优先级寄存器  可位寻址</em><br><em>Adress: B8H</em></p>
<p>各个中断源属于两级中断中的哪一级由该寄存器控制。</p>
<ul>
<li>PT0 定时器/计数器 0 中断优先级控制位</li>
<li>PT1 定时器/计数器 1 中断优先级控制位</li>
<li>PX0 外部中断 0 中断优先级控制位</li>
<li>PX1 外部中断 1 中断优先级控制位</li>
<li>PS 串行口中断优先级控制位</li>
</ul>
<p>置1为高优先级中断，置0为低优先级中断。</p>
<p>若两中断源被设定为相同优先级，当两中断源同时请求中断时，按照默认优先级别响应中断。</p>
<h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>中断函数的调用格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function_Name</span><span class="params">()</span> interrupt Interrupt_Number <span class="keyword">using</span> Register_Bank</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>Interrupt_Number</code>参考上表，无论是否为默认优先级，该值均不变。<br><code>using Register_Bank</code>语句可省略。</p>
<p>即使中断函数写在main函数后面，也不需要在main函数前先对中断函数进行声明。</p>
<p>如果定义两个中断处理函数时，使他们能对同一个中断源进行响应（如两个函数声明时使用了相同的中断向量<code>interrupt 0</code>），那么程序在执行时会发生什么？<br>测试了一下，这样的程序能够通过Keil编译（虽然会有警告<code>WARNING L5: CODE SPACE MEMORY OVERLAP</code>，实际上Keil的官方文档中，<a href="http://www.keil.com/support/docs/839.htm" target="_blank" rel="noopener">对WARING L5的描述</a>也提到了这种情况，但并未说明后果），暂未测试实际执行情况。</p>
<p>一些关于中断函数的注意事项：</p>
<blockquote><p>No function arguments may be specified for an interrupt function. The compiler emits an error message if an interrupt function is declared with any arguments.<br>声明中断函数时不能有参数，否则编译器会报错。</p>
<p>Interrupt function declarations may not include a return value. They must be declared as void. The compiler emits an error message if any attempt is made to define a return value for the interrupt function. The implicit int return value, however, is ignored by the compiler.<br>声明中断函数时不能包含返回值。中断函数必须声明为 void 类型。对于任何试图将中断函数声明为有返回值类型的函数的行为，编译器都会报错。不过，如果返回值为隐式 int 类型则会被编译器忽略。</p>
<p>The compiler recognizes direct calls to interrupt functions and rejects them. It is pointless to call interrupt procedures directly, because exiting the procedure causes execution of the RETI instruction which affects the hardware interrupt system of the 8051 chip. Because no interrupt request on the part of the hardware existed, the effect of this instruction is indeterminate and usually fatal. Do not call an interrupt function indirectly through a function pointer.<br>编译器会识别到任何对中断函数的直接调用并报错。直接调用中断程序是没有意义的，因为退出程序会导致RETI指令的执行， 从而影响8051芯片的硬件中断系统。由于硬件部分并没有中断请求，因此该指令的效果是不确定的，通常是致命的。不要通过函数指针间接调用中断函数。</p>
<p>The Cx51 Compiler allows interrupt numbers within the 0-31 range. Refer to your 8051 derivative document to determine which interrupts are available.<br>Cx51编译器允许0-31范围内的中断位。请参阅8051衍生文档以确定可用的中断。</p>
</blockquote>
<p>2019年8月7日 七夕</p>
<hr>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>通信可以分为两大类：</p>
<ul>
<li>串行传输：一次发送/接收一个位<ul>
<li>异步传输</li>
<li>同步传输</li>
<li>等时传输</li>
</ul>
</li>
<li>并行传输：一次发送/接收多个位</li>
</ul>
<p>以8051为例，8051的RXD和TXD口一次只能接收/发送一个位，为串行传输。<br>以8086为例，8086的数据总线宽度为16，一次可以向内存中读取/写入16位数据，为并行传输。</p>
<p>直觉上觉得并行传输速度快，更先进。查了一下结果发现居然还真不是这样，串行传输反而有取代并行传输的趋势。</p>
<p>PCI和PATA都是并行传输，家里十几年前买的电脑里用的非常宽的硬盘线就是PATA接口，现在已经被淘汰。<br>PCI Express（即PCIe）和SATA均为串行传输，笔记本里的Intel 530和Samsung 860EVO就分别是PCIe和SATA接口，体积很小，但速度依然很快。</p>
<p>串行通信制式的概念：</p>
<ul>
<li>单工：接收端和发送端固定，数据只能从发送端传输到接收端，二者只需一条线连接即可。</li>
<li>半双工：在某一时刻接收端和发送端是固定的，即一次数据传输时一定有一个为接收端，另一个为发送端。二者地位可互换。二者需要一条信号线和一条接地线连接。</li>
<li>全双工：在任一时刻接收端和发送端都可变，即两个设备都可以同时接收和发送数据。二者需要一条接地线和两条信号线连接。</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87" target="_blank" rel="noopener">比特率（Bit rate）</a>：指单位时间内传输送或处理的比特的数量，规定使用“比特每秒”（bit/s或bps）为单位。</p>
<p>对于单片机而言，波特率数值大小不同于单片机发送或者接收数据的时钟频率，波特率大小可以是单片机时钟频率的1/16或者1/64。</p>
<h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><em>Universal asynchronous receiver-transmitter 通用异步收发传输器</em></p>
<p>UART是什么？摘自<a href="http://www.circuitbasics.com/basics-uart-communication/" target="_blank" rel="noopener">这里</a>：</p>
<blockquote><p>UART stands for Universal Asynchronous Receiver/Transmitter. It’s not a communication protocol like SPI and I2C, but a physical circuit in a microcontroller, or a stand-alone IC. A UART’s main purpose is to transmit and receive serial data.</p>
</blockquote>
<p>简单地说，UART不是具体的某一个独立的芯片，而是一种异步串行通信的方式，但这种方式还不能称之为“通信协议”。<br><del>其实我觉得这不就是一种通信协议么…</del></p>
<p>UART通信只需要两个接口：</p>
<ul>
<li>RXD 串行接收引脚</li>
<li>TXD 串行发送引脚</li>
</ul>
<p><del>RXD和TXD中的X有什么含义？</del></p>
<p>显然，在进行UART通信时，要将一个设备的RXD端和另一个设备的TXD端连接。</p>
<p>前面提到，UART是一种异步通信，这意味着没有时钟信号两设备上的让RXD和TXD保持同步。为了保证RXD能够完整的接收到所有数据，传输数据时要满足的条件和步骤大致如下：</p>
<ul>
<li>数据以数据包的形式传送，数据包的结构是可以修改的，只需提前在数据接收方和发送方处设置好即可。</li>
<li>数据接收方和发送方的通信波特率应保持一致。</li>
<li>通信未开始时，线路保持高电平。</li>
<li>通信开始时，TXD首先发送一位0（低电平）作为起始位通知接收方开始传输数据。</li>
<li>发送数据。</li>
<li>发送一位1作为停止位，完成一个数据包的传输。</li>
</ul>
<p><del>终于知道以前用PN532时连的线是干啥用的了</del></p>
<h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p><em>Recommended Standard 232 RS-232</em></p>
<p><a href="https://zh.wikipedia.org/wiki/RS-232" target="_blank" rel="noopener">RS-232</a>是美国电子工业联盟（EIA）制定的串行数据通信的接口标准，原始编号全称是EIA-RS-232。它被广泛用于计算机串行接口外设连接。</p>
<p>RS-232接口最初规定为25个引脚，但大部分设备进行了简化，只使用了其中的9个引脚：</p>
<table>
<thead>
<tr>
<th>Pin</th>
<th>Abbreviation</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pin1</td>
<td>DCD</td>
<td>Data Carrier Detect</td>
</tr>
<tr>
<td>Pin2</td>
<td>RXD</td>
<td>Receiver</td>
</tr>
<tr>
<td>Pin3</td>
<td>TXD</td>
<td>Transmit</td>
</tr>
<tr>
<td>Pin4</td>
<td>DTR</td>
<td>Data Terminal Ready</td>
</tr>
<tr>
<td>Pin5</td>
<td>GND</td>
<td>Ground</td>
</tr>
<tr>
<td>Pin6</td>
<td>DSR</td>
<td>Data Set Ready</td>
</tr>
<tr>
<td>Pin7</td>
<td>RTS</td>
<td>Request To Send</td>
</tr>
<tr>
<td>Pin8</td>
<td>CTS</td>
<td>Clear To Send</td>
</tr>
<tr>
<td>Pin9</td>
<td>RI</td>
<td>Ring Indicator</td>
</tr>
</tbody>
</table>
<p>需要注意的是，RS-232标准采用的电平为RS-232电平而不是TTL电平，RS-232电平为负逻辑电平，即-15V~-3V代表逻辑”1”，+3V~+15V代表逻辑”0”。<br>可使用MAX232芯片进行转换。</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p><em>Universal Serial Bus 通用串行总线</em></p>
<p><a href="https://zh.wikipedia.org/wiki/USB" target="_blank" rel="noopener">USB</a>已经非常熟悉了，其USB接口类型有很多：</p>
<ul>
<li>Standard<ul>
<li>Type-A</li>
<li>Type-A SuperSpeed</li>
<li>Type-B</li>
<li>Type-B SuperSpeed</li>
<li>Type-C</li>
</ul>
</li>
<li>Mini<ul>
<li>Mini-A</li>
<li>Mini-B</li>
<li>Mini-AB </li>
</ul>
</li>
<li>Micro<ul>
<li>Micro-A</li>
<li>Micro-B</li>
<li>Micro-B SuperSpeed</li>
<li>Micro-AB</li>
</ul>
</li>
</ul>
<p>在上述接口中，含SuperSpeed后缀的接口以及Type-C接口均支持USB3.0标准，其余仅支持USB2.0标准。<br><del>转眼间USB4.0标准就要公布了，时间过得真快</del></p>
<p>Type-A SuperSpeed和Type-B SuperSpeed接口一般为蓝色。</p>
<p>同类型的接口可以混插，如Type-A接头可以插入Type-A SuperSpeed接口中，反过来也一样。</p>
<p>不同的接口引脚数往往不同，但所有的接口一定有以下四个引脚（其实核心也就是Pin 3和Pin 4）：</p>
<table>
<thead>
<tr>
<th>Pin</th>
<th>Name</th>
<th>Cable color</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>VCC</td>
<td>Red</td>
<td>+5 VDC</td>
</tr>
<tr>
<td>2</td>
<td>D-</td>
<td>White</td>
<td>Data -</td>
</tr>
<tr>
<td>3</td>
<td>D+</td>
<td>Green</td>
<td>Data +</td>
</tr>
<tr>
<td>4</td>
<td>GND</td>
<td>Black</td>
<td>Ground</td>
</tr>
</tbody>
</table>
<p><em>摘自<a href="https://pinouts.ru/Slots/USB_pinout.shtml" target="_blank" rel="noopener">USB pinout</a></em></p>
<p>Type-A和Type-B接口有且仅有这四个引脚。</p>
<p>Type-A SuperSpeed的引脚如下，可以看到虽然多了5个引脚，但1-4引脚依然存在。</p>
<table>
<thead>
<tr>
<th>PinNumber</th>
<th>PinName</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>VBus</td>
<td>+5V Power</td>
</tr>
<tr>
<td>2</td>
<td>USB D-</td>
<td>USB 2.0 data</td>
</tr>
<tr>
<td>3</td>
<td>USB D+</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>GND</td>
<td>Ground for power return</td>
</tr>
<tr>
<td>5</td>
<td>StdA_SSRX-</td>
<td>SuperSpeed receiver</td>
</tr>
<tr>
<td>6</td>
<td>StdA_SSRX+</td>
<td>SuperSpeed receiver</td>
</tr>
<tr>
<td>7</td>
<td>GND_DRAIN</td>
<td>Ground for signal return</td>
</tr>
<tr>
<td>8</td>
<td>StdA_SSTX-</td>
<td>SuperSpeed transmitter</td>
</tr>
<tr>
<td>9</td>
<td>StdA_SSTX+</td>
<td>SuperSpeed transmitter</td>
</tr>
</tbody>
</table>
<p>USB标准采用的电平依然不是TTL电平，其D-和D+引脚传输的是差分信号。可使用<a href="http://www.winchiphead.com/download/CH340/CH340DS1.PDF" target="_blank" rel="noopener">CH340</a>芯片进行转换。</p>
<p>2019年8月8日 立秋</p>
<h3 id="串行口控制寄存器"><a href="#串行口控制寄存器" class="headerlink" title="串行口控制寄存器"></a>串行口控制寄存器</h3><p><em>SCON: Serial Control 串行口控制寄存器 可位寻址</em><br><em>Address: 98H</em></p>
<p>类似TCON，控制串口的工作模式及指示串口状态。</p>
<ul>
<li>RI 接收中断标志位</li>
<li>TI 发送中断标志位</li>
<li>RB8 模式 2 和 3 中接收到的第九位数据</li>
<li>TB8 模式 2 和 3 中要发送的第九位数据</li>
<li>REN 使能串行接收</li>
<li>SM2 多机通信控制位</li>
<li>SM1 控制工作模式</li>
<li>SM0 控制工作模式</li>
</ul>
<h3 id="串行口数据缓冲寄存器"><a href="#串行口数据缓冲寄存器" class="headerlink" title="串行口数据缓冲寄存器"></a>串行口数据缓冲寄存器</h3><p><em>SBUF: Serial Buffer 串行口数据缓冲寄存器 不可位寻址</em><br><em>Adress: 99H</em></p>
<p>表面上SBUF是一个寄存器，但其实它是由一个只读寄存器和一个只写寄存器构成的。使用时并不需要选择具体使用哪一个寄存器，当对SBUF作读操作时，单片机会自动调用只读寄存器。反过来，当程序对SBUF作写操作时，单片机会自动调用只写寄存器。</p>
<p>看起来挺复杂，实际上SBUF的工作原理也挺简单的，STC89C52RC的datasheet写的很详细：</p>
<blockquote><p>······在写入SBUF信号的控制下，把数据装入相同的9位移位寄存器，前面8位为数据字节，其最低位为移位寄存器的输出位。根据不同的工作方式会自动将“1”或TB8的值装入移位寄存器的第9位，并进行发送。</p>
<p>串行通道的接收寄存器是一个输入移位寄存器。在方式0时它的字长为8位，其他方式时位9位。当一帧接收完毕，移位寄存器中的数据字节装入串行数据缓冲器SBUF中，其第9位则装入SCON寄存器中的RB8位。如果由于SM2使得已接受到的数据无效时，RB8和SBUF中的内容不变。</p>
<p>由于接收通道内设有输入移位寄存器和SBUF缓冲器，从而能使一帧接收完将数据由移位寄存器装入SBUF后，可立即接收下一帧信息，主机应在该帧接收结束前从SBUF缓冲器中将数据取走，否则前一帧数据将丢失。SBUF以并行方式送往内部数据总线。</p>
</blockquote>
<h3 id="串口通信的具体实现"><a href="#串口通信的具体实现" class="headerlink" title="串口通信的具体实现"></a>串口通信的具体实现</h3><p>步骤大致如下：</p>
<ol>
<li>配置串行口控制寄存器SCON</li>
<li>配置定时器 T1 为自动重装模式，禁用 T1 中断</li>
<li>根据baud计算TH1、TL1初值</li>
<li>TR1置1，启动定时器</li>
</ol>
<p>2019年8月14日</p>
<h3 id="两种不同的换行符"><a href="#两种不同的换行符" class="headerlink" title="两种不同的换行符"></a>两种不同的换行符</h3><p>在VS Code右下角可以选择行尾序列LF或CRLF，一直以来只知道是两种不同的换行符但没有去深入了解。但在用8051做串口通讯时遇到了问题，直接发送ASCII表的第十一位LF（0x10）时上位机显示的文本并未将其理解为换行符，于是去查了一些相关资料：</p>
<p>不同的编辑器使用的换行符往往不同，这是一个历史问题。采用的换行标记一般为以下五种，后两种挺少见的，可以忽略：</p>
<ul>
<li>ASCII standard<ul>
<li>LF: line feed 换行</li>
<li>CR: carriage return 回车</li>
<li>CRLF: carriage return + line feed 换行 + 回车</li>
</ul>
</li>
<li>Unicode standard<ul>
<li>LS: Line Separator</li>
<li>PS: Paragraph Separator</li>
</ul>
</li>
</ul>
<p>多数Unix和类Unix系统（macOS、Linux、FreeBSD etc.）都使用LF作为换行符。而Windows系统使用的换行符是CRLF，选择二者组合的原因还挺有意思的，这和上世纪时广泛使用的电传打印机(teleprinter)有关。</p>
<p>这篇文章<a href="https://devblogs.microsoft.com/oldnewthing/?p=40193" target="_blank" rel="noopener">Why is the line terminator CR+LF?</a>对原因解释的很清楚：</p>
<blockquote><p>This protocol dates back to the days of teletypewriters.</p>
<p>CR stands for “carriage return” – the CR control character returned the print head (“carriage”) to column 0 without advancing the paper. LF stands for “linefeed” – the LF control character advanced the paper one line without moving the print head.So if you wanted to return the print head to column zero (ready to print the next line) and advance the paper (so it prints on fresh paper), you need both CR and LF.</p>
<p>If you go to the various internet protocol documents, such as RFC 0821 (SMTP), RFC 1939 (POP), RFC 2060 (IMAP), or RFC 2616 (HTTP), you’ll see that they all specify CR+LF as the line termination sequence.</p>
<p>So the the real question is not “Why do CP/M, MS-DOS, and Win32 use CR+LF as the line terminator?” but rather “Why did other people choose to differ from these standards documents and use some other line terminator?”</p>
</blockquote>
<p>读到这自然也会好奇为什么C语言中只使用<code>\n</code>就能实现换行，事实上这篇文章也提到了原因：</p>
<blockquote><p>The unix ancestry of the C language carried this convention into the C language standard, which requires only “\n” (which encodes LF) to terminate lines, putting the burden on the runtime libraries to convert raw file data into logical lines.</p>
<p>The C language also introduced the term “newline” to express the concept of “generic line terminator”. I’m told that the ASCII committee changed the name of character 0x0A to “newline” around 1996, so the confusion level has been raised even higher.</p>
</blockquote>
<p>2019年8月15日</p>
<hr>
<h2 id="Cx51中的坑"><a href="#Cx51中的坑" class="headerlink" title="Cx51中的坑"></a>Cx51中的坑</h2><p>不到十行的程序莫名其妙的报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C141: syntax error near &apos;int&apos;, expected &apos;__asm&apos;</span><br></pre></td></tr></table></figure></p>
<p>翻来覆去看对应的语句，怎么都没找到错误，查了一下才知道到底是什么问题。</p>
<p>确切的讲，这个问题是C89的锅，C89规定变量必须声明在块的开头，也就是其他执行语句的前面。而C99标准放宽了这一限制。</p>
<p>2019年8月9日</p>
<hr>
<h2 id="MCS-51的寻址方式"><a href="#MCS-51的寻址方式" class="headerlink" title="MCS-51的寻址方式"></a>MCS-51的寻址方式</h2><p>一共有七种寻址方式：</p>
<ul>
<li>直接寻址</li>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>寄存器间接寻址</li>
<li>基址寄存器加变址寄存器间接寻址</li>
<li>相对寻址</li>
<li>位寻址</li>
</ul>
<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址的概念比较简单，就是该指令执行时会从寄存器中读取一个立即数。立即数是编写程序时写入程序指令的常数。为了区分这个数是操作数（即参与运算的数）还是地址，会在这个数字之前加上<code>#</code>标志，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, #30H</span><br></pre></td></tr></table></figure>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>顾名思义，直接在指令中给出操作数的真实地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, 30H</span><br></pre></td></tr></table></figure>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>寄存器寻址，其实就是，假定有一个立即数存放在工作寄存器里，然后从该工作寄存器读取这个立即数的过程就是寄存器寻址，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R1</span><br></pre></td></tr></table></figure>
<p>至于R1属于哪一个工作寄存器区，这个由执行该语句时，PSW寄存器中的RS1和RS0的值来决定。</p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器间接寻址的概念很类似于C语言中的指针，先看下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R1</span><br></pre></td></tr></table></figure>
<p>显然，该语句为上面所提到的寄存器寻址，单片机首先从R1中读取一个数，并认为这个数是立即数，然后将这个数储存到A中。而对于下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, @R1</span><br></pre></td></tr></table></figure>
<p>则是指：单片机从R1中读取一个数，但认为这个数不是一个立即数，而是指向另一个存储单元的地址。单片机会继续到这个存储单元去读取保存在里面的数据，并把这个数保存在累加器A中。</p>
<h3 id="基址寄存器加变址寄存器间接寻址"><a href="#基址寄存器加变址寄存器间接寻址" class="headerlink" title="基址寄存器加变址寄存器间接寻址"></a>基址寄存器加变址寄存器间接寻址</h3><p>名字很长，但是联系到8086汇编就很容易理解了，说白了就是把段地址+偏移地址的模式稍微简化一下，不对段地址进行移位操作，而是直接和偏移地址相加，没什么意思。</p>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>这个就更简单了，就是说，假如程序执行到了语句X，现在想跳转到X前面的某一个语句或者后面的某一个语句，那么就可以用相对寻址来实现。这个就有点类似于C语言里的goto语句（复习一下，goto语句的标签具有函数作用域）。</p>
<p>只不过更准确的说，相对寻址改变的是程序计数器PC中的值，进而实现语句跳转。</p>
<h3 id="位寻址"><a href="#位寻址" class="headerlink" title="位寻址"></a>位寻址</h3><p>位寻址的概念已经很熟悉了，C51里就已经经常使用，还有一个相对的概念是“不可位寻址”。</p>
<p>现在可以回过头来看一看<code>reg52.h</code>里都有哪些内容了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">REG52.H</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Header file for generic 80C52 and 80C32 microcontroller.</span></span><br><span class="line"><span class="comment">Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __REG52_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __REG52_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BYTE Registers  */</span></span><br><span class="line">sfr P0    = <span class="number">0x80</span>;</span><br><span class="line">sfr P1    = <span class="number">0x90</span>;/</span><br><span class="line">sfr P2    = <span class="number">0xA0</span>;</span><br><span class="line">sfr P3    = <span class="number">0xB0</span>;/</span><br><span class="line">sfr PSW   = <span class="number">0xD0</span>;/</span><br><span class="line">sfr ACC   = <span class="number">0xE0</span>;</span><br><span class="line">sfr B     = <span class="number">0xF0</span>;</span><br><span class="line">sfr SP    = <span class="number">0x81</span>;</span><br><span class="line">sfr DPL   = <span class="number">0x82</span>;</span><br><span class="line">sfr DPH   = <span class="number">0x83</span>;</span><br><span class="line">sfr PCON  = <span class="number">0x87</span>;</span><br><span class="line">sfr TCON  = <span class="number">0x88</span>;/</span><br><span class="line">sfr TMOD  = <span class="number">0x89</span>;</span><br><span class="line">sfr TL0   = <span class="number">0x8A</span>;</span><br><span class="line">sfr TL1   = <span class="number">0x8B</span>;</span><br><span class="line">sfr TH0   = <span class="number">0x8C</span>;</span><br><span class="line">sfr TH1   = <span class="number">0x8D</span>;</span><br><span class="line">sfr IE    = <span class="number">0xA8</span>;/</span><br><span class="line">sfr IP    = <span class="number">0xB8</span>;/</span><br><span class="line">sfr SCON  = <span class="number">0x98</span>;/</span><br><span class="line">sfr SBUF  = <span class="number">0x99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  8052 Extensions  */</span></span><br><span class="line">sfr T2CON  = <span class="number">0xC8</span>;/</span><br><span class="line">sfr RCAP2L = <span class="number">0xCA</span>;</span><br><span class="line">sfr RCAP2H = <span class="number">0xCB</span>;</span><br><span class="line">sfr TL2    = <span class="number">0xCC</span>;</span><br><span class="line">sfr TH2    = <span class="number">0xCD</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BIT Registers  */</span></span><br><span class="line"><span class="comment">/*  PSW  */</span></span><br><span class="line">sbit CY    = PSW^<span class="number">7</span>;</span><br><span class="line">sbit AC    = PSW^<span class="number">6</span>;</span><br><span class="line">sbit F0    = PSW^<span class="number">5</span>;</span><br><span class="line">sbit RS1   = PSW^<span class="number">4</span>;</span><br><span class="line">sbit RS0   = PSW^<span class="number">3</span>;</span><br><span class="line">sbit OV    = PSW^<span class="number">2</span>;</span><br><span class="line">sbit P     = PSW^<span class="number">0</span>; <span class="comment">//8052 only</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  TCON  */</span></span><br><span class="line">sbit TF1   = TCON^<span class="number">7</span>;</span><br><span class="line">sbit TR1   = TCON^<span class="number">6</span>;</span><br><span class="line">sbit TF0   = TCON^<span class="number">5</span>;</span><br><span class="line">sbit TR0   = TCON^<span class="number">4</span>;</span><br><span class="line">sbit IE1   = TCON^<span class="number">3</span>;</span><br><span class="line">sbit IT1   = TCON^<span class="number">2</span>;</span><br><span class="line">sbit IE0   = TCON^<span class="number">1</span>;</span><br><span class="line">sbit IT0   = TCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IE  */</span></span><br><span class="line">sbit EA    = IE^<span class="number">7</span>;</span><br><span class="line">sbit ET2   = IE^<span class="number">5</span>; <span class="comment">//8052 only</span></span><br><span class="line">sbit ES    = IE^<span class="number">4</span>;</span><br><span class="line">sbit ET1   = IE^<span class="number">3</span>;</span><br><span class="line">sbit EX1   = IE^<span class="number">2</span>;</span><br><span class="line">sbit ET0   = IE^<span class="number">1</span>;</span><br><span class="line">sbit EX0   = IE^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IP  */</span></span><br><span class="line">sbit PT2   = IP^<span class="number">5</span>;</span><br><span class="line">sbit PS    = IP^<span class="number">4</span>;</span><br><span class="line">sbit PT1   = IP^<span class="number">3</span>;</span><br><span class="line">sbit PX1   = IP^<span class="number">2</span>;</span><br><span class="line">sbit PT0   = IP^<span class="number">1</span>;</span><br><span class="line">sbit PX0   = IP^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P3  */</span></span><br><span class="line">sbit RD    = P3^<span class="number">7</span>;</span><br><span class="line">sbit WR    = P3^<span class="number">6</span>;</span><br><span class="line">sbit T1    = P3^<span class="number">5</span>;</span><br><span class="line">sbit T0    = P3^<span class="number">4</span>;</span><br><span class="line">sbit INT1  = P3^<span class="number">3</span>;</span><br><span class="line">sbit INT0  = P3^<span class="number">2</span>;</span><br><span class="line">sbit TXD   = P3^<span class="number">1</span>;</span><br><span class="line">sbit RXD   = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  SCON  */</span></span><br><span class="line">sbit SM0   = SCON^<span class="number">7</span>;</span><br><span class="line">sbit SM1   = SCON^<span class="number">6</span>;</span><br><span class="line">sbit SM2   = SCON^<span class="number">5</span>;</span><br><span class="line">sbit REN   = SCON^<span class="number">4</span>;</span><br><span class="line">sbit TB8   = SCON^<span class="number">3</span>;</span><br><span class="line">sbit RB8   = SCON^<span class="number">2</span>;</span><br><span class="line">sbit TI    = SCON^<span class="number">1</span>;</span><br><span class="line">sbit RI    = SCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P1  */</span></span><br><span class="line">sbit T2EX  = P1^<span class="number">1</span>; <span class="comment">// 8052 only</span></span><br><span class="line">sbit T2    = P1^<span class="number">0</span>; <span class="comment">// 8052 only</span></span><br><span class="line">             </span><br><span class="line"><span class="comment">/*  T2CON  */</span></span><br><span class="line">sbit TF2    = T2CON^<span class="number">7</span>;</span><br><span class="line">sbit EXF2   = T2CON^<span class="number">6</span>;</span><br><span class="line">sbit RCLK   = T2CON^<span class="number">5</span>;</span><br><span class="line">sbit TCLK   = T2CON^<span class="number">4</span>;</span><br><span class="line">sbit EXEN2  = T2CON^<span class="number">3</span>;</span><br><span class="line">sbit TR2    = T2CON^<span class="number">2</span>;</span><br><span class="line">sbit C_T2   = T2CON^<span class="number">1</span>;</span><br><span class="line">sbit CP_RL2 = T2CON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>2019年9月18日</p>
<hr>
<h2 id="MCS-51-的存储器结构"><a href="#MCS-51-的存储器结构" class="headerlink" title="MCS-51 的存储器结构"></a>MCS-51 的存储器结构</h2><p>学习8086汇编时，可以了解到8086采用的是Von Neumann架构，正如王爽在《汇编语言》中反复强调的一样，指令和数据是完全相同的概念，程序和数据共用同一条总线。</p>
<p>不同于8086，一般认为，MCS-51是采用Harvard架构的MCU，其程序存储器（ROM）和数据存储器（RAM）的Adress Space相互独立。</p>
<p>扩展阅读：<a href="https://www.zhihu.com/question/22406681/answer/21264994" target="_blank" rel="noopener">为什么电脑还沿用冯·诺伊曼结构而不使用哈佛结构？</a></p>
<p>从物理上分，即从电路的实际物理结构来区分，MCS-51的存储空间可分为四个部分：</p>
<ul>
<li>程序存储器<ul>
<li>片内程序存储器</li>
<li>片外程序存储器</li>
</ul>
</li>
<li>数据存储器<ul>
<li>片内数据存储器</li>
<li>片外数据存储器</li>
</ul>
</li>
</ul>
<p>从逻辑上分，即按照实际使用时的角度来区分，则可分为三个部分：</p>
<ul>
<li>程序存储器（片内片外统一编址）</li>
<li>数据存储器（片内片外独立编址）<ul>
<li>片内数据存储器</li>
<li>片外数据存储器</li>
</ul>
</li>
</ul>
<p>这里又牵扯出了两个概念——统一编址和独立编址。<br>实际上是很简单的概念，可参考<a href="https://blog.csdn.net/zhandoushi1982/article/details/5976898" target="_blank" rel="noopener">内存和外设的统一编址及独立编址</a>和<a href="https://www.cnblogs.com/armlinux/archive/2010/11/26/2396888.html" target="_blank" rel="noopener">理解“统一编址与独立编址、I/O端口与I/O内存”</a></p>
<h3 id="MCS-51-的程序存储器"><a href="#MCS-51-的程序存储器" class="headerlink" title="MCS-51 的程序存储器"></a>MCS-51 的程序存储器</h3><p>MCS-51的程序计数器是16位，即地址空间可达2^16 bit = 64KB。</p>
<p>正常工作模式下（即<span style="TEXT-DECORATION: overline">EA</span>端接高电平），PC从内部ROM的0x0000开始计数。当PC的值大于0x0FFF时，会自动转至片外程序存储器的0x1000处，直到片外存储器的0xFFFF为止。所以逻辑上对片内程序存储器和片外程序存储器不做区分。</p>
<p>不过实际使用时，为了某些特殊目的，还可以将<span style="TEXT-DECORATION: overline">EA</span>端接低电平，此时单片机会直接从片外ROM的0x0000开始计数，而不再使用片内程序存储器。</p>
<p>程序存储器中有七个地址较为特殊，分别为复位时PC指向的地址0000H和六个中断源入口地址（参见中断部分内容）。</p>
<h3 id="MCS-51-的数据存储器"><a href="#MCS-51-的数据存储器" class="headerlink" title="MCS-51 的数据存储器"></a>MCS-51 的数据存储器</h3><p>正如前面提到的那样，MCS-51单片机的片内、片外数据存储器是独立编址的。</p>
<ul>
<li>片内数据存储器的地址空间：0x00 ~ 0xFF</li>
<li>片外数据存储器的地址空间：0x0000 ~ 0xFFFF</li>
</ul>
<p>对于MCS-51系列的MCU而言，片内数据存储器又可以分为两块：</p>
<ul>
<li>0x00 ~ 0x7F: 工作寄存器区 + 位寻址区 + 数据缓冲区</li>
<li>0x80 ~ 0xFF: 特殊功能寄存器SFR</li>
</ul>
<p>而对于MCS-52系列的MCU，实际上有两块区域被映射到了0x80 ~ 0xFF的地址空间，即可认为这两块区域是独立编址的。这两块区域一个是特殊功能寄存器SFR块，另一个则是一个普通的数据存储器块。</p>
<p>这两块区域有着完全相同的地址，那么实际在写程序时，如何才能区分这两块区域呢？这个是通过不同的寻址方式实现的，访问SFR块必须采用直接寻址的方式，而访问重叠部分的普通RAM则采用寄存器间接寻址来实现。</p>
<p>工作寄存器区一共分为四个区（0区~3区，首地址分别为0、8、16和24），对应四个通用寄存器组。每个通用寄存器组由8个通用寄存器R0~R7构成，使用时具体访问哪一组通用寄存器由PSW寄存器中的RS1和RS0决定。</p>
<p>这里就可以回答一个问题，为什么51单片机上电复位后堆栈指针SP指向0007H而不是0000H？</p>
<p>这是因为，单片机上电复位后，PSW寄存器被重置为0x00，因此也就是默认选择了工作寄存器区0区。因此通用寄存器R0~R7被映射到了地址0x00~0x07，为了避免进行堆栈操作时将该区域的数据破坏，故将堆栈指针SP复位值设计为0007H。</p>
<p>复位后CPU内部RAM的各单元内容<strong>并不会</strong>被清除，但长时间掉电会造成数据存储器内数据的丢失。</p>
<p>位寻址区就是指该区域中的每一位均可位寻址，需要注意的就是RAM中并不是只有该区域可以位寻址，SFR中的部分单元也可位寻址。</p>
<p>用户RAM区，需要注意的就是在汇编时，要把单片机的堆栈指针SP指向该区域。否则由于SP复位后指向0007H，在栈向上生长时会破坏工作寄存器区（1区~3区）和位寻址区内的数据。</p>
<h3 id="Keil-uVision5-查看和修改程序-数据存储器"><a href="#Keil-uVision5-查看和修改程序-数据存储器" class="headerlink" title="Keil uVision5 查看和修改程序\数据存储器"></a>Keil uVision5 查看和修改程序\数据存储器</h3><p>进入调试状态后点击Memory Window，并在Address内填入对应地址即可查看存储器内数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看 ROM 的 CODE 区</span></span><br><span class="line">C:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 DATA 区</span></span><br><span class="line">D:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 IDATA 区</span></span><br><span class="line">I:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片外 RAM 的 XDATA 区</span></span><br><span class="line">X:<span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>code 代码存储区</li>
<li>data 直接寻址片内数据存储区</li>
<li>bdata 可位寻址片内数据存储区</li>
<li>idata 间接寻址片内数据存储区</li>
<li>pdata 分页寻址片外数据存储区</li>
<li>xdata 片外数据存储区</li>
</ul>
<p>关于code、idata等详细含义，可查看<a href="http://www.keil.com/support/man/docs/c51/c51_le_memtypes.htm" target="_blank" rel="noopener">Memory Types</a><br>2019年10月7日 重阳节</p>
<hr>
<h2 id="MCS-51的伪指令"><a href="#MCS-51的伪指令" class="headerlink" title="MCS-51的伪指令"></a>MCS-51的伪指令</h2><p>伪指令主要有以下八个：</p>
<ul>
<li>ORG</li>
<li>END</li>
<li>DB</li>
<li>DW</li>
<li>DS</li>
<li>EQU</li>
<li>DATA</li>
<li>BIT</li>
</ul>
<p>这八条指令大致可分为三类，下分类记录。</p>
<h3 id="ORG和END"><a href="#ORG和END" class="headerlink" title="ORG和END"></a>ORG和END</h3><p><code>ORG</code>指令指定了其后面第一条指令在ROM中存储时的起始位置，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG 0030H</span><br><span class="line">INC A</span><br></pre></td></tr></table></figure>
<p>这里<code>INC A</code>在ROM中就是从0030H开始存储的。</p>
<p>顺便复习一下标号，标号是代表着其后面第一条指令的地址，因此下面两种写法是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP:  INC A</span><br><span class="line"></span><br><span class="line">; 等价于</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">       INC A</span><br></pre></td></tr></table></figure>
<p>不要错误的认为标号代表当前行所在的地址。</p>
<p><code>END</code>就是结束标志，没什么意思。</p>
<h3 id="DB、DW和DS"><a href="#DB、DW和DS" class="headerlink" title="DB、DW和DS"></a>DB、DW和DS</h3><ul>
<li>DB：从指定单元开始，定义n个字节，并在每个字节中存放1个数</li>
<li>DW：从指定单元开始，定义n个字（对于MCS-51，1个word = 2个byte），并在每个字中存放1个数</li>
<li>DS：从指定单元开始，定义n个空字节</li>
</ul>
<p>这里的“指定单元”的地址按以下两种方法确定：</p>
<ol>
<li>由<code>ORG</code>指令确定</li>
<li>在前一条指令末地址的下一个地址确定</li>
</ol>
<p>对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORG     8051H</span><br><span class="line">DB      &apos;A&apos;                  ; (8051H) = &apos;A&apos; = 05H</span><br><span class="line"></span><br><span class="line">ORG     8086H</span><br><span class="line">NOP                          ; NOP 为单字节指令</span><br><span class="line">DB      &apos;B&apos;                  ; (8087H) = &apos;B&apos; = 06H</span><br></pre></td></tr></table></figure>
<p><code>DB</code>指令在保存字符串时会非常方便，可以直接写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB      &apos;To be or not to be&apos;</span><br><span class="line">DB      &apos;That is the question&apos;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB      &apos;T&apos;, &apos;o&apos;, &apos; &apos;, &apos;b&apos;, &apos;e&apos;</span><br><span class="line">; ......</span><br></pre></td></tr></table></figure>
<p>但对于<code>DW</code>指令而言，一次只能定义两个字节的单元：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 是错误的！</span><br><span class="line">DW      &apos;To be or not to be&apos;</span><br><span class="line">DW      &apos;That is the question&apos;</span><br><span class="line"></span><br><span class="line">; 必须写为：</span><br><span class="line">DW      &apos;To&apos;, &apos; b&apos;, &apos;e &apos;, &apos;or&apos;</span><br><span class="line">; ......</span><br></pre></td></tr></table></figure>
<p>另外，<code>DB</code>，<code>DW</code>和<code>DS</code>后可以跟表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DB      128 + 127</span><br><span class="line">DW      1024 + 255</span><br><span class="line">DS      1 + 1</span><br><span class="line"></span><br><span class="line">; 等价于：</span><br><span class="line">DB      255</span><br><span class="line">DW      1279</span><br><span class="line">DS      2</span><br></pre></td></tr></table></figure>
<p>在使用<code>DB</code>、<code>DW</code>和<code>DS</code>时有一点需要注意，以这段程序为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG     8000H</span><br><span class="line">DB      &apos;A&apos;, 00H</span><br></pre></td></tr></table></figure>
<p>这段代码本意是在8000H单元中存放字母A对应的ASCII码0x41，8001H单元中存放00H</p>
<p>即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8000H:  0100 0001</span><br><span class="line">8001H:  0000 0000</span><br></pre></td></tr></table></figure>
<p>但利用Keil调试功能提供的反汇编代码来观察一下，上面的<code>DB</code>指令会被翻译为双字节指令<code>AJMP 20H</code>，为什么会出现这种情况？这就要回顾一下AJMP指令的机器码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; AJMP addr11</span><br><span class="line"></span><br><span class="line">A10A9A8    00001</span><br><span class="line">A7A6A5A4A3A2A1A0</span><br></pre></td></tr></table></figure>
<p>对比一下不难发现，前面的<code>DB</code>指令及其存放的数据，恰好为<code>AJMP 20H</code>指令对应的机器码，因此反汇编的结果也就不难理解了。</p>
<p>因此这里也就需要注意，如果写程序时不慎将<code>DB</code>和<code>DW</code>指令及其定义的数据写为程序需要执行的代码，有可能会引发莫名其妙的错误（且编译器不提示），如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">MAIN:</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>
<p>正确写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line"></span><br><span class="line">        ORG     0060H</span><br><span class="line">MAIN:</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>
<p>当然，由于<code>NOP</code>指令的机器码就是<code>0000 0000</code>，因此<code>DS</code>指令并不会导致错误，只是相当于额外增加了几微秒的延时。</p>
<p>另外，所有的资料都会说，DS指令是用来划分出一部分空间备用，包括Keil的文档也只是简单的提了这么几句话:</p>
<blockquote><p>The DS statement reserves the specified number of bytes in the current memory space. label is a symbol that is assigned the current memory address. expression is the number of bytes to reserve.<br>This statement reserves space and increments the location counter by the number of bytes reserved.</p>
</blockquote>
<p>但是，DB、DW和DS只对程序存储器起作用，而ROM在单片机运行时是不可能被修改的，既然如此，为什么还会需要DS指令？</p>
<p>只查到<code>startup.a51</code>文件中用到了DS指令，其它情况均未检索到。</p>
<h3 id="EQU、DATA和BIT"><a href="#EQU、DATA和BIT" class="headerlink" title="EQU、DATA和BIT"></a>EQU、DATA和BIT</h3><ul>
<li>EQU：类似#define，但必须先定义后使用，可跟表达式</li>
<li>DATA：类似#define，可以先使用再定义（类似goto的函数作用域），可跟表达式</li>
<li>BIT：类似#define，可以先使用再定义</li>
</ul>
<p>EQU的用法要留意一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 正确的</span><br><span class="line">Alpha   EQU     0FFH</span><br><span class="line">MOV     A, #Alpha</span><br><span class="line"></span><br><span class="line">; 亦可  MOV     A, Alpha  , 此时Alpha为地址</span><br><span class="line"></span><br><span class="line">; 错误的</span><br><span class="line">Alpha   EQU     #0FFH</span><br></pre></td></tr></table></figure>
<p>EQU后可跟表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alpha   EQU     90 + 9</span><br><span class="line"></span><br><span class="line">; 等价于</span><br><span class="line">Alpha   EQU     99</span><br></pre></td></tr></table></figure>
<p>2019年10月21日</p>
<hr>
<h2 id="MCS-51的指令"><a href="#MCS-51的指令" class="headerlink" title="MCS-51的指令"></a>MCS-51的指令</h2><p>根据《MCS-51单片机原理、系统设计与应用》一书，111条指令可按以下三种方式分类：</p>
<p>按字节数分：</p>
<ul>
<li>单字节指令</li>
<li>双字节指令</li>
<li>三字节指令</li>
</ul>
<p>按执行时间分：</p>
<ul>
<li>单周期指令</li>
<li>双周期指令</li>
<li>四周期指令</li>
</ul>
<p>按功能分：</p>
<ul>
<li>数据传送类</li>
<li>算术运算类</li>
<li>逻辑运算类</li>
<li>控制转移类</li>
<li>布尔处理类</li>
</ul>
<p>虽然说有111条指令，但操作码助记符也就这45个：</p>
<ul>
<li>数据传送类<ul>
<li>MOV</li>
<li>MOVC</li>
<li>MOVX</li>
<li>PUSH</li>
<li>POP</li>
<li>XCH</li>
<li>XCHD</li>
</ul>
</li>
<li>算术运算类<ul>
<li>ADD</li>
<li>ADDC</li>
<li>SUBB</li>
<li>INC</li>
<li>DEC</li>
<li>MUL</li>
<li>DIV</li>
<li>DA</li>
</ul>
</li>
<li>逻辑运算和移位指令<ul>
<li>ANL</li>
<li>ORL</li>
<li>XRL</li>
<li>CLR</li>
<li>CPL</li>
<li>RL</li>
<li>RR</li>
<li>RLC</li>
<li>RRC</li>
<li>SWAP</li>
</ul>
</li>
<li>控制转移类<ul>
<li>AJMP</li>
<li>LJMP</li>
<li>SJMP</li>
<li>JMP</li>
<li>JZ</li>
<li>JNZ</li>
<li>CJNE</li>
<li>DJNZ</li>
<li>ACALL</li>
<li>LCALL</li>
<li>RET</li>
<li>RETI</li>
<li>NOP</li>
</ul>
</li>
<li>布尔处理类<ul>
<li>CLR</li>
<li>SETB</li>
<li>CPL</li>
<li>ANL</li>
<li>ORL</li>
<li>JC</li>
<li>JNC</li>
<li>JBC</li>
</ul>
</li>
</ul>
<p>用的比较少的指令：</p>
<ul>
<li>XCH：内部RAM、SFR或寄存器内容与累加器内容互换</li>
<li>XCHD：内部RAM低4位内容与累加器低4位内容交换</li>
<li>SWAP：累加器高4位与低4位交换</li>
<li>DA：十进制调整指令</li>
</ul>
<p>2019年10月24日 霜降</p>
<hr>
<h2 id="关于MCS-51汇编中有符号数和无符号数的问题"><a href="#关于MCS-51汇编中有符号数和无符号数的问题" class="headerlink" title="关于MCS-51汇编中有符号数和无符号数的问题"></a>关于MCS-51汇编中有符号数和无符号数的问题</h2><p>在C语言中，有符号数和无符号数利用signed和unsigned关键字来区分，简洁明了。</p>
<p>但在汇编层面，不存在变量的概念，一切操作都是直接对寄存器中二进制数进行运算。此时CPU如何区分一个数是有符号数还是无符号数？如果两有符号数相加，那么就可能发生溢出的问题，这个时候单片机的溢出标志位就可能会发生改变。</p>
<p>但如果两个无符号数相加，那么溢出的概念就毫无意义，那么对于无符号数的运算，单片机的溢出标志位是否还会改变呢？在keil中测试即可发现，无符号数运算时溢出标志位依然是会改变的，至于为什么，有必要弄明白CPU是如何处理这一问题的。</p>
<p>查阅了相关资料，得出的结论是，CPU并不区分一个数有无符号，或者也可以说，CPU在运算时把所有数都看作有符号数，例如，如果我想计算129 + 1的值，则应写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV A, #10000001B</span><br><span class="line">ADD A, #1</span><br></pre></td></tr></table></figure>
<p>而如果我想计算-127 + 1，那么有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; -127的补码为1000 0001B</span><br><span class="line">MOV A, #10000001B</span><br><span class="line">ADD A, #1</span><br></pre></td></tr></table></figure>
<p>可以看到两种计算的指令是完全相同的，结果均为<code>1000 0010B</code>，如果认为两个数为无符号，则答案就是130，反之，则为<code>1000 0010B</code>的原码-126，寄存器中的数到底有无符号，完全取决于使用者看待问题的方式，使用者认为这是有符号，那么它就是有符号数。</p>
<p>如果有符号数参与计算时发生了溢出，OV标志位自然也就会被置为1。但由于CPU不区分有符号数和无符号数（有符号和无符号的指令是相同的），因此，即使OV发生了变化，如果使用者认为这两个数是无符号数，那么OV的变化对于使用者而言就毫无意义，忽略即可。</p>
<p>扩展阅读：<br>王爽《汇编语言》 11.3 SF标志 第215页</p>
<p>2019年10月26日</p>
<hr>
<h2 id="线译码、部分译码和全译码"><a href="#线译码、部分译码和全译码" class="headerlink" title="线译码、部分译码和全译码"></a>线译码、部分译码和全译码</h2><p><del>暑假跟着张老师做实验箱时就没搞的很清楚，上课时听懂以后没复习又全忘了Orz</del><br>回顾一下，MCS-51有三条总线——地址总线（P0和P2）、数据总线（P0）和控制总线（P3）。如果想要让单片机连接存储器或其它芯片，只需将三条总线直接和芯片上对应的引脚连在一起即可，大致按照以下规则：</p>
<p><strong>数据总线连接外围芯片用于传输数据的引脚</strong><br><del>废话</del></p>
<p><strong>控制总线连接外围芯片控制信号的相关引脚</strong></p>
<span style="TEXT-DECORATION: overline">RD</span>连接数据存储器芯片的读有效信号引脚<span style="TEXT-DECORATION: overline">RD</span>或<span style="TEXT-DECORATION: overline">OE</span><br><span style="TEXT-DECORATION: overline">WR</span>连接数据存储器芯片的写有效信号引脚<span style="TEXT-DECORATION: overline">WR</span>或<span style="TEXT-DECORATION: overline">WE</span><br><span style="TEXT-DECORATION: overline">PSEN</span>连接程序存储器芯片的输出有效有信号引脚<span style="TEXT-DECORATION: overline">OE</span>

<p><strong>地址总线连接外围芯片片选和字选相关引脚</strong><br>引入两个概念：<em>片选</em>和<em>字选</em></p>
<p><strong>片选</strong>：假设有多个芯片连接在总线上，选中某个芯片（从而允许其工作），<span style="TEXT-DECORATION: overline">CS</span>或<span style="TEXT-DECORATION: overline">CE</span>引脚一般作为片选引脚。<br><strong>字选</strong>：在已经选中了某个芯片的前提下，选择该芯片内的某个存储单元。</p>
<p>显然，对于所有要挂载在总线上工作的芯片，字选可以没有，但片选是必须的。但对于存储器等内部具有多个存储单元的芯片，或是8255、ADC0809这样需要选择通道的芯片，字选是必须的。</p>
<p>更具体一点，片选如何实现呢？</p>
<p>实际操作时，外接芯片的片选和字选引脚都用地址线来实现，被称之为片选地址线。假设51单片机外连接了1个4K容量的数据存储器和<code>n-1</code>个只需片选不需要字选的芯片，则单片机就需要10条地址线作为字选地址线。而剩下的6条地址线则用作片选地址线来选中其他芯片。</p>
<p>片选地址线可以直接悬空，也可以直接连接芯片的片选端，还可以先连接一个译码器，再将译码器的输出端连接到芯片的片选端。因而可分为三种方式连接地址线：线译码方式、部分译码方式和全译码方式。</p>
<p><strong>线译码方式</strong><br>片选地址线中的某一条地址线直接与芯片的片选引脚连接，其它片选引脚根据需要可悬空。</p>
<p><strong>部分译码方式</strong><br>片选地址线一部分参与译码，其余部分悬空。</p>
<p><strong>全译码方式</strong><br>所有片选地址线全部参与译码。</p>
<p>参考资料：<br><a href="http://www2.hhstu.edu.cn/dzsfzx/upload/2013/9/e/1.02%20MCS-51%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86%E3%80%81%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%BA%94%E7%94%A81.pdf" target="_blank" rel="noopener">王质朴, 吕运朋. MCS-51单片机原理、接口及应用</a><br><a href="https://books.google.com/books?id=MQ8oDwAAQBAJ&amp;pg=PA183&amp;lpg=PA183&amp;dq=%E7%BA%BF%E8%AF%91%E7%A0%81+%E9%83%A8%E5%88%86%E8%AF%91%E7%A0%81&amp;source=bl&amp;ots=Aa0YiN-AgE&amp;sig=ACfU3U0WTCIGW3zZa57U3pZaX11MLCwy3g&amp;hl=zh-CN&amp;sa=X&amp;ved=2ahUKEwiq6b-Prp7mAhVFs54KHd3iBjMQ6AEwAnoECAcQAQ#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">王欣飞, 谢龙汉, 谢锋然. 51单片机原理与程序设计</a></p>
<p>2019年12月5日</p>
<hr>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/20/笔记/" rel="next" title="笔记">
                <i class="fa fa-chevron-left"></i> 笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/18/DS1302/" rel="prev" title="DS1302">
                DS1302 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Y.-Y. Wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cx51-的数据类型"><span class="nav-number">1.</span> <span class="nav-text">Cx51 的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器-计数器"><span class="nav-number">2.</span> <span class="nav-text">定时器 / 计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定时器"><span class="nav-number">2.1.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数器"><span class="nav-number">2.2.</span> <span class="nav-text">计数器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断"><span class="nav-number">3.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断允许控制寄存器"><span class="nav-number">3.1.</span> <span class="nav-text">中断允许控制寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断优先级控制寄存器"><span class="nav-number">3.2.</span> <span class="nav-text">中断优先级控制寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断函数"><span class="nav-number">3.3.</span> <span class="nav-text">中断函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串口通信"><span class="nav-number">4.</span> <span class="nav-text">串口通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">一些基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UART"><span class="nav-number">4.2.</span> <span class="nav-text">UART</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RS-232"><span class="nav-number">4.3.</span> <span class="nav-text">RS-232</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USB"><span class="nav-number">4.4.</span> <span class="nav-text">USB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行口控制寄存器"><span class="nav-number">4.5.</span> <span class="nav-text">串行口控制寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行口数据缓冲寄存器"><span class="nav-number">4.6.</span> <span class="nav-text">串行口数据缓冲寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串口通信的具体实现"><span class="nav-number">4.7.</span> <span class="nav-text">串口通信的具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种不同的换行符"><span class="nav-number">4.8.</span> <span class="nav-text">两种不同的换行符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cx51中的坑"><span class="nav-number">5.</span> <span class="nav-text">Cx51中的坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MCS-51的寻址方式"><span class="nav-number">6.</span> <span class="nav-text">MCS-51的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#立即寻址"><span class="nav-number">6.1.</span> <span class="nav-text">立即寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接寻址"><span class="nav-number">6.2.</span> <span class="nav-text">直接寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器寻址"><span class="nav-number">6.3.</span> <span class="nav-text">寄存器寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器间接寻址"><span class="nav-number">6.4.</span> <span class="nav-text">寄存器间接寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基址寄存器加变址寄存器间接寻址"><span class="nav-number">6.5.</span> <span class="nav-text">基址寄存器加变址寄存器间接寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对寻址"><span class="nav-number">6.6.</span> <span class="nav-text">相对寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位寻址"><span class="nav-number">6.7.</span> <span class="nav-text">位寻址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MCS-51-的存储器结构"><span class="nav-number">7.</span> <span class="nav-text">MCS-51 的存储器结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MCS-51-的程序存储器"><span class="nav-number">7.1.</span> <span class="nav-text">MCS-51 的程序存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCS-51-的数据存储器"><span class="nav-number">7.2.</span> <span class="nav-text">MCS-51 的数据存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keil-uVision5-查看和修改程序-数据存储器"><span class="nav-number">7.3.</span> <span class="nav-text">Keil uVision5 查看和修改程序\数据存储器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MCS-51的伪指令"><span class="nav-number">8.</span> <span class="nav-text">MCS-51的伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORG和END"><span class="nav-number">8.1.</span> <span class="nav-text">ORG和END</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DB、DW和DS"><span class="nav-number">8.2.</span> <span class="nav-text">DB、DW和DS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EQU、DATA和BIT"><span class="nav-number">8.3.</span> <span class="nav-text">EQU、DATA和BIT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MCS-51的指令"><span class="nav-number">9.</span> <span class="nav-text">MCS-51的指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于MCS-51汇编中有符号数和无符号数的问题"><span class="nav-number">10.</span> <span class="nav-text">关于MCS-51汇编中有符号数和无符号数的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线译码、部分译码和全译码"><span class="nav-number">11.</span> <span class="nav-text">线译码、部分译码和全译码</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Y.-Y. Wang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.7.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color='30,30,30' opacity='0.4' zIndex='-1' count='45' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  


  





  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":125,"height":250},"mobile":{"show":true}});</script></body>
</html>
