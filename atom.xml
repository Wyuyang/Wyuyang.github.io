<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Y.-Y. Wang&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangyuyang.me/"/>
  <updated>2019-10-18T11:59:45.969Z</updated>
  <id>http://wangyuyang.me/</id>
  
  <author>
    <name>Y.-Y. Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PTA-数据结构与算法题目集</title>
    <link href="http://wangyuyang.me/2019/10/08/PTA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
    <id>http://wangyuyang.me/2019/10/08/PTA-数据结构与算法题目集/</id>
    <published>2019-10-08T00:44:09.000Z</published>
    <updated>2019-10-18T11:59:45.969Z</updated>
    
    <content type="html"><![CDATA[<p>学习数据结构时做的练习题。</p><a id="more"></a><h2 id="6-2-顺序表操作集"><a href="#6-2-顺序表操作集" class="headerlink" title="6-2 顺序表操作集"></a>6-2 顺序表操作集</h2><p>本题要求实现顺序表的操作集。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>各个操作函数的定义为：</p><p>List MakeEmpty()：创建并返回一个空的线性表；</p><p>Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR；</p><p>bool Insert( List L, ElementType X, Position P )：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false；</p><p>bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    L = MakeEmpty();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        <span class="keyword">if</span> ( Insert(L, X, <span class="number">0</span>)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Insertion Error: %d is not in.\n"</span>, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Finding Error: %d is not in.\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is at position %d.\n"</span>, X, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P);</span><br><span class="line">        <span class="keyword">if</span> ( Delete(L, P)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Deletion Error.\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> ( Insert(L, <span class="number">0</span>, P)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Insertion Error: 0 is not in.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FULL Insertion Error: <span class="number">6</span> is <span class="keyword">not</span> in.</span><br><span class="line">Finding Error: <span class="number">6</span> is <span class="keyword">not</span> in.</span><br><span class="line"><span class="number">5</span> is at position <span class="number">0.</span></span><br><span class="line"><span class="number">1</span> is at position <span class="number">4.</span></span><br><span class="line">POSITION <span class="number">-1</span> EMPTY Deletion Error.</span><br><span class="line">FULL Insertion Error: <span class="number">0</span> is <span class="keyword">not</span> in.</span><br><span class="line">POSITION <span class="number">6</span> EMPTY Deletion Error.</span><br><span class="line">FULL Insertion Error: <span class="number">0</span> is <span class="keyword">not</span> in.</span><br></pre></td></tr></table></figure></p><p>改了很多次，最后发现是printf()函数输出内容大小写问题……</p><p>下附自己写的答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    </span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(L)                                                  <span class="comment">// 如不检查 L 是否为空，VS2019 会报 C6011 警告</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Last == <span class="number">-1</span> || L == <span class="literal">NULL</span>)                        <span class="comment">// 线性表为空或指针为 NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L-&gt;Last; i++)                     <span class="comment">// 从 0 开始遍历数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X == L-&gt;Data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Last == MAXSIZE - <span class="number">1</span>)                            <span class="comment">// 线性表已满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (P &lt; <span class="number">0</span> || P &gt; L-&gt;Last+<span class="number">1</span>)                       <span class="comment">// 插入位置错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ILLEGAL POSITION"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L-&gt;Last; i &gt;= P; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Data[i + <span class="number">1</span>] = L-&gt;Data[i];                   <span class="comment">// 右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L-&gt;Data[P] = X;</span><br><span class="line">        L-&gt;Last++;                                         <span class="comment">// 更新表中元素数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span> || P &gt; L-&gt;Last)                              <span class="comment">// 删除位置错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"POSITION %d EMPTY"</span>, P);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = P; i &lt; L-&gt;Last; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Data[i] = L-&gt;Data[i + <span class="number">1</span>];                   <span class="comment">// 左移</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        L-&gt;Last--;                                         <span class="comment">// 更新表中元素数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一句话需要注意一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的</span></span><br><span class="line">L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br></pre></td></tr></table></figure><p>正确的代码是我之前的写法，提交后也能通过检测，确实没问题。但后来第二次写程序时写成了第二种写法，发现不对。</p><p>正确的这一行代码的目的很简单，就是向操作系统申请一块内存，这块内存的大小要能放下一个结构体，同时定义一个指向这块内存首地址的指针L。因此这块内存的长度和L指向的数据类型（即struct LNode）应当相等（长了浪费，短了不够）。</p><p>所以正确的这一行代码实际上干了三件事：</p><ul><li>求出结构体类型的长度（这里为24字节）</li><li>使用malloc()函数获取24个字节的内存，并返回一个void类型指针</li><li>将malloc()返回的指针强制转换为List类型</li></ul><p>那么再继续看这两行代码，它们的区别实际上在于内存长度的不同，sizeof(struct LNode)的返回值为24，而List指针长度为4。显然，第二种写法中只申请了一块4字节的地址，无法容纳下要存放的结构体，是错误的。</p><p><del>总结：还是malloc()函数不熟</del></p><p>2019年10月8日 寒露</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习数据结构时做的练习题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AVR单片机熔丝位设置</title>
    <link href="http://wangyuyang.me/2019/10/06/AVR%E5%8D%95%E7%89%87%E6%9C%BA%E7%86%94%E4%B8%9D%E4%BD%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>http://wangyuyang.me/2019/10/06/AVR单片机熔丝位设置/</id>
    <published>2019-10-06T06:58:23.000Z</published>
    <updated>2019-10-07T07:28:41.903Z</updated>
    
    <content type="html"><![CDATA[<p>第一次用AVR单片机，试着用Atmega32U4搭建了一个最小系统板，从datasheet里了解到AVR单片机还有一个叫做熔丝（fuse）的东西，记一下学到的知识。<br><a id="more"></a> </p><h2 id="什么是熔丝？"><a href="#什么是熔丝？" class="headerlink" title="什么是熔丝？"></a>什么是熔丝？</h2><p>fuse实际是保险丝的意思，但中文资料一般将avr芯片中的fuse翻译作熔丝。这里的熔丝和电工里用到的保险丝几乎没什么关系，并不是用于过载保护，而是指芯片上一个长度为3字节的特殊存储区域。在这个存储区域内保存的数据决定着该芯片的工作方式，从这个角度来讲，有点类似于51单片机中的一些特殊功能寄存器（如TMOD等）。该区域中保存的数据并不会因为断电而消失，而且单片机正常运行时不能修改。因此正确配置熔丝位（fuse bits）是十分重要的。事实上，如果设置熔丝位时设置错误，会有让单片机直接锁死的风险，届时只能采取一些特殊措施来解锁芯片。</p><h2 id="熔丝位的具体设置"><a href="#熔丝位的具体设置" class="headerlink" title="熔丝位的具体设置"></a>熔丝位的具体设置</h2><p>前面提到，fuse是指芯片上一个长度为3字节的特殊存储区域。所以对熔丝的修改，实际上就是修改该区域内存储的数据。先随便来看一个Atmega32U4的熔丝位设置：</p><ul><li>Fuse Bits:  0xFF9941</li></ul><p>这是一个长度为3字节的数，实际上为三部分构成：</p><ul><li>Low:        0x41</li><li>High:       0x99</li><li>Extend:     0xFF</li></ul><p>对应的二进制数为</p><ul><li>Low:        0100  0001</li><li>High:       1001  1001</li><li>Extend:     1111  1111</li></ul><p>这里熔丝低位和熔丝高位中的每一位都有着特殊含义，如熔丝低位中的0001是指单片机工作时使用芯片内部频率为1MHz的RC振荡器。当使用有源/无源的高频/低频晶振时，这四位也要进行相应的修改。具体的设置可参考datasheet。</p><p>熔丝扩展位里的低四位和前两者一样，有着特殊的含义。但扩展位的高四位没有任何功能。</p><p>2019年10月6日</p><hr><p><a href="http://www.ladyada.net/learn/avr/fuses.html" target="_blank" rel="noopener">http://www.ladyada.net/learn/avr/fuses.html</a><br><a href="http://blog.sina.com.cn/s/blog_870ad0e00100tug9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_870ad0e00100tug9.html</a><br><a href="https://blog.csdn.net/wowocpp/article/details/80715172" target="_blank" rel="noopener">https://blog.csdn.net/wowocpp/article/details/80715172</a><br><a href="https://www.amobbs.com/thread-4644881-1-1.html" target="_blank" rel="noopener">https://www.amobbs.com/thread-4644881-1-1.html</a><br><a href="https://www.amobbs.com/forum.php?mod=viewthread&amp;tid=29462" target="_blank" rel="noopener">https://www.amobbs.com/forum.php?mod=viewthread&amp;tid=29462</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次用AVR单片机，试着用Atmega32U4搭建了一个最小系统板，从datasheet里了解到AVR单片机还有一个叫做熔丝（fuse）的东西，记一下学到的知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DS1302</title>
    <link href="http://wangyuyang.me/2019/08/18/DS1302/"/>
    <id>http://wangyuyang.me/2019/08/18/DS1302/</id>
    <published>2019-08-18T01:20:36.000Z</published>
    <updated>2019-08-23T06:07:00.338Z</updated>
    
    <content type="html"><![CDATA[<p>课程需要，学习DS1302的用法。</p><a id="more"></a> <h2 id="Datasheet"><a href="#Datasheet" class="headerlink" title="Datasheet"></a>Datasheet</h2><p><a href="https://datasheets.maximintegrated.com/en/ds/DS1302.pdf" target="_blank" rel="noopener">DS1302-Datasheet</a><br><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2007&amp;filename=NKDZ200702019" target="_blank" rel="noopener">Application Note 58: Crystal Considerations for Dallas Real-Time Clocks</a></p><hr><h2 id="Vcc1和Vcc2的区别"><a href="#Vcc1和Vcc2的区别" class="headerlink" title="Vcc1和Vcc2的区别"></a>Vcc1和Vcc2的区别</h2><p>一开始，我是觉得Vcc1和Vcc2没啥区别随便接电源，看到datasheet里这段话更是觉得没有区别：</p><blockquote><p>Vcc2<br>Primary Power-Supply Pin in Dual Supply Configuration. VCC1 is connected to a backup source to maintain the time and date in the absence of primary power. The DS1302 operates from the larger of VCC1 or VCC2. When VCC2 is greater than VCC1 + 0.2V, VCC2 powers the DS1302. When VCC2 is less than VCC1, VCC1 powers the DS1302.</p></blockquote><p>但是看到Vcc1的引脚说明就知道还是有一点区别的：</p><blockquote><p>Vcc1<br>Low-Power Operation in Single Supply and Battery-Operated Systems and LowPower Battery Backup. In systems using the trickle charger, the rechargeable energy source is connected to this pin. UL recognized to ensure against reverse charging current when used with a lithium battery. </p></blockquote><p>简单地说就是Vcc1支持给电池充电（如果使用了可充电电池的话），Vcc2不支持。</p><hr><h2 id="晶振负载电容（load-capacitance）的影响"><a href="#晶振负载电容（load-capacitance）的影响" class="headerlink" title="晶振负载电容（load capacitance）的影响"></a>晶振负载电容（load capacitance）的影响</h2><p>首先，什么是负载电容？晶振的负载电容并非指连接在晶振外部的电容，而是指晶振本身串接在电路中的等效电容值。关于负载电容的更详细的内容，可参考<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2007&amp;filename=NKDZ200702019" target="_blank" rel="noopener">王跃, 张晰泊, 王彬, 高清运. 用于RTC的32.768 kHz晶振电路的设计</a></p><p>根据datasheet：</p><blockquote><p>Connections for Standard 32.768kHz Quartz Crystal. The internal oscillator is designed for operation with a crystal having a specified load capacitance of 6pF.<br>For more information on crystal selection and crystal layout considerations, refer to Application Note 58: Crystal Considerations for Dallas Real-Time Clocks. </p></blockquote><p>选择32.768kHz晶振很好理解，但是这里强调了晶振的负载电容为6pF，原因没有作详细解释。于是我就去查了一下文中提到的<a href="http://www.emesystems.com/pdfs/parts/DS1307_xtal.pdf" target="_blank" rel="noopener">Application Note 58: Crystal Considerations for Dallas Real-Time Clocks</a>，这篇文档里给出了答案：</p><blockquote><p>The frequency accuracy of a crystal-based oscillator circuit is mainly dependent upon the accuracy of the crystal and the accuracy of the match between the crystal and the oscillator capacitive load. If the capacitive load is less than the crystal was designed for, the oscillator runs fast. If the capacitive load is greater than what the crystal was designed for, the oscillator runs slow. </p><p>……</p><p>Wrong crystal. An RTC typically runs fast if a crystal with a specified load capacitance (CL) greater than the RTC-specified load capacitance is used. The severity of the inaccuracy is dependent on the value of the CL. For example, using a crystal with a CL of 12pF on an RTC designed with a 6pF CL causes the RTC to be about 3 to 4 minutes per month fast.</p></blockquote><p>也就是说，如果使用负载电容大于6pF的晶振，DS1302计时会更快。反之，如果小于6pF,计时会变慢。个人觉得如果对计时精准度没有较高的要求，完全可以忽略这一问题，用12pF的晶振来提供时钟信号也不过每个月快3到4分钟而已。</p><p>如果过晶振的负载电容不等于6pF，又希望计时精度更高，也可以选择通过串/并联电容进行修正，详见<a href="http://www.cqvip.com/qk/83588x/200101/4871613.html" target="_blank" rel="noopener">屠运武, 谷松, 王甬生, 钟英华. 时钟芯片DS1302可靠起振的方法</a>。</p><p>2019年8月18日</p><hr><h2 id="向-DS1302-中写入数据"><a href="#向-DS1302-中写入数据" class="headerlink" title="向 DS1302 中写入数据"></a>向 DS1302 中写入数据</h2><p>DS1302一共有三个引脚用于通信：</p><ul><li>CE</li><li>I/O</li><li>SCLK</li></ul><p>其中CE在datasheet的早期版本中也被叫做RST，虽然名字改了但功能未变。对DS1302读写数据时CE必须输入高电平。</p><p>SCLK为时钟信号输入，用于保证数据发送方和接收方的同步。</p><p>I/0引脚则是真正用于传输数据的引脚，数据传输时先发送低位然后才发送高位。</p><p>根据datasheet：</p><blockquote><p>COMMAND BYTE<br>Figure 3 shows the command byte. A command byte initiates each data transfer. The MSB (bit 7) must be a logic 1. If it is 0, writes to the DS1302 will be disabled. Bit 6 specifies clock/calendar data if logic 0 or RAM data if logic 1. Bits 1 to 5 specify the designated registers to be input or output, and the LSB (bit 0) specifies a write operation (input) if logic 0 or read operation (output) if logic 1. The command byte is always input starting with the LSB (bit 0).</p><p>DATA INPUT<br>Following the eight SCLK cycles that input a write command byte, a data byte is input on the rising edge of the next eight SCLK cycles. Additional SCLK cycles are ignored should they inadvertently occur. Data is input starting with bit 0.</p></blockquote><p>简单地说，就是每次向DS1302发送数据，都只能发送两个字节。先发送的第一个字节是控制命令，第二个字节才是真正想要传送的数据。</p><p>控制命令中，第七位必须为1，否则写入会被禁用无效；第六位用于选择RAM或clock/calender；第一到第五位是要写入（读取）的寄存器的地址；最低位则用于指示读取数据（为1）还是写入数据（为0）。套用微机原理中的概念，I/O引脚同时充当了数据总线、地址总线和控制总线的作用。</p><p>概括：写入时钟数据时，控制命令的构成为（从高到低）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BIN: 1 0 xxxxx 0</span><br><span class="line">// `xxxxx`为目标寄存器的地址。</span><br><span class="line"></span><br><span class="line">HEX: 0x80 | xxxx</span><br><span class="line">// `xxxx`为目标寄存器的地址（十六进制）。</span><br></pre></td></tr></table></figure><hr><h2 id="从-DS1302-中读取数据"><a href="#从-DS1302-中读取数据" class="headerlink" title="从 DS1302 中读取数据"></a>从 DS1302 中读取数据</h2><p>和写入数据类似，首先要发送一个控制命令，命令包含要读取的寄存器地址、指示本次操作的目的为读取信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BIN: 1 0 xxxxx 1</span><br><span class="line">// `xxxxx`为目标寄存器的地址。</span><br><span class="line"></span><br><span class="line">HEX: 0x80 | xxxx</span><br><span class="line">// `xxxx`为目标寄存器的地址（十六进制）。</span><br></pre></td></tr></table></figure><p>2019年8月21日</p><hr><h2 id="DS1302-中的寄存器"><a href="#DS1302-中的寄存器" class="headerlink" title="DS1302 中的寄存器"></a>DS1302 中的寄存器</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程需要，学习DS1302的用法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MCS 51</title>
    <link href="http://wangyuyang.me/2019/08/06/MCS-51/"/>
    <id>http://wangyuyang.me/2019/08/06/MCS-51/</id>
    <published>2019-08-06T00:29:51.000Z</published>
    <updated>2019-10-21T03:18:13.957Z</updated>
    
    <content type="html"><![CDATA[<p>正式开始学习8051及C51。</p><h2 id="Cx51-的数据类型"><a href="#Cx51-的数据类型" class="headerlink" title="Cx51 的数据类型"></a>Cx51 的数据类型</h2><p>摘自[Cx51 User’s Guide][1]<br><a id="more"></a> </p><table><thead><tr><th>Data Types</th><th>Bits</th><th>Bytes</th><th>Value Range</th></tr></thead><tbody><tr><td>bit</td><td>1</td><td></td><td>0 to 1</td></tr><tr><td>signed char</td><td>8</td><td>1</td><td>-128 — +127</td></tr><tr><td>unsigned char</td><td>8</td><td>1</td><td>0 — 255</td></tr><tr><td>enum</td><td>8 / 16</td><td>1 or 2</td><td>-128 — +127 or -32768 — +32767</td></tr><tr><td>signed short int</td><td>16</td><td>2</td><td>-32768 — +32767</td></tr><tr><td>unsigned short int</td><td>16</td><td>2</td><td>0 — 65535</td></tr><tr><td>signed int</td><td>16</td><td>2</td><td>-32768 — +32767</td></tr><tr><td>unsigned int</td><td>16</td><td>2</td><td>0 — 65535</td></tr><tr><td>signed long int</td><td>32</td><td>4</td><td>-2147483648 — +2147483647</td></tr><tr><td>unsigned long int</td><td>32</td><td>4</td><td>0 — 4294967295</td></tr><tr><td>float</td><td>32</td><td>4</td><td>±1.175494E-38 — ±3.402823E+38</td></tr><tr><td>double</td><td>32</td><td>4</td><td>±1.175494E-38 — ±3.402823E+38</td></tr><tr><td>sbit</td><td>1</td><td></td><td>0 or 1</td></tr><tr><td>sfr</td><td>8</td><td>1</td><td>0 — 255</td></tr><tr><td>sfr16</td><td>16</td><td>2</td><td>0 — 65535</td></tr></tbody></table><p>仔细看一下表，实际上Cx51对ANSI C是做了简化，在Cx51中，有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int = short int</span><br><span class="line">double = float</span><br></pre></td></tr></table></figure></p><p>2019年8月6日</p><hr><h2 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器 / 计数器"></a>定时器 / 计数器</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>51单片机内有两个16位定时器/计数器T0和T1，与之相关的特殊功能寄存器有三个，分别是：</p><ul><li>定时值存储寄存器 TH / TL</li><li>定时器控制寄存器 TCON</li><li>定时器模式寄存器 TMOD</li></ul><p>三种寄存器的功能也比较明显，看名字就知道，第一个用来设定定时器开始计数的初值；第二个控制定时器的启动/停止，此外还可以指示定时器是否发生溢出；最后一个寄存器指定定时器的工作模式，比如定时器模式和计数器模式、8/16位定时器等。</p><p>显然，由三个寄存器的功能可以看出，使用定时器的步骤（不使用中断）：</p><ol><li>设定TMOD参数    （指定是定时器还是计数器，以及定时器/计数器的工作模式，一般16位工作模式即可满足需求）</li><li>设定TH / TL的初始值    （有点类似数电课程设计里用74LS90和74LS192芯片做计数器）</li><li>设定TCON参数    （让定时器开始计数）</li><li>校验TCON参数</li></ol><p>事实上前三步已经实现了定时计数功能，但是，只通过前三步我们并不能知道计时是否已经结束。而TCON中的TF位可以指示定时器是否溢出（有点像计数器芯片里的借位输出端BO），通过检测TF变量的变化次数，就可以知道定时器发生了多少次溢出。而发生一次溢出所需要的时间是确定的（与TH / TL初值和时钟信号频率有关），因此很容易就知道定时器已经计数了多长时间。</p><p>其它补充知识：</p><ul><li>三个寄存器各位的复位值均为0。</li><li>TMOD不可位寻址，另外两种寄存器可位寻址。</li><li>TMOD中GATE置为0禁用定时器，置为1解除禁用状态。</li><li>16位定时器可应付几乎所有场景，此时直接令 TMOD = 0x01 即可。 </li><li>TCON的TR置为1后开始计数，置为0后暂停计数。</li><li>每次计数时，每经过一个机器周期，定时器值会增加1。</li><li>暂停计数时定时器的值不会被重置，还会保持暂停前的状态。</li></ul><p>附代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">char delay(unsigned int time)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入参数单位为毫秒</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;               <span class="comment">//清零TMOD低四位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;               <span class="comment">//设定T0为16位模式定时器</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;</span><br><span class="line">    TL0 = <span class="number">0x18</span>;                 <span class="comment">//设置定时器初始值，满足每次循环用时1ms</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                    <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF0 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;</span><br><span class="line">            TH0 = <span class="number">0xFC</span>;</span><br><span class="line">            TL0 = <span class="number">0x18</span>;         <span class="comment">//设置每次溢出后定时器初始值</span></span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面是使用查询法实现定时器定时功能，下面是利用中断来实现定时功能的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED0 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    TMOD = <span class="number">0x01</span>;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt_timer</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与查询法相比较，主要有以下几点不同之处：</p><ol><li>查询法中TF位需要在程序中手动置0，而在中断法中，一旦程序进入了中断函数，TF位会被自动置0。</li><li>查询法中用于统计溢出次数的变量count可以和定时函数封装在同一个函数中，而中断法中应将之申明为全局变量（因为中断函数禁止传参，见下文）。</li><li>中断函数不需要声明。</li></ol><p>2019年8月6日</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>就本质上来讲，定时器和计数器并没有太大的区别。唯一的区别在于，定时器是对机器周期进行计数，而计数器是对输入Tn的脉冲进行计数，二者使用方法几乎完全相同，只需将TMOD中的C/T位置1即可。<br>下附代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BEEP = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;           <span class="comment">//清零TMOD高四位</span></span><br><span class="line">    TMOD |= <span class="number">0x60</span>;           <span class="comment">//设定T1为8位自动重装模式计数器</span></span><br><span class="line">    TH1 = <span class="number">256</span> - number;</span><br><span class="line">    TL1 = <span class="number">256</span> - number;     <span class="comment">//设置计数器初始值，满足每计数十次即溢出</span></span><br><span class="line">    TR1 = <span class="number">1</span>;                <span class="comment">//开始计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF1 = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            TH1 = <span class="number">256</span> - number;</span><br><span class="line">            TL1 = <span class="number">256</span> - number;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == number)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                BEEP = <span class="number">0</span>;   <span class="comment">//计数number次后蜂鸣提示</span></span><br><span class="line">                delay(<span class="number">50</span>);</span><br><span class="line">                BEEP = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end of if (TF1 == 1) </span></span><br><span class="line">    &#125;<span class="comment">//end of while (1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2019年8月10日</p><hr><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断的优先级有两种，当程序执行时，若低优先级中断执行时，发生了高优先级中断，则：</p><ul><li>固有优先级：处理完低优先级中断后才进入高优先级中断，即不发生中断嵌套。</li><li>抢占优先级：打断低优先级中断并立刻进入高优先级中断，处理完高优先级中断后，返回低优先级中断。</li></ul><p>根据[Cx51 User’s Guide][1]，8051内置六个标准中断源：</p><table><thead><tr><th>InterruptNumber</th><th>Description</th><th>Address</th></tr></thead><tbody><tr><td>0</td><td>EXTERNAL INT 0</td><td>0003h</td></tr><tr><td>1</td><td>TIMER/COUNTER 0</td><td>000Bh</td></tr><tr><td>2</td><td>EXTERNAL INT 1</td><td>0013h</td></tr><tr><td>3</td><td>TIMER/COUNTER 1</td><td>001Bh</td></tr><tr><td>4</td><td>SERIAL PORT</td><td>0023h</td></tr><tr><td>5</td><td>TIMER/COUNTER 2 (8052)</td><td>002Bh</td></tr></tbody></table><p>与之相关的寄存器有两个（参考STC89C52的datasheet中 图6-1 STC89C52系列中断系统结构图）：</p><ul><li>中断允许控制寄存器        IE，XICON寄存器</li><li>中断优先级控制寄存器      IP，XICON，IPH寄存器</li></ul><blockquote><p>注：XICON，IPH寄存器为STC89C52独有，可实现4个中断优先级，而传统的8051单片机只能实现2级中断优先级</p></blockquote><p>显然，由中断相关寄存器的名称可以知道，要想使用中断，首先要在中断允许寄存器中启用中断功能，然后调整中断优先级寄存器中优先级的设定（也可不调整直接使用默认优先级）。</p><p>当单片机收到中断信息后，应当转去执行中断信息的处理程序，但是单片机是如何根据中断信息找到处理程序的入口呢？显然，在单片机内部，中断信息和其处理程序建立了某种联系。上表中每一个中断源都对应唯一的一个InterruptNumber——中断类型码，单片机会根据中断类型码，在中断向量表中找到对应的处理程序入口地址，进而开始执行中断服务程序。</p><h3 id="中断允许控制寄存器"><a href="#中断允许控制寄存器" class="headerlink" title="中断允许控制寄存器"></a>中断允许控制寄存器</h3><p><em>IE: Interrupt Enable  中断允许寄存器  可位寻址</em><br><em>Adress: A8H</em></p><p>单片机对任意中断源是否做出响应均由该寄存器进行控制。</p><ul><li>EA 总中断控制位</li><li>ET0 定时器/计数器 0 中断允许位</li><li>ET1 定时器/计数器 1 中断允许位</li><li>EX0 外部中断 0 中断允许位</li><li>EX1 外部中断 1 中断允许位</li><li>ES 串行口中断允许位</li></ul><p>置1为允许中断，置0为禁止中断。</p><h3 id="中断优先级控制寄存器"><a href="#中断优先级控制寄存器" class="headerlink" title="中断优先级控制寄存器"></a>中断优先级控制寄存器</h3><p><em>IP: Interrupt Priority  中断优先级寄存器  可位寻址</em><br><em>Adress: B8H</em></p><p>各个中断源属于两级中断中的哪一级由该寄存器控制。</p><ul><li>PT0 定时器/计数器 0 中断优先级控制位</li><li>PT1 定时器/计数器 1 中断优先级控制位</li><li>PX0 外部中断 0 中断优先级控制位</li><li>PX1 外部中断 1 中断优先级控制位</li><li>PS 串行口中断优先级控制位</li></ul><p>置1为高优先级中断，置0为低优先级中断。</p><p>若两中断源被设定为相同优先级，当两中断源同时请求中断时，按照默认优先级别响应中断。</p><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>中断函数的调用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function_Name</span><span class="params">()</span> interrupt Interrupt_Number <span class="keyword">using</span> Register_Bank</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中<code>Interrupt_Number</code>参考上表，无论是否为默认优先级，该值均不变。<br><code>using Register_Bank</code>语句可省略。</p><p>即使中断函数写在main函数后面，也不需要在main函数前先对中断函数进行声明。</p><p>如果定义两个中断处理函数时，使他们能对同一个中断源进行响应（如两个函数声明时使用了相同的中断向量<code>interrupt 0</code>），那么程序在执行时会发生什么？<br>测试了一下，这样的程序能够通过Keil编译（虽然会有警告<code>WARNING L5: CODE SPACE MEMORY OVERLAP</code>，实际上Keil的官方文档中，[对WARING L5的描述][2]也提到了这种情况，但并未说明后果），暂未测试实际执行情况。</p><p>一些关于中断函数的注意事项：</p><blockquote><p>No function arguments may be specified for an interrupt function. The compiler emits an error message if an interrupt function is declared with any arguments.<br>声明中断函数时不能有参数，否则编译器会报错。</p><p>Interrupt function declarations may not include a return value. They must be declared as void. The compiler emits an error message if any attempt is made to define a return value for the interrupt function. The implicit int return value, however, is ignored by the compiler.<br>声明中断函数时不能包含返回值。中断函数必须声明为 void 类型。对于任何试图将中断函数声明为有返回值类型的函数的行为，编译器都会报错。不过，如果返回值为隐式 int 类型则会被编译器忽略。</p><p>The compiler recognizes direct calls to interrupt functions and rejects them. It is pointless to call interrupt procedures directly, because exiting the procedure causes execution of the RETI instruction which affects the hardware interrupt system of the 8051 chip. Because no interrupt request on the part of the hardware existed, the effect of this instruction is indeterminate and usually fatal. Do not call an interrupt function indirectly through a function pointer.<br>编译器会识别到任何对中断函数的直接调用并报错。直接调用中断程序是没有意义的，因为退出程序会导致RETI指令的执行， 从而影响8051芯片的硬件中断系统。由于硬件部分并没有中断请求，因此该指令的效果是不确定的，通常是致命的。不要通过函数指针间接调用中断函数。</p><p>The Cx51 Compiler allows interrupt numbers within the 0-31 range. Refer to your 8051 derivative document to determine which interrupts are available.<br>Cx51编译器允许0-31范围内的中断位。请参阅8051衍生文档以确定可用的中断。</p></blockquote><p>2019年8月7日 七夕</p><hr><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>通信可以分为两大类：</p><ul><li>串行传输：一次发送/接收一个位<ul><li>异步传输</li><li>同步传输</li><li>等时传输</li></ul></li><li>并行传输：一次发送/接收多个位</li></ul><p>以8051为例，8051的RXD和TXD口一次只能接收/发送一个位，为串行传输。<br>以8086为例，8086的数据总线宽度为16，一次可以向内存中读取/写入16位数据，为并行传输。</p><p>直觉上觉得并行传输速度快，更先进。查了一下结果发现居然还真不是这样，串行传输反而有取代并行传输的趋势。</p><p>PCI和PATA都是并行传输，家里十几年前买的电脑里用的非常宽的硬盘线就是PATA接口，现在已经被淘汰。<br>PCI Express（即PCIe）和SATA均为串行传输，笔记本里的Intel 530和Samsung 860EVO就分别是PCIe和SATA接口，体积很小，但速度依然很快。</p><p>串行通信制式的概念：</p><ul><li>单工：接收端和发送端固定，数据只能从发送端传输到接收端，二者只需一条线连接即可。</li><li>半双工：在某一时刻接收端和发送端是固定的，即一次数据传输时一定有一个为接收端，另一个为发送端。二者地位可互换。二者需要一条信号线和一条接地线连接。</li><li>全双工：在任一时刻接收端和发送端都可变，即两个设备都可以同时接收和发送数据。二者需要一条接地线和两条信号线连接。</li></ul><p>[比特率（Bit rate）][3]：指单位时间内传输送或处理的比特的数量，规定使用“比特每秒”（bit/s或bps）为单位。</p><p>对于单片机而言，波特率数值大小不同于单片机发送或者接收数据的时钟频率，波特率大小可以是单片机时钟频率的1/16或者1/64。</p><h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><em>Universal asynchronous receiver-transmitter 通用异步收发传输器</em></p><p>UART是什么？摘自[这里][4]：</p><blockquote><p>UART stands for Universal Asynchronous Receiver/Transmitter. It’s not a communication protocol like SPI and I2C, but a physical circuit in a microcontroller, or a stand-alone IC. A UART’s main purpose is to transmit and receive serial data.</p></blockquote><p>简单地说，UART不是具体的某一个独立的芯片，而是一种异步串行通信的方式，但这种方式还不能称之为“通信协议”。<br><del>其实我觉得这不就是一种通信协议么…</del></p><p>UART通信只需要两个接口：</p><ul><li>RXD 串行接收引脚</li><li>TXD 串行发送引脚</li></ul><p><del>RXD和TXD中的X有什么含义？</del></p><p>显然，在进行UART通信时，要将一个设备的RXD端和另一个设备的TXD端连接。</p><p>前面提到，UART是一种异步通信，这意味着没有时钟信号两设备上的让RXD和TXD保持同步。为了保证RXD能够完整的接收到所有数据，传输数据时要满足的条件和步骤大致如下：</p><ul><li>数据以数据包的形式传送，数据包的结构是可以修改的，只需提前在数据接收方和发送方处设置好即可。</li><li>数据接收方和发送方的通信波特率应保持一致。</li><li>通信未开始时，线路保持高电平。</li><li>通信开始时，TXD首先发送一位0（低电平）作为起始位通知接收方开始传输数据。</li><li>发送数据。</li><li>发送一位1作为停止位，完成一个数据包的传输。</li></ul><p><del>终于知道以前用PN532时连的线是干啥用的了</del></p><h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p><em>Recommended Standard 232 RS-232</em></p><p>[RS-232][5]是美国电子工业联盟（EIA）制定的串行数据通信的接口标准，原始编号全称是EIA-RS-232。它被广泛用于计算机串行接口外设连接。</p><p>RS-232接口最初规定为25个引脚，但大部分设备进行了简化，只使用了其中的9个引脚：</p><table><thead><tr><th>Pin</th><th>Abbreviation</th><th>Name</th></tr></thead><tbody><tr><td>Pin1</td><td>DCD</td><td>Data Carrier Detect</td></tr><tr><td>Pin2</td><td>RXD</td><td>Receiver</td></tr><tr><td>Pin3</td><td>TXD</td><td>Transmit</td></tr><tr><td>Pin4</td><td>DTR</td><td>Data Terminal Ready</td></tr><tr><td>Pin5</td><td>GND</td><td>Ground</td></tr><tr><td>Pin6</td><td>DSR</td><td>Data Set Ready</td></tr><tr><td>Pin7</td><td>RTS</td><td>Request To Send</td></tr><tr><td>Pin8</td><td>CTS</td><td>Clear To Send</td></tr><tr><td>Pin9</td><td>RI</td><td>Ring Indicator</td></tr></tbody></table><p>需要注意的是，RS-232标准采用的电平为RS-232电平而不是TTL电平，RS-232电平为负逻辑电平，即-15V~-3V代表逻辑”1”，+3V~+15V代表逻辑”0”。<br>可使用MAX232芯片进行转换。</p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p><em>Universal Serial Bus 通用串行总线</em></p><p>[USB][6]已经非常熟悉了，其USB接口类型有很多：</p><ul><li>Standard<ul><li>Type-A</li><li>Type-A SuperSpeed</li><li>Type-B</li><li>Type-B SuperSpeed</li><li>Type-C</li></ul></li><li>Mini<ul><li>Mini-A</li><li>Mini-B</li><li>Mini-AB </li></ul></li><li>Micro<ul><li>Micro-A</li><li>Micro-B</li><li>Micro-B SuperSpeed</li><li>Micro-AB</li></ul></li></ul><p>在上述接口中，含SuperSpeed后缀的接口以及Type-C接口均支持USB3.0标准，其余仅支持USB2.0标准。<br><del>转眼间USB4.0标准就要公布了，时间过得真快</del></p><p>Type-A SuperSpeed和Type-B SuperSpeed接口一般为蓝色。</p><p>同类型的接口可以混插，如Type-A接头可以插入Type-A SuperSpeed接口中，反过来也一样。</p><p>不同的接口引脚数往往不同，但所有的接口一定有以下四个引脚（其实核心也就是Pin 3和Pin 4）：</p><table><thead><tr><th>Pin</th><th>Name</th><th>Cable color</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>VCC</td><td>Red</td><td>+5 VDC</td></tr><tr><td>2</td><td>D-</td><td>White</td><td>Data -</td></tr><tr><td>3</td><td>D+</td><td>Green</td><td>Data +</td></tr><tr><td>4</td><td>GND</td><td>Black</td><td>Ground</td></tr></tbody></table><p><em>摘自[USB pinout][7]</em></p><p>Type-A和Type-B接口有且仅有这四个引脚。</p><p>Type-A SuperSpeed的引脚如下，可以看到虽然多了5个引脚，但1-4引脚依然存在。</p><table><thead><tr><th>PinNumber</th><th>PinName</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>VBus</td><td>+5V Power</td></tr><tr><td>2</td><td>USB D-</td><td>USB 2.0 data</td></tr><tr><td>3</td><td>USB D+</td><td></td></tr><tr><td>4</td><td>GND</td><td>Ground for power return</td></tr><tr><td>5</td><td>StdA_SSRX-</td><td>SuperSpeed receiver</td></tr><tr><td>6</td><td>StdA_SSRX+</td><td>SuperSpeed receiver</td></tr><tr><td>7</td><td>GND_DRAIN</td><td>Ground for signal return</td></tr><tr><td>8</td><td>StdA_SSTX-</td><td>SuperSpeed transmitter</td></tr><tr><td>9</td><td>StdA_SSTX+</td><td>SuperSpeed transmitter</td></tr></tbody></table><p>USB标准采用的电平依然不是TTL电平，其D-和D+引脚传输的是差分信号。可使用[CH340][8]芯片进行转换。</p><p>2019年8月8日 立秋</p><h3 id="串行口控制寄存器"><a href="#串行口控制寄存器" class="headerlink" title="串行口控制寄存器"></a>串行口控制寄存器</h3><p><em>SCON: Serial Control 串行口控制寄存器 可位寻址</em><br><em>Address: 98H</em></p><p>类似TCON，控制串口的工作模式及指示串口状态。</p><ul><li>RI 接收中断标志位</li><li>TI 发送中断标志位</li><li>RB8 模式 2 和 3 中接收到的第九位数据</li><li>TB8 模式 2 和 3 中要发送的第九位数据</li><li>REN 使能串行接收</li><li>SM2 多机通信控制位</li><li>SM1 控制工作模式</li><li>SM0 控制工作模式</li></ul><h3 id="串行口数据缓冲寄存器"><a href="#串行口数据缓冲寄存器" class="headerlink" title="串行口数据缓冲寄存器"></a>串行口数据缓冲寄存器</h3><p><em>SBUF: Serial Buffer 串行口数据缓冲寄存器 不可位寻址</em><br><em>Adress: 99H</em></p><p>表面上SBUF是一个寄存器，但其实它是由一个只读寄存器和一个只写寄存器构成的。使用时并不需要选择具体使用哪一个寄存器，当对SBUF作读操作时，单片机会自动调用只读寄存器。反过来，当程序对SBUF作写操作时，单片机会自动调用只写寄存器。</p><p>看起来挺复杂，实际上SBUF的工作原理也挺简单的，STC89C52RC的datasheet写的很详细：</p><blockquote><p>······在写入SBUF信号的控制下，把数据装入相同的9位移位寄存器，前面8位为数据字节，其最低位为移位寄存器的输出位。根据不同的工作方式会自动将“1”或TB8的值装入移位寄存器的第9位，并进行发送。</p><p>串行通道的接收寄存器是一个输入移位寄存器。在方式0时它的字长为8位，其他方式时位9位。当一帧接收完毕，移位寄存器中的数据字节装入串行数据缓冲器SBUF中，其第9位则装入SCON寄存器中的RB8位。如果由于SM2使得已接受到的数据无效时，RB8和SBUF中的内容不变。</p><p>由于接收通道内设有输入移位寄存器和SBUF缓冲器，从而能使一帧接收完将数据由移位寄存器装入SBUF后，可立即接收下一帧信息，主机应在该帧接收结束前从SBUF缓冲器中将数据取走，否则前一帧数据将丢失。SBUF以并行方式送往内部数据总线。</p></blockquote><h3 id="串口通信的具体实现"><a href="#串口通信的具体实现" class="headerlink" title="串口通信的具体实现"></a>串口通信的具体实现</h3><p>步骤大致如下：</p><ol><li>配置串行口控制寄存器SCON</li><li>配置定时器 T1 为自动重装模式，禁用 T1 中断</li><li>根据baud计算TH1、TL1初值</li><li>TR1置1，启动定时器</li></ol><p>2019年8月14日</p><h3 id="两种不同的换行符"><a href="#两种不同的换行符" class="headerlink" title="两种不同的换行符"></a>两种不同的换行符</h3><p>在VS Code右下角可以选择行尾序列LF或CRLF，一直以来只知道是两种不同的换行符但没有去深入了解。但在用8051做串口通讯时遇到了问题，直接发送ASCII表的第十一位LF（0x10）时上位机显示的文本并未将其理解为换行符，于是去查了一些相关资料：</p><p>不同的编辑器使用的换行符往往不同，这是一个历史问题。采用的换行标记一般为以下五种，后两种挺少见的，可以忽略：</p><ul><li>ASCII standard<ul><li>LF: line feed 换行</li><li>CR: carriage return 回车</li><li>CRLF: carriage return + line feed 换行 + 回车</li></ul></li><li>Unicode standard<ul><li>LS: Line Separator</li><li>PS: Paragraph Separator</li></ul></li></ul><p>多数Unix和类Unix系统（macOS、Linux、FreeBSD etc.）都使用LF作为换行符。而Windows系统使用的换行符是CRLF，选择二者组合的原因还挺有意思的，这和上世纪时广泛使用的电传打印机(teleprinter)有关。</p><p>这篇文章[Why is the line terminator CR+LF?][9]对原因解释的很清楚：</p><blockquote><p>This protocol dates back to the days of teletypewriters.</p><p>CR stands for “carriage return” – the CR control character returned the print head (“carriage”) to column 0 without advancing the paper. LF stands for “linefeed” – the LF control character advanced the paper one line without moving the print head.So if you wanted to return the print head to column zero (ready to print the next line) and advance the paper (so it prints on fresh paper), you need both CR and LF.</p><p>If you go to the various internet protocol documents, such as RFC 0821 (SMTP), RFC 1939 (POP), RFC 2060 (IMAP), or RFC 2616 (HTTP), you’ll see that they all specify CR+LF as the line termination sequence.</p><p>So the the real question is not “Why do CP/M, MS-DOS, and Win32 use CR+LF as the line terminator?” but rather “Why did other people choose to differ from these standards documents and use some other line terminator?”</p></blockquote><p>读到这自然也会好奇为什么C语言中只使用<code>\n</code>就能实现换行，事实上这篇文章也提到了原因：</p><blockquote><p>The unix ancestry of the C language carried this convention into the C language standard, which requires only “\n” (which encodes LF) to terminate lines, putting the burden on the runtime libraries to convert raw file data into logical lines.</p><p>The C language also introduced the term “newline” to express the concept of “generic line terminator”. I’m told that the ASCII committee changed the name of character 0x0A to “newline” around 1996, so the confusion level has been raised even higher.</p></blockquote><p>2019年8月15日</p><hr><h2 id="Cx51中的坑"><a href="#Cx51中的坑" class="headerlink" title="Cx51中的坑"></a>Cx51中的坑</h2><p>不到十行的程序莫名其妙的报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C141: syntax error near &apos;int&apos;, expected &apos;__asm&apos;</span><br></pre></td></tr></table></figure></p><p>翻来覆去看对应的语句，怎么都没找到错误，查了一下才知道到底是什么问题。</p><p>确切的讲，这个问题是C89的锅，C89规定变量必须声明在块的开头，也就是其他执行语句的前面。而C99标准放宽了这一限制。</p><p>2019年8月9日</p><hr><h2 id="MCS-51的寻址方式"><a href="#MCS-51的寻址方式" class="headerlink" title="MCS-51的寻址方式"></a>MCS-51的寻址方式</h2><p>一共有七种寻址方式：</p><ul><li>直接寻址</li><li>立即寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>基址寄存器加变址寄存器间接寻址</li><li>相对寻址</li><li>位寻址</li></ul><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址的概念比较简单，就是该指令执行时会从寄存器中读取一个立即数。立即数是编写程序时写入程序指令的常数。为了区分这个数是操作数（即参与运算的数）还是地址，会在这个数字之前加上<code>#</code>标志，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, #30H</span><br></pre></td></tr></table></figure><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>寄存器寻址，其实就是，先把一个立即数放到工作寄存器里，然后从工作寄存器读取这个立即数的过程就是寄存器寻址，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R3</span><br></pre></td></tr></table></figure><p>至于R1属于哪一个工作寄存器区，这个由执行该语句时，PSW寄存器中的RS1和RS0的值来决定。</p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器间接寻址的概念很类似于C语言中的指针，先看下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R1</span><br></pre></td></tr></table></figure><p>显然，该语句为上面所提到的寄存器寻址，单片机首先从R1中读取一个数，并认为这个数是立即数，然后将这个数储存到A中。而对于下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, @R1</span><br></pre></td></tr></table></figure><p>则是指：单片机从R1中读取一个数，但认为这个数不是一个立即数，而是指向另一个存储单元的地址。单片机会继续到这个存储单元去读取保存在里面的数据，并把这个数保存在累加器A中。</p><h3 id="基址寄存器加变址寄存器间接寻址"><a href="#基址寄存器加变址寄存器间接寻址" class="headerlink" title="基址寄存器加变址寄存器间接寻址"></a>基址寄存器加变址寄存器间接寻址</h3><p>名字很长，但是联系到8086汇编就很容易理解了，说白了就是把段地址+偏移地址的模式稍微简化一下，不对段地址进行移位操作，而是直接和偏移地址相加，没什么意思。</p><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>这个就更简单了，就是说，假如程序执行到了语句X，现在想跳转到X前面的某一个语句或者后面的某一个语句，那么就可以用相对寻址来实现。这个就有点类似于C语言里的goto语句（复习一下，goto语句的标签具有函数作用域）。</p><p>只不过更准确的说，相对寻址改变的是程序计数器PC中的值，进而实现语句跳转。</p><h3 id="位寻址"><a href="#位寻址" class="headerlink" title="位寻址"></a>位寻址</h3><p>位寻址的概念已经很熟悉了，C51里就已经经常使用，还有一个相对的概念是“不可位寻址”。</p><p>现在可以回过头来看一看<code>reg52.h</code>里都有哪些内容了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">REG52.H</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Header file for generic 80C52 and 80C32 microcontroller.</span></span><br><span class="line"><span class="comment">Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __REG52_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __REG52_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BYTE Registers  */</span></span><br><span class="line">sfr P0    = <span class="number">0x80</span>;</span><br><span class="line">sfr P1    = <span class="number">0x90</span>;/</span><br><span class="line">sfr P2    = <span class="number">0xA0</span>;</span><br><span class="line">sfr P3    = <span class="number">0xB0</span>;/</span><br><span class="line">sfr PSW   = <span class="number">0xD0</span>;/</span><br><span class="line">sfr ACC   = <span class="number">0xE0</span>;</span><br><span class="line">sfr B     = <span class="number">0xF0</span>;</span><br><span class="line">sfr SP    = <span class="number">0x81</span>;</span><br><span class="line">sfr DPL   = <span class="number">0x82</span>;</span><br><span class="line">sfr DPH   = <span class="number">0x83</span>;</span><br><span class="line">sfr PCON  = <span class="number">0x87</span>;</span><br><span class="line">sfr TCON  = <span class="number">0x88</span>;/</span><br><span class="line">sfr TMOD  = <span class="number">0x89</span>;</span><br><span class="line">sfr TL0   = <span class="number">0x8A</span>;</span><br><span class="line">sfr TL1   = <span class="number">0x8B</span>;</span><br><span class="line">sfr TH0   = <span class="number">0x8C</span>;</span><br><span class="line">sfr TH1   = <span class="number">0x8D</span>;</span><br><span class="line">sfr IE    = <span class="number">0xA8</span>;/</span><br><span class="line">sfr IP    = <span class="number">0xB8</span>;/</span><br><span class="line">sfr SCON  = <span class="number">0x98</span>;/</span><br><span class="line">sfr SBUF  = <span class="number">0x99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  8052 Extensions  */</span></span><br><span class="line">sfr T2CON  = <span class="number">0xC8</span>;/</span><br><span class="line">sfr RCAP2L = <span class="number">0xCA</span>;</span><br><span class="line">sfr RCAP2H = <span class="number">0xCB</span>;</span><br><span class="line">sfr TL2    = <span class="number">0xCC</span>;</span><br><span class="line">sfr TH2    = <span class="number">0xCD</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BIT Registers  */</span></span><br><span class="line"><span class="comment">/*  PSW  */</span></span><br><span class="line">sbit CY    = PSW^<span class="number">7</span>;</span><br><span class="line">sbit AC    = PSW^<span class="number">6</span>;</span><br><span class="line">sbit F0    = PSW^<span class="number">5</span>;</span><br><span class="line">sbit RS1   = PSW^<span class="number">4</span>;</span><br><span class="line">sbit RS0   = PSW^<span class="number">3</span>;</span><br><span class="line">sbit OV    = PSW^<span class="number">2</span>;</span><br><span class="line">sbit P     = PSW^<span class="number">0</span>; <span class="comment">//8052 only</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  TCON  */</span></span><br><span class="line">sbit TF1   = TCON^<span class="number">7</span>;</span><br><span class="line">sbit TR1   = TCON^<span class="number">6</span>;</span><br><span class="line">sbit TF0   = TCON^<span class="number">5</span>;</span><br><span class="line">sbit TR0   = TCON^<span class="number">4</span>;</span><br><span class="line">sbit IE1   = TCON^<span class="number">3</span>;</span><br><span class="line">sbit IT1   = TCON^<span class="number">2</span>;</span><br><span class="line">sbit IE0   = TCON^<span class="number">1</span>;</span><br><span class="line">sbit IT0   = TCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IE  */</span></span><br><span class="line">sbit EA    = IE^<span class="number">7</span>;</span><br><span class="line">sbit ET2   = IE^<span class="number">5</span>; <span class="comment">//8052 only</span></span><br><span class="line">sbit ES    = IE^<span class="number">4</span>;</span><br><span class="line">sbit ET1   = IE^<span class="number">3</span>;</span><br><span class="line">sbit EX1   = IE^<span class="number">2</span>;</span><br><span class="line">sbit ET0   = IE^<span class="number">1</span>;</span><br><span class="line">sbit EX0   = IE^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IP  */</span></span><br><span class="line">sbit PT2   = IP^<span class="number">5</span>;</span><br><span class="line">sbit PS    = IP^<span class="number">4</span>;</span><br><span class="line">sbit PT1   = IP^<span class="number">3</span>;</span><br><span class="line">sbit PX1   = IP^<span class="number">2</span>;</span><br><span class="line">sbit PT0   = IP^<span class="number">1</span>;</span><br><span class="line">sbit PX0   = IP^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P3  */</span></span><br><span class="line">sbit RD    = P3^<span class="number">7</span>;</span><br><span class="line">sbit WR    = P3^<span class="number">6</span>;</span><br><span class="line">sbit T1    = P3^<span class="number">5</span>;</span><br><span class="line">sbit T0    = P3^<span class="number">4</span>;</span><br><span class="line">sbit INT1  = P3^<span class="number">3</span>;</span><br><span class="line">sbit INT0  = P3^<span class="number">2</span>;</span><br><span class="line">sbit TXD   = P3^<span class="number">1</span>;</span><br><span class="line">sbit RXD   = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  SCON  */</span></span><br><span class="line">sbit SM0   = SCON^<span class="number">7</span>;</span><br><span class="line">sbit SM1   = SCON^<span class="number">6</span>;</span><br><span class="line">sbit SM2   = SCON^<span class="number">5</span>;</span><br><span class="line">sbit REN   = SCON^<span class="number">4</span>;</span><br><span class="line">sbit TB8   = SCON^<span class="number">3</span>;</span><br><span class="line">sbit RB8   = SCON^<span class="number">2</span>;</span><br><span class="line">sbit TI    = SCON^<span class="number">1</span>;</span><br><span class="line">sbit RI    = SCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P1  */</span></span><br><span class="line">sbit T2EX  = P1^<span class="number">1</span>; <span class="comment">// 8052 only</span></span><br><span class="line">sbit T2    = P1^<span class="number">0</span>; <span class="comment">// 8052 only</span></span><br><span class="line">             </span><br><span class="line"><span class="comment">/*  T2CON  */</span></span><br><span class="line">sbit TF2    = T2CON^<span class="number">7</span>;</span><br><span class="line">sbit EXF2   = T2CON^<span class="number">6</span>;</span><br><span class="line">sbit RCLK   = T2CON^<span class="number">5</span>;</span><br><span class="line">sbit TCLK   = T2CON^<span class="number">4</span>;</span><br><span class="line">sbit EXEN2  = T2CON^<span class="number">3</span>;</span><br><span class="line">sbit TR2    = T2CON^<span class="number">2</span>;</span><br><span class="line">sbit C_T2   = T2CON^<span class="number">1</span>;</span><br><span class="line">sbit CP_RL2 = T2CON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>2019年9月18日</p><hr><h2 id="MCS-51-的存储器结构"><a href="#MCS-51-的存储器结构" class="headerlink" title="MCS-51 的存储器结构"></a>MCS-51 的存储器结构</h2><p>学习8086汇编时，可以了解到8086采用的是Von Neumann架构，正如王爽在《汇编语言》中反复强调的一样，指令和数据是完全相同的概念，程序和数据共用同一条总线。</p><p>不同于8086，一般认为，MCS-51是采用Harvard架构的MCU，其程序存储器（ROM）和数据存储器（RAM）的Adress Space相互独立。</p><p>扩展阅读：[为什么电脑还沿用冯·诺伊曼结构而不使用哈佛结构？][10]</p><p>从物理上分，即从电路的实际物理结构来区分，MCS-51的存储空间可分为四个部分：</p><ul><li>程序存储器<ul><li>片内程序存储器</li><li>片外程序存储器</li></ul></li><li>数据存储器<ul><li>片内数据存储器</li><li>片外数据存储器</li></ul></li></ul><p>从逻辑上分，即按照实际使用时的角度来区分，则可分为三个部分：</p><ul><li>程序存储器（片内片外统一编址）</li><li>数据存储器（片内片外独立编址）<ul><li>片内数据存储器</li><li>片外数据存储器</li></ul></li></ul><p>这里又牵扯出了两个概念——统一编址和独立编址。<br>实际上是很简单的概念，可参考[内存和外设的统一编址及独立编址][11]和[理解“统一编址与独立编址、I/O端口与I/O内存”][12]</p><h3 id="MCS-51-的程序存储器"><a href="#MCS-51-的程序存储器" class="headerlink" title="MCS-51 的程序存储器"></a>MCS-51 的程序存储器</h3><p>MCS-51的程序计数器是16位，即地址空间可达2^16 bit = 64KB。</p><p>正常工作模式下（即<span style="TEXT-DECORATION: overline">EA</span>端接高电平），PC从内部ROM的0x0000开始计数。当PC的值大于0x0FFF时，会自动转至片外程序存储器的0x1000处，直到片外存储器的0xFFFF为止。所以逻辑上对片内程序存储器和片外程序存储器不做区分。</p><p>不过实际使用时，为了某些特殊目的，还可以将<span style="TEXT-DECORATION: overline">EA</span>端接低电平，此时单片机会直接从片外ROM的0x0000开始计数，而不再使用片内程序存储器。</p><p>程序存储器中有七个地址较为特殊，分别为复位时PC指向的地址0000H和六个中断源入口地址（参见中断部分内容）。</p><h3 id="MCS-51-的数据存储器"><a href="#MCS-51-的数据存储器" class="headerlink" title="MCS-51 的数据存储器"></a>MCS-51 的数据存储器</h3><p>正如前面提到的那样，MCS-51单片机的片内、片外数据存储器是独立编址的。</p><ul><li>片内数据存储器的地址空间：0x00 ~ 0xFF</li><li>片外数据存储器的地址空间：0x0000 ~ 0xFFFF</li></ul><p>对于MCS-51系列的MCU而言，片内数据存储器又可以分为两块：</p><ul><li>0x00 ~ 0x7F: 工作寄存器区 + 位寻址区 + 数据缓冲区</li><li>0x80 ~ 0xFF: 特殊功能寄存器SFR</li></ul><p>而对于MCS-52系列的MCU，实际上有两块区域被映射到了0x80 ~ 0xFF的地址空间，即可认为这两块区域是独立编址的。这两块区域一个是特殊功能寄存器SFR块，另一个则是一个普通的数据存储器块。</p><p>这两块区域有着完全相同的地址，那么实际在写程序时，如何才能区分这两块区域呢？这个是通过不同的寻址方式实现的，访问SFR块必须采用直接寻址的方式，而访问重叠部分的普通RAM则采用寄存器间接寻址来实现。</p><p>工作寄存器区一共分为四个区，对应四个通用寄存器组。每个通用寄存器组由8个通用寄存器R0~R7构成，使用时具体访问哪一组通用寄存器由PSW寄存器中的RS1和RS0决定。</p><p>位寻址区就是指该区域中的每一位均可位寻址，需要注意的就是RAM中并不是只有该区域可以位寻址，SFR中的部分单元也可位寻址。</p><p>用户RAM区，需要注意的就是在汇编时，要把单片机的堆栈指针SP指向该区域。否则由于SP默认指向0007H，在栈向上生长时会破坏工作寄存器区和位寻址区内的数据。</p><h3 id="Keil-uVision5-查看和修改程序-数据存储器"><a href="#Keil-uVision5-查看和修改程序-数据存储器" class="headerlink" title="Keil uVision5 查看和修改程序\数据存储器"></a>Keil uVision5 查看和修改程序\数据存储器</h3><p>进入调试状态后点击Memory Window，并在Address内填入对应地址即可查看存储器内数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看 ROM 的 CODE 区</span></span><br><span class="line">C:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 DATA 区</span></span><br><span class="line">D:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 IDATA 区</span></span><br><span class="line">I:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片外 RAM 的 XDATA 区</span></span><br><span class="line">X:<span class="number">0x00</span></span><br></pre></td></tr></table></figure><ul><li>code 代码存储区</li><li>data 直接寻址片内数据存储区</li><li>bdata 可位寻址片内数据存储区</li><li>idata 间接寻址片内数据存储区</li><li>pdata 分页寻址片外数据存储区</li><li>xdata 片外数据存储区</li></ul><p>关于code、idata等详细含义，可查看[Memory Types][13]<br>2019年10月7日 重阳节</p><hr><h2 id="MCS-51的伪指令"><a href="#MCS-51的伪指令" class="headerlink" title="MCS-51的伪指令"></a>MCS-51的伪指令</h2><p>伪指令主要有以下八个：</p><ul><li>ORG</li><li>END</li><li>DB</li><li>DW</li><li>DS</li><li>EQU</li><li>DATA</li><li>BIT</li></ul><p>这八条指令大致可分为三类，下分类记录。</p><h3 id="ORG和END"><a href="#ORG和END" class="headerlink" title="ORG和END"></a>ORG和END</h3><p>ORG指令制定了其后面第一条指令在ROM中存储时的起始位置，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG 0030H</span><br><span class="line">INC A</span><br></pre></td></tr></table></figure><p>这里<code>INC A</code>在ROM中就是从0030H开始存储的。</p><p>顺便复习一下标号，标号是代表着其后面第一条指令的地址，因此下面两种写法是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP:  INC A</span><br><span class="line"></span><br><span class="line">; 等价于</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">       INC A</span><br></pre></td></tr></table></figure><p>不要错误的认为标号代表当前行所在的地址。</p><p>END就是结束标志，没什么意思。</p><h3 id="DB、DW和DS"><a href="#DB、DW和DS" class="headerlink" title="DB、DW和DS"></a>DB、DW和DS</h3><ul><li>DB：从指定单元开始，定义n个字节，并在每个字节中存放1个数</li><li>DW：从指定单元开始，定义n个字（对于MCS-51，1个word = 2个byte），并在每个字中存放1个数</li><li>DS：从指定单元开始，定义n空字节</li></ul><p>这里的“指定单元”的地址按以下两种方法确定：</p><ol><li>由ORG指令确定</li><li>在前一条指令末地址的下一个地址确定</li></ol><p>对应代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORG     8051H</span><br><span class="line">DB      &apos;A&apos;                  ; (8051H) = &apos;A&apos; = 05H</span><br><span class="line"></span><br><span class="line">ORG     8086H</span><br><span class="line">NOP                          ; NOP 为单字节指令</span><br><span class="line">DB      &apos;B&apos;                  ; (8087H) = &apos;B&apos; = 06H</span><br></pre></td></tr></table></figure><p>在使用<code>DB</code>、<code>DW</code>和<code>DS</code>时有一点需要注意，以这段程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG     8000H</span><br><span class="line">DB      &apos;A&apos;, 00H</span><br></pre></td></tr></table></figure><p>这段代码本意是在8000H单元中存放字母A对应的ASCII码0x41，8001H单元中存放00H</p><p>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8000H:  0100 0001</span><br><span class="line">8001H:  0000 0000</span><br></pre></td></tr></table></figure></p><p>但利用Keil调试功能提供的反汇编代码来观察一下，上面的<code>DB</code>指令会被翻译为双字节指令<code>AJMP 20H</code>，为什么会出现这种情况？这就要回顾一下AJMP指令的机器码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; AJMP addr11</span><br><span class="line"></span><br><span class="line">A10A9A8    00001</span><br><span class="line">A7A6A5A4A3A2A1A0</span><br></pre></td></tr></table></figure><p>对比一下不难发现，前面的<code>DB</code>指令及其存放的数据，恰好为<code>AJMP 20H</code>指令对应的机器码，因此反汇编的结果也就不难理解了。</p><p>因此这里也就需要注意，如果写程序时不慎将<code>DB</code>指令及其定义的数据写为程序需要执行的代码，有可能会引发莫名其妙的错误，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">MAIN:</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure><p>正确写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line"></span><br><span class="line">        ORG     0060H</span><br><span class="line">MAIN:</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure><h3 id="EQU、DATA和BIT"><a href="#EQU、DATA和BIT" class="headerlink" title="EQU、DATA和BIT"></a>EQU、DATA和BIT</h3><ul><li>EQU：类似#define，但必须先定义后使用</li><li>DATA：类似#define，可以先使用在定义（类似goto的函数作用域）</li><li>BIT：类似#define，</li></ul><p>2019年10月24日 霜降<br>———<br> [1]: <a href="http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm" target="_blank" rel="noopener">http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm</a><br> [2]: <a href="http://www.keil.com/support/docs/839.htm" target="_blank" rel="noopener">http://www.keil.com/support/docs/839.htm</a><br> [3]: <a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87</a><br> [4]: <a href="http://www.circuitbasics.com/basics-uart-communication/" target="_blank" rel="noopener">http://www.circuitbasics.com/basics-uart-communication/</a><br> [5]: <a href="https://zh.wikipedia.org/wiki/RS-232" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/RS-232</a><br> [6]: <a href="https://zh.wikipedia.org/wiki/USB" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/USB</a><br> [7]: <a href="https://pinouts.ru/Slots/USB_pinout.shtml" target="_blank" rel="noopener">https://pinouts.ru/Slots/USB_pinout.shtml</a><br> [8]: <a href="http://www.winchiphead.com/download/CH340/CH340DS1.PDF" target="_blank" rel="noopener">http://www.winchiphead.com/download/CH340/CH340DS1.PDF</a><br> [9]: <a href="https://devblogs.microsoft.com/oldnewthing/?p=40193" target="_blank" rel="noopener">https://devblogs.microsoft.com/oldnewthing/?p=40193</a><br> [10]: <a href="https://www.zhihu.com/question/22406681/answer/21264994" target="_blank" rel="noopener">https://www.zhihu.com/question/22406681/answer/21264994</a><br> [11]: <a href="https://blog.csdn.net/zhandoushi1982/article/details/5976898" target="_blank" rel="noopener">https://blog.csdn.net/zhandoushi1982/article/details/5976898</a><br> [12]: <a href="https://www.cnblogs.com/armlinux/archive/2010/11/26/2396888.html" target="_blank" rel="noopener">https://www.cnblogs.com/armlinux/archive/2010/11/26/2396888.html</a><br> [13]: <a href="http://www.keil.com/support/man/docs/c51/c51_le_memtypes.htm" target="_blank" rel="noopener">http://www.keil.com/support/man/docs/c51/c51_le_memtypes.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正式开始学习8051及C51。&lt;/p&gt;
&lt;h2 id=&quot;Cx51-的数据类型&quot;&gt;&lt;a href=&quot;#Cx51-的数据类型&quot; class=&quot;headerlink&quot; title=&quot;Cx51 的数据类型&quot;&gt;&lt;/a&gt;Cx51 的数据类型&lt;/h2&gt;&lt;p&gt;摘自[Cx51 User’s Guide][1]&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔记</title>
    <link href="http://wangyuyang.me/2019/07/20/%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2019/07/20/笔记/</id>
    <published>2019-07-20T14:28:11.000Z</published>
    <updated>2019-07-31T08:58:42.702Z</updated>
    
    <content type="html"><![CDATA[<p>学一些东西时遇到的问题。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">目录</span><br><span class="line">1. Assembly Language</span><br><span class="line">    1.1 DOSBox 窗口大小调整无反应</span><br><span class="line"></span><br><span class="line">2. LabVIEW</span><br><span class="line">    2.1 Control Design效率问题</span><br><span class="line"></span><br><span class="line">3. OpenCV</span><br><span class="line">    3.1 imread()函数用法</span><br><span class="line">    3.2 使用Matplotlib正确显示彩色图像</span><br></pre></td></tr></table></figure><h2 id="Assembly-Language"><a href="#Assembly-Language" class="headerlink" title="Assembly Language"></a>Assembly Language</h2><h3 id="DOSBox-窗口大小调整无反应"><a href="#DOSBox-窗口大小调整无反应" class="headerlink" title="DOSBox 窗口大小调整无反应"></a>DOSBox 窗口大小调整无反应</h3><p>根据网络上的说法，调整安装目录下<code>dosbox-0.74-3.conf</code>下的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=original</span><br><span class="line">output=surface</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution = 1536*864</span><br><span class="line">output = overlay</span><br></pre></td></tr></table></figure></p><p>发现没有变化，Google一下，建议改<code>scaler</code>为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[render]</span><br><span class="line"></span><br><span class="line">frameskip = 0</span><br><span class="line">aspect = false</span><br><span class="line">scaler = normal2x forced</span><br></pre></td></tr></table></figure></p><p>然而强制缩放太糊，我还是改成了<code>scaler=none</code>。<br>又折腾半小时才解决，发现是<code>1536x864</code>而不是<code>1536*864</code>,即字母<code>x</code>而不是乘号<code>*</code>…..<del>mdzz，配置文件的注释也不写清楚</del><br>另外之所以改为<code>1536x864</code>而不是<code>1920x1080</code>是因为笔记本本来就开了125%缩放。<br>另另外，感觉<code>output = overlay</code>比<code>opengl</code>更锐利一点？</p><hr><h2 id="LabVIEW"><a href="#LabVIEW" class="headerlink" title="LabVIEW"></a>LabVIEW</h2><h3 id="Control-Design效率问题"><a href="#Control-Design效率问题" class="headerlink" title="Control Design效率问题"></a>Control Design效率问题</h3><p>用LabVIEW做了一个二阶LTI系统的单位阶跃响应曲线绘制VI，系统初始参数由滑动杆输入，计算结果捆绑成簇，输出到front panel的XY图控件。</p><p>计算这一块有两种解决办法，一种是直接调用<code>Control and Simulation &gt;&gt; Control Design &gt;&gt; Model Construction &gt;&gt; CD Construct Second Order Model.vi</code>和<code>CD Step Response Model.vi</code>。另一种方法是调用公式节点直接写C进行计算。</p><p>前一种方法实现最简单，只需要点一点鼠标就可以了，但问题在于，不知道该VI及其子VI的执行策略。每次程序循环执行时，即使不做数据更新操作，CPU占用率也会飙到50%以上。</p><p>而直接用C语言实现计算，虽然写起来很麻烦，但速度反而非常快，CPU占用率只要不到5%。</p><p>2019.7.31更新：问题解决一半，将控件放置在while循环内，同时在循环内放置一个<code>Wait For Front Panel Activity</code>控件即可解决数据未更新时占用率过高的问题，但在反复拖动滑动杆时CPU占用率依然远远高于C语言实现方案。LabVIEW本身提供的例程<code>CDEx Adjust Second Order System Parameters.vi</code>也存在一样的问题。所以我认为这是LabVIEW的问题，以后能用C语言还是尽量用C来解决。</p><hr><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h3 id="imread-函数用法"><a href="#imread-函数用法" class="headerlink" title="imread()函数用法"></a>imread()函数用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imread(path, flag)</span><br></pre></td></tr></table></figure><!-- more --> <p>path为图片路径，未找到指定文件时返回值None<br>flag为读取图片的方式，具体取值含义可以参考官方文档。</p><h3 id="使用Matplotlib正确显示彩色图像"><a href="#使用Matplotlib正确显示彩色图像" class="headerlink" title="使用Matplotlib正确显示彩色图像"></a>使用Matplotlib正确显示彩色图像</h3><p>尝试直接使用下面代码显示图像时发现颜色不正常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">pyplot.imgshow(img)</span><br></pre></td></tr></table></figure></p><p>查阅资料，<a href="https://stackoverflow.com/questions/15072736/extracting-a-region-from-an-image-using-slicing-in-python-opencv/15074748#15074748" target="_blank" rel="noopener">Extracting a region from an image using slicing in Python, OpenCV</a>里提到：<br><blockquote><p>There is a slight difference in pixel ordering in OpenCV and Matplotlib.</p><p>OpenCV follows BGR order, while matplotlib likely follows RGB order.</p><p>So when you display an image loaded in OpenCV using pylab functions, you may need to convert it into RGB mode. </p></blockquote><br>关于为什么OpenCV选择BGR而不是RGB这个问题，可以看这里<a href="https://www.zhihu.com/question/264044792" target="_blank" rel="noopener">深度学习中为什么普遍使用BGR而不用RGB？</a><br>另附上Stackoverflow中给出的两种解决方案：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">img = img[::,::<span class="number">-1</span>]</span><br><span class="line">pyplot.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">pyplot.imshow(img)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学一些东西时遇到的问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二十</title>
    <link href="http://wangyuyang.me/2019/04/11/%E4%BA%8C%E5%8D%81/"/>
    <id>http://wangyuyang.me/2019/04/11/二十/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-11T11:21:25.267Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.Net/Matlab混合编程</title>
    <link href="http://wangyuyang.me/2019/03/17/CSharp-Matlab%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    <id>http://wangyuyang.me/2019/03/17/CSharp-Matlab混合编程/</id>
    <published>2019-03-17T05:22:26.000Z</published>
    <updated>2019-03-17T06:34:12.751Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便的使用Matlab中自定义的函数，需要制作一个简单的界面。但Matlab难以做出一个漂亮的GUI。因此希望利用C#制作出一个界面。</p><p>Matlab版本为R2018a<br><a id="more"></a><br>在C#中调用Matlab函数大体上分为以下几个步骤：</p><ol><li>首先创建一个函数的M文件。</li><li>将函数文件编译为dll文件。</li><li>在C#工程中添加对dll文件引用，并在程序中加入对命名空间的引用。</li><li>愉快的敲代码。</li></ol><p>具体描述一下过程：</p><h2 id="创建M文件"><a href="#创建M文件" class="headerlink" title="创建M文件"></a>创建M文件</h2><p>没什么好说的，需要了解一些Matlab基础知识和语法。</p><h2 id="将函数编译为dll文件"><a href="#将函数编译为dll文件" class="headerlink" title="将函数编译为dll文件"></a>将函数编译为dll文件</h2><p>这一块主要分为两部分：</p><h3 id="创建一个编译dll库的工程-prj"><a href="#创建一个编译dll库的工程-prj" class="headerlink" title="创建一个编译dll库的工程.prj"></a>创建一个编译dll库的工程.prj</h3><p>在Command Window中输入deploytool</p><p>在弹出的Matlab Compiler窗口中，有五个选项：</p><ul><li>Application Compiler</li><li>Hadoop Compiler</li><li>Library Compiler</li><li>Production Server Compiler</li><li>Web App Compiler</li></ul><p>这里选择Library Compiler，然后在上方的Type内选择.Net Assembly，并在旁边的Exported Functions中添加前面创建的M文件。</p><p>接下来需要填写窗口下方的信息，Namespace, Class Name, Method Name按需添加、填写即可。</p><h3 id="编译函数"><a href="#编译函数" class="headerlink" title="编译函数"></a>编译函数</h3><p>必要信息填写完成后直接点击Package，选择保存位置即可。等待数分钟后即完成编译。</p><h2 id="在C-工程中添加对dll文件引用"><a href="#在C-工程中添加对dll文件引用" class="headerlink" title="在C#工程中添加对dll文件引用"></a>在C#工程中添加对dll文件引用</h2><p>首先添加对dll库引用：</p><p>解决方案资源管理器 -&gt; 引用-（右键） -&gt; 添加引用 -&gt; 程序集 -&gt; 浏览 -（选择生成的dll库）-&gt; 添加</p><p>然后使用using引用对应的命名空间即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便的使用Matlab中自定义的函数，需要制作一个简单的界面。但Matlab难以做出一个漂亮的GUI。因此希望利用C#制作出一个界面。&lt;/p&gt;
&lt;p&gt;Matlab版本为R2018a&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模拟登录HFUT新教务系统-C#</title>
    <link href="http://wangyuyang.me/2019/02/16/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E6%96%B0%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F-csharp/"/>
    <id>http://wangyuyang.me/2019/02/16/模拟登录HFUT新教务系统-csharp/</id>
    <published>2019-02-16T09:10:23.000Z</published>
    <updated>2019-02-22T16:23:22.441Z</updated>
    
    <content type="html"><![CDATA[<p>希望利用C#写一个GUI，方便起见抓取数据部分也由C#实现，先写一个小程序试一试。</p><p>爬虫主体是借助System.Net.Http.HttpClient实现的。<br><a id="more"></a><br><blockquote><p>System.Net.Http是什么？</p><p>Provides a programming interface for modern HTTP applications, including HTTP client components that allow applications to consume web services over HTTP and HTTP components that can be used by both clients and servers for parsing HTTP headers.</p><p>Commonly Used Types:<br>System.Net.Http.HttpResponseMessage<br>System.Net.Http.DelegatingHandler<br>System.Net.Http.HttpRequestException<br>System.Net.Http.HttpClient<br>System.Net.Http.MultipartContent<br>System.Net.Http.Headers.HttpContentHeaders<br>System.Net.Http.HttpClientHandler<br>System.Net.Http.StreamContent<br>System.Net.Http.FormUrlEncodedContent<br>System.Net.Http.HttpMessageHandler</p></blockquote></p><p>主要思路和<a href="https://wangyuyang.me/2019/01/20/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E6%96%B0%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/#more">这篇文章</a>相同。</p><p>Post Json数据部分代码则参考了<a href="https://blogs.msdn.microsoft.com/wsdevsol/2013/02/05/how-to-use-httpclient-to-post-json-data/" target="_blank" rel="noopener">How to use HttpClient to post JSON data</a>。<br><del>完全没看懂“Add code to serialize the object to a string and…”这一部分代码到底干了啥，反正能用Orz</del></p><p><del>学了几天的C#，回过头来再看代码写的好烂啊emmm…</del></p><p>下附源码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Json;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">jwxt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">            LoginJwxt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DataContract</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post_Payload</span></span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"username"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"password"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"captcha"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> captcha &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoginJwxt</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">string</span> login_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/login"</span>;</span><br><span class="line">            <span class="keyword">string</span> login_salt_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/login-salt"</span>;</span><br><span class="line">            <span class="keyword">string</span> student_info_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/for-std/student-info/"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> username = <span class="string">"2019123456"</span>;</span><br><span class="line">            <span class="keyword">string</span> password = <span class="string">"123456"</span>;</span><br><span class="line">            <span class="keyword">string</span> encryptpassword;</span><br><span class="line">            <span class="keyword">string</span> salt = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">            httpClient.DefaultRequestHeaders.Add(<span class="string">"user-agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取salt</span></span><br><span class="line">            salt = httpClient.GetStringAsync(login_salt_url).Result;</span><br><span class="line">            password = salt + <span class="string">"-"</span> + password;</span><br><span class="line"></span><br><span class="line">            SHA1 sha = <span class="keyword">new</span> SHA1CryptoServiceProvider();</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sha.ComputeHash(Encoding.UTF8.GetBytes(password)).Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                builder.Append(sha.ComputeHash(Encoding.UTF8.GetBytes(password))[i].ToString(<span class="string">"x2"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            encryptpassword = builder.ToString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Create and Populate the Post_Payload class with data</span></span><br><span class="line">            Post_Payload post_Payload = <span class="keyword">new</span> Post_Payload();</span><br><span class="line">            post_Payload.username = username;</span><br><span class="line">            post_Payload.password = encryptpassword;</span><br><span class="line">            post_Payload.captcha = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Create a Json Serializer for our type </span></span><br><span class="line">            DataContractJsonSerializer jsonSer = <span class="keyword">new</span> DataContractJsonSerializer(<span class="keyword">typeof</span>(Post_Payload));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the serializer to write the object to a MemoryStream </span></span><br><span class="line">            MemoryStream ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">            jsonSer.WriteObject(ms, post_Payload);</span><br><span class="line">            ms.Position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//use a Stream reader to construct the StringContent (Json) </span></span><br><span class="line">            StreamReader sr = <span class="keyword">new</span> StreamReader(ms);</span><br><span class="line">            StringContent theContent = <span class="keyword">new</span> StringContent(sr.ReadToEnd(), System.Text.Encoding.UTF8, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">            httpClient.PostAsync(login_url, theContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证是否登录成功，保存学籍信息页到本地</span></span><br><span class="line">            FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">"E:\\abc.txt"</span>, FileMode.Create);</span><br><span class="line">            <span class="comment">//获得字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = System.Text.Encoding.Default.GetBytes(httpClient.GetStringAsync(student_info_url).Result);</span><br><span class="line">            <span class="comment">//开始写入</span></span><br><span class="line">            fs.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">            <span class="comment">//清空缓冲区、关闭流</span></span><br><span class="line">            fs.Flush();</span><br><span class="line">            fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望利用C#写一个GUI，方便起见抓取数据部分也由C#实现，先写一个小程序试一试。&lt;/p&gt;
&lt;p&gt;爬虫主体是借助System.Net.Http.HttpClient实现的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="http://wangyuyang.me/2019/02/16/CSharp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2019/02/16/CSharp-学习笔记/</id>
    <published>2019-02-16T07:53:53.000Z</published>
    <updated>2019-02-22T04:33:02.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何将result-array和string进行互转？"><a href="#如何将result-array和string进行互转？" class="headerlink" title="如何将result array和string进行互转？"></a>如何将result array和string进行互转？</h2><p>假设使用UTF-8编码：<br><a id="more"></a><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> convert = <span class="string">"This is the string to be converted"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From string to result array</span></span><br><span class="line">result[] buffer = System.Text.Encoding.UTF8.Getresults(convert);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From result array to string</span></span><br><span class="line"><span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(buffer, <span class="number">0</span>, buffer.Length);</span><br></pre></td></tr></table></figure></p><hr><h2 id="计算SHA1-Hash"><a href="#计算SHA1-Hash" class="headerlink" title="计算SHA1 Hash"></a>计算SHA1 Hash</h2><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.sha1?view=netframework-4.7.2" target="_blank" rel="noopener">SHA1 Class</a><br><em>Namespace: System.Security.Cryptography</em><br><em>Assemblies: System.Security.Cryptography.Algorithms.dll, mscorlib.dll, netstandard.dll</em></p><p>The following example computes the SHA1 hash for data and stores it in result. This example assumes that there is a predefined constant DATA_SIZE.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">result[] data = <span class="keyword">new</span> result[DATA_SIZE];</span><br><span class="line">result[] result; </span><br><span class="line"> </span><br><span class="line">SHA1 sha = <span class="keyword">new</span> SHA1CryptoServiceProvider(); </span><br><span class="line"><span class="comment">// This is one implementation of the abstract class SHA1.</span></span><br><span class="line">result = sha.ComputeHash(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用该语句转换为字符串，会增加额外的连接符：“-”，一般不推荐。</span></span><br><span class="line"><span class="keyword">string</span> Result = Bitconvert.ToString(result);</span><br><span class="line"><span class="comment">// 而如果使用前面提到的两种转换方法，会变成乱码，暂不清楚原因</span></span><br><span class="line"><span class="comment">// 懒得细查，直接循环解决：</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    builder.Append(result[i].ToString(<span class="string">"x2"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">string</span> Result = builder.ToString();</span><br></pre></td></tr></table></figure><h2 id="为什么Visual-Studio-2017没有Paste-XML-as-Classes功能"><a href="#为什么Visual-Studio-2017没有Paste-XML-as-Classes功能" class="headerlink" title="为什么Visual Studio 2017没有Paste XML as Classes功能"></a>为什么Visual Studio 2017没有Paste XML as Classes功能</h2><p>“将XML粘贴为类”功能是Windows Communication Foundation的功能之一，需要勾选Visual Studio Installer -&gt; 单个组件 -&gt; WCF，并完成安装，大小1.84GB。<br><del>沙雕巨硬，这么常用的功能非得放在WCF里，又不是只有ASP.NET开发才会用。就为这一个功能还要装一个WCF，都被骂几年了还不改。还不如老子自己手动转Class..</del></p><h2 id="为什么XmlDocument中SelectNode返回为null"><a href="#为什么XmlDocument中SelectNode返回为null" class="headerlink" title="为什么XmlDocument中SelectNode返回为null"></a>为什么XmlDocument中SelectNode返回为null</h2><p><del>woc，老子在别的地方查了两天的bug，结果最后发现是读取数据时出的问题,哭了</del><br>假设要从下面的XML文件中提取所有<code>&lt;course&gt;</code>节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">semester</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"统计学"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">courseid</span>&gt;</span>1800113X<span class="tag">&lt;/<span class="name">courseid</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">classid</span>&gt;</span>1800113X--001<span class="tag">&lt;/<span class="name">classid</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">credit</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">credit</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">gpa</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">gpa</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">grade</span>&gt;</span>97<span class="tag">&lt;/<span class="name">grade</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">detail</span>&gt;</span>平时成绩:100期末考试:94作业撰写:100<span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">course</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"测控专业导论（下）"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">courseid</span>&gt;</span>0115022B<span class="tag">&lt;/<span class="name">courseid</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">classid</span>&gt;</span>0115022B--001<span class="tag">&lt;/<span class="name">classid</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">credit</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">credit</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">gpa</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">gpa</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">grade</span>&gt;</span>优<span class="tag">&lt;/<span class="name">grade</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">detail</span>&gt;</span>论文撰写:优出勤率:优<span class="tag">&lt;/<span class="name">detail</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">course</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">semester</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一开始尝试使用foreach loop读取信息，结果发现foreach语句压根没有执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XmlNode xn_semester = xmlDoc.SelectSingleNode(<span class="string">"semester"</span>);</span><br><span class="line">XmlNodeList xnl_courses = xn_semester.SelectNode(<span class="string">"course"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(XmlNode xn_course <span class="keyword">in</span> xnl_courses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环里随便放一些乱七八糟的东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开VS调试，打断点，xn_course始终为null是什么情况？调试窗口里xnl_courses下count的值始终为0？？<br>Google一下，万能的StackOverflow也有类似的问题：<a href="https://stackoverflow.com/questions/41172258/c-sharp-xmldocument-select-nodes-returns-empty" target="_blank" rel="noopener">C# XmlDocument select nodes returns empty</a>。<br>虽然情况不太一样，但马上也能看出问题所在了，解决方法也很简单，改成这样就可以了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XmlNode xn_semester = xmlDoc.SelectSingleNode(<span class="string">"semester"</span>);</span><br><span class="line">XmlNodeList xnl_courses = xn_semester.SelectNode(<span class="string">"//semester//course"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(XmlNode xn_course <span class="keyword">in</span> xnl_courses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环里随便放一些乱七八糟的东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实证明，偷懒不好好补一补相关知识是会遭报应的….当时还迷之自信觉得这段代码没问题Orz<br><del>不学XPath就乱写的后果.jpg</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何将result-array和string进行互转？&quot;&gt;&lt;a href=&quot;#如何将result-array和string进行互转？&quot; class=&quot;headerlink&quot; title=&quot;如何将result array和string进行互转？&quot;&gt;&lt;/a&gt;如何将result array和string进行互转？&lt;/h2&gt;&lt;p&gt;假设使用UTF-8编码：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Notes</title>
    <link href="http://wangyuyang.me/2019/02/12/Notes/"/>
    <id>http://wangyuyang.me/2019/02/12/Notes/</id>
    <published>2019-02-12T12:47:04.000Z</published>
    <updated>2019-02-17T10:39:22.545Z</updated>
    
    <content type="html"><![CDATA[<p>随便记一些看到的东西。</p><h2 id="Lorem-ipsum-dolor-sit-amet-adipisicing-elit"><a href="#Lorem-ipsum-dolor-sit-amet-adipisicing-elit" class="headerlink" title="Lorem ipsum dolor sit amet, adipisicing elit"></a>Lorem ipsum dolor sit amet, adipisicing elit</h2><p>XAML Controls Gallery里看到的拉丁语。<br><a id="more"></a> </p><blockquote><p>虽然该短语毫无意义，但它却历史悠久。数个世纪以来，印刷工人一直使用该短语来表现其字体最与众不同的特点。使用该短语是因为其中的字母以及字母组合中的字母间距可以最好地展现所用字体的粗细、设计及其他重要特点。</p><p>1994 年的一期《Before &amp; After》杂志将“Lorem ipsum …”追溯到 de Finibus Bonorum et Malorum（西塞罗在公元前 45 年撰写的伦理学理论方面的论文）中一段文字的混乱的拉丁语版。段落“Lorem ipsum …”摘选自文字“Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit …”，可以翻译为“没有人喜欢痛苦，追逐痛苦并且想拥有痛苦，因为痛苦就是痛苦…”</p><p>在 16 世纪，一位印刷工人改写了西塞罗的文字，并将其发展成一页印刷样本。此后，这种类似拉丁语的文字就成为了印刷界样本文字的标准。在电子出版以前，图形设计师不得不通过画弯弯曲曲的线来表示文字，以便模仿版式。预先印有“Lorem ipsum”的自粘式纸张的出现提供了一种更切实的用于表示文字在页面中的位置的方法。</p></blockquote><p>摘自<a href="https://support.microsoft.com/zh-cn/help/114222/description-of-the-lorem-ipsum-dolor-sit-amet-text-that-appears-in-wor" target="_blank" rel="noopener">Microsoft支持</a></p><h2 id="Hamburger-Button"><a href="#Hamburger-Button" class="headerlink" title="Hamburger Button"></a>Hamburger Button</h2><p>什么是Hamburger button？<br><blockquote><p>The hamburger button is a button placed typically in a top corner of a graphical user interface. Its function is to toggle a menu or navigation bar between being collapsed behind the button or displayed on the screen. The icon typically associated with this menu, which consists of three horizontal bars, is more formally known as the collapsed menu icon. However, the term Hamburger Button gained acceptance and has become a commonly used term.</p></blockquote></p><p>摘自Wikipedia<a href="https://en.wikipedia.org/wiki/Hamburger_button" target="_blank" rel="noopener">Hamburger button</a></p><h2 id="outerHTML-和-innerHTML"><a href="#outerHTML-和-innerHTML" class="headerlink" title="outerHTML 和 innerHTML"></a>outerHTML 和 innerHTML</h2><p>innerHTML:从对象的起始位置到终止位置的全部内容,不包括Html标签。<br>outerHTML:除了包含innerHTML的全部内容外, 还包含对象标签本身。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">span</span>&gt;</span> test2 </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1）innerHTML的值是“<span style="color:red">test1</span> test2 ”</p><p>2）outerHTML的值是<div id="test"><span style="color:red">test1</span> test2</div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随便记一些看到的东西。&lt;/p&gt;
&lt;h2 id=&quot;Lorem-ipsum-dolor-sit-amet-adipisicing-elit&quot;&gt;&lt;a href=&quot;#Lorem-ipsum-dolor-sit-amet-adipisicing-elit&quot; class=&quot;headerlink&quot; title=&quot;Lorem ipsum dolor sit amet, adipisicing elit&quot;&gt;&lt;/a&gt;Lorem ipsum dolor sit amet, adipisicing elit&lt;/h2&gt;&lt;p&gt;XAML Controls Gallery里看到的拉丁语。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UWP开发笔记</title>
    <link href="http://wangyuyang.me/2019/02/09/UWP%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2019/02/09/UWP开发笔记/</id>
    <published>2019-02-09T08:30:43.000Z</published>
    <updated>2019-02-25T11:26:52.137Z</updated>
    
    <content type="html"><![CDATA[<p><del>想给爬虫写一个GUI，再挖一个新坑hhh</del><br>笔记主要整理自Bob Tabor的视频教程<a href="https://www.bilibili.com/video/av7997007" target="_blank" rel="noopener">Windows 10 development for absolute beginners</a>、Microsoft官方文档以及<a href="http://www.runoob.com/aboutus" target="_blank" rel="noopener">Runoob</a>。<br><a id="more"></a> </p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="一个XML文档实例"><a href="#一个XML文档实例" class="headerlink" title="一个XML文档实例"></a>一个XML文档实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一个XML文档实例，摘自www.runoob.com/xml/xml-tree.html--&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"COOKING"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"CHILDREN"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"WEB"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到XML注释的语法与HTML相似，注释的下一行指出了文档的版本和编码。</p><h3 id="元素和属性"><a href="#元素和属性" class="headerlink" title="元素和属性"></a>元素和属性</h3><p>XML中一定包含一个根元素，其他所有元素都是根元素的子集。</p><p>XML元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p><p>一个元素可以包含：</p><ul><li>其他元素</li><li>文本</li><li>属性</li><li>或混合以上所有…</li></ul><p>该实例中 <code>&lt;bookstore&gt;</code>为根元素。文档中的所有 <code>&lt;book&gt;</code>元素都被包含在 <code>&lt;bookstore&gt;</code>中。</p><p>每个<code>&lt;book&gt;</code>元素都有一个属性（名称/值的对），如<code>category=&quot;CHILDREN&quot;</code>，属性值必须加引号（单双均可）。</p><p>需要注意因使用属性而引起的一些问题：</p><ul><li>属性不能包含多个值（元素可以）</li><li>属性不能包含树结构（元素可以）</li><li>属性不容易扩展（为未来的变化）</li></ul><p><code>&lt;book&gt;</code> 元素有 4 个子元素：<code>&lt;title&gt;、&lt;author&gt;、&lt;year&gt;、&lt;price&gt;</code>，可以看到这四个子元素都包含文本，如<code>Erik T. Ray</code>。</p><h3 id="DTD-和-Schemes"><a href="#DTD-和-Schemes" class="headerlink" title="DTD 和 Schemes"></a>DTD 和 Schemes</h3><p>XML语言没有预定义的标签（不同于HTML，HTML中使用的标签都是预定义的。HTML 文档只能使用在 HTML 标准中定义过的标签（如 <code>&lt;p&gt;、&lt;h1&gt;</code> 等等））。XML DTD（Document Type Definition）定义了XML文档的结构。DTD定义了一个XML文档中可以有哪些元素，每个XML文档都有必要在开头声明引用了哪一个DTD文件。</p><p>2001年5月2日起，W3C标准开始支持一种DTD的代替者，XML Schema。Schema比DTD更强大，更灵活，后面在XAML中会用到他。</p><h3 id="XML-Namespaces"><a href="#XML-Namespaces" class="headerlink" title="XML Namespaces"></a>XML Namespaces</h3><p>XML 命名空间提供避免元素命名冲突的方法。<br>在XML中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。</p><p>例如，这个XML携带HTML表格的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个XML文档携带有关桌子的信息（一件家具）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的<code>&lt;table&gt;</code>元素，就会发生命名冲突。命名冲突可以通过使用名称前缀避免。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:h</span>=<span class="string">"URI1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:f</span>=<span class="string">"URI2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h:table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的实例中，不会有冲突，因为两个<code>&lt;table&gt;</code>元素有不同的名称。</p><p>为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。</p><p>命名空间URI不会被解析器用于查找信息。很多公司常常会使命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。</p><hr><h2 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h2><p>XAML本质上仍是XML，在利用XMAL定义UI的过程实际上是在创建类的实例，并给他们设定相应的属性值。</p><p>XAML完全可以被C#取代，但如果使用C#创建实例并赋值，代码会非常繁琐。而借助于类型转换器（Type Converters），可以在XAML中用一个字符串来表示属性，类型转换器会帮助我们将字符串转换为相应的枚举值，类的实例等（C#中则必须写出完整的枚举值，甚至是类的实例），大大简化了代码。</p><p>例如，在C#中定义一个按钮：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Page_Loaded</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Button myButton = <span class="keyword">new</span> Button();</span><br><span class="line">    ...</span><br><span class="line">    myButton.HorizontalAlignment =  HorizontalAlignment.Left;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在XAML中，只需写成：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">"myButton"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>XAML语法分析器会将字符串的值转换为它所对应的显示声明的枚举值，在这里就是将<code>Left</code>转换为了<code>Windows.UI.Xaml.HorizontalAlignment.Left</code></p><p>此外，XAML可以使用Visual Studio提供的可视化设计器进行修改，非常直观。</p><p>疑问，待查：XML到底有没有类的概念，为什么XAML里有？</p><h3 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h3><p>暂时了解到这四种，以后填坑：<br><del>flag</del></p><ul><li>默认属性</li><li>复杂属性</li><li>附加属性</li><li>属性元素</li></ul><h3 id="纲要（Schemas）"><a href="#纲要（Schemas）" class="headerlink" title="纲要（Schemas）"></a>纲要（Schemas）</h3><p>定义了XAML的语法规则、UWP API中的控件，对Blend和Visual Studio中的可视化设计器的支持等。</p><p>MainPage.xaml文件顶端的代码就是XAML的Schemas，一般不需要改动。</p><h3 id="命名空间（Namespaces）"><a href="#命名空间（Namespaces）" class="headerlink" title="命名空间（Namespaces）"></a>命名空间（Namespaces）</h3><p>在命名空间后加冒号“ : ”时，实际上是在告诉XAML语法分析器在哪里能够找到这个元素的定义。大部分XAML代码都不需要带命名空间，Page中已经定义了一个默认命名空间。</p><hr><h2 id="XAML-Controls-Gallery"><a href="#XAML-Controls-Gallery" class="headerlink" title="XAML Controls Gallery"></a>XAML Controls Gallery</h2><p>XAML Controls Gallery应用包含了Fluent Design System和XAML所有可用的控件实例。<br><a href="https://www.microsoft.com/zh-cn/p/xaml-controls-gallery/9msvh128x2zt?activetab=pivot%3Aoverviewtab" target="_blank" rel="noopener">获取 XAML 控件库应用 (Microsoft Store)</a><br>墙裂推荐的这个UWP应用！！里面可以随意修改每一个控件的属性并立刻看到效果，再也不用怕文档描述模糊看不懂了！应用本身也是开源的。<br><del>微软大法好！！！！！</del></p><hr><h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>Grid没有Content属性，但具有UElementCollection类型的Children属性，因此可以将多个控件放入同一个布局控件中去。<br>在尝试将控件嵌入另一个控件时，实际上是在调用Children属性的Add方法，例如（在C#中实现）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grid.Children.Add(OneofMyButton);</span><br></pre></td></tr></table></figure><p>根据需要，可以指定Grid各行各列的尺寸大小，有两种方式：</p><ul><li>使用Auto和 *</li><li>直接指定数值大小</li></ul><p>每一个Grid中都有一个默认格子，即第0行第0列（无需定义）<br>如果将控件在不指定行列的情况下放入Grid，默认将放在第0行第0列。<br>Grid中元素可以跨行跨列。</p><h3 id="Auto-和"><a href="#Auto-和" class="headerlink" title="Auto 和 *"></a>Auto 和 *</h3><p>Auto方法下，Grid会用其包含的最大尺寸元素来定义行或列的尺寸<br>* 为从剩下的空间中取出1份，类似的 2* 则为取出2份……</p><hr><h2 id="Grid和StackPanel布局的区别"><a href="#Grid和StackPanel布局的区别" class="headerlink" title="Grid和StackPanel布局的区别"></a>Grid和StackPanel布局的区别</h2><p>Grid，字面意思，相当于表格，可以直接定位到指定的x行y列。<br>Grid中的控件默认会被自动居中，两个控件可以任意重叠。</p><p>StackPanel，由名字可以看出，元素会被一个接一个的放置在每一横行或每一竖行，类似于HTML中的div，或者Android中的LinearLayout。</p><p>StackPanel通过嵌套可以实现类似Grid定位到指定行列的效果。</p><p>StackPanel的子控件默认从上向下排列，当设置为横向时默认从左向右排列，两个子控件不允许重叠。</p><p>两个例子：<br>使用Grid：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将窗口均分为2*2的方格--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Grid.Coloum</span>=<span class="string">"0"</span> <span class="attr">Grid.Row</span>=<span class="string">"0"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Grid.Coloum</span>=<span class="string">"1"</span> <span class="attr">Grid.Row</span>=<span class="string">"0"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Grid.Coloum</span>=<span class="string">"0"</span> <span class="attr">Grid.Row</span>=<span class="string">"1"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Grid.Coloum</span>=<span class="string">"1"</span> <span class="attr">Grid.Row</span>=<span class="string">"1"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用StackPanel：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Orientation</span>=<span class="string">"Vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Orientation</span>=<span class="string">"Horizontal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span>&gt;</span>1<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span>&gt;</span>2<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Orientation</span>=<span class="string">"Horizontal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span>&gt;</span>3<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span>&gt;</span>4<span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更详细的可以看这两篇文章：<br><a href="https://social.technet.microsoft.com/wiki/contents/articles/32944.difference-between-grid-and-stackpanel.aspx" target="_blank" rel="noopener">Difference between Grid and StackPanel</a><br><a href="https://docs.microsoft.com/en-us/windows/uwp/design/layout/grid-tutorial" target="_blank" rel="noopener">Tutorial: Use Grid and StackPanel to create a simple weather app</a></p><hr><h2 id="RelativePanel-Class"><a href="#RelativePanel-Class" class="headerlink" title="RelativePanel Class"></a>RelativePanel Class</h2><p><em>Namespace: Windows.UI.Xaml.Controls</em><br><em>Assemblies: Windows.UI.Xaml.Controls.dll, Windows.dll</em></p><p>一个非线性UI的面板控件，“非线性”指的是元素之间的关系不是堆叠的，因此难以用Grid和StackPanel实现。</p><p>RelativePanel是通过相对位置布局，在它的内部有两种定位方式：</p><ul><li>定义几个子元素之间的位置关系</li><li>定义子元素与父面板之间的位置关系</li></ul><p>用于在RelativePanel内定位的Attached Property有三类：</p><ul><li>Sibling Position Relationship，同级位置关系，用于放置同级元素，如控件的上、下、左、右</li><li>Sibling Alignment Relationship，同级对齐关系，如控件间的左对齐、顶端对齐等</li><li>Panel Alignment Relationship，面板对齐关系，如将控件和面板左对齐、顶端对齐等</li></ul><p>一些常用的Properties：</p><table><thead><tr><th>Property Names</th><th>含义</th></tr></thead><tbody><tr><td>RelativePanel.LeftOf</td><td>对齐到另一控件的左侧</td></tr><tr><td>RelativePanel.RightOf</td><td>对齐到另一控件的右侧</td></tr><tr><td>RelativePanel.Above</td><td>对齐到另一控件的顶端</td></tr><tr><td>RelativePanel.Below</td><td>对齐到另一控件的底端</td></tr><tr><td></td><td></td></tr><tr><td>RelativePanel.AlignLeftWith</td><td>两个控件的左侧对齐</td></tr><tr><td>RelativePanel.AlignRightWith</td><td>两个控件的右侧对齐</td></tr><tr><td>RelativePanel.AlignTopWith</td><td>两个控件的顶端对齐</td></tr><tr><td>RelativePanel.AlignBottomWith</td><td>两个控件的底端对齐</td></tr><tr><td>RelativePanel.AlignHorizontalCenterWith</td><td>两个控件中心的横坐标相同</td></tr><tr><td>RelativePanel.AlignVerticalCenterWith</td><td>两个控件中心的纵坐标相同</td></tr><tr><td></td><td></td></tr><tr><td>RelativePanel.AlignLeftWithPanel</td><td>与面板左对齐</td></tr><tr><td>RelativePanel.AlignRightWithPanel</td><td>与面板右对齐</td></tr><tr><td>RelativePanel.AlignTopWithPanel</td><td>与面板顶端对齐</td></tr><tr><td>RelativePanel.AlignBottomWithPanel</td><td>与面板底端对齐</td></tr><tr><td>RelativePanel.AlignHorizontalCenterWithPanel</td><td>在面板内水平居中</td></tr><tr><td>RelativePanel.AlignVerticalCenterWithPanel</td><td>在面板内垂直居中</td></tr></tbody></table><p>需要注意以下同级对齐关系和同级位置关系的区别：<br>以RelativePanel.LeftOf和RelativePanel.AlignLeftWith为例，假设有两个控件A和B，那么对于A而言：</p><ul><li><code>RelativePanel.LeftOf=&quot;B&quot;</code> 就是让A的右侧对齐到B的左侧，A和B没有重叠。</li><li><code>RelativePanel.AlignLeftWith=&quot;B&quot;</code> 就是让A的左侧对齐到B的左侧，A和B重叠在一起。</li></ul><p>另外所有的面板对齐关系均为Bool类型（属性值为True或False）。</p><p>还有水平居中就是让控件左右边距相同，垂直居中就是上下边距相同。</p><p>全部的Properties可以查阅Microsoft Docs <a href="https://docs.microsoft.com/zh-cn/uwp/api/windows.ui.xaml.controls.relativepanel" target="_blank" rel="noopener">RelativePanel Class</a><br><del>Microsoft的文档是真的详细，还是想说一句，微软大法好！!</del></p><p>如果控件的位置关系存在冲突，则按照以下优先级顺序：<br>面板对齐关系 &gt; 同级对齐关系 &gt; 同级位置关系</p><hr><h2 id="SplitView-Class"><a href="#SplitView-Class" class="headerlink" title="SplitView Class"></a>SplitView Class</h2><p><em>Namespace: Windows.UI.Xaml.Controls</em><br><em>Assemblies: Windows.UI.Xaml.Controls.dll, Windows.dll</em></p><p>API：<a href="https://docs.microsoft.com/en-us/uwp/api/Windows.UI.Xaml.Controls.SplitView" target="_blank" rel="noopener">SplitView 类</a></p><p>拆分视图控件，一个能显示两个视图的容器，其中一个视图是主页面的content，另一个视图是一个能随意展开/折叠的窗格，一般被用做Hamburger Menu。<br>举个栗子，网易云音乐UWP主界面左侧的Hamburger Menu（写有搜索、发现音乐、我的音乐和歌单等内容的那个灰色部分）就是这玩意儿。</p><p>SplitView有几个常用的属性：</p><ul><li>PaneBackground，面板背景</li><li>IsPaneOpen，面板是开启/关闭状态，值为Bool类型</li><li>OpenPaneLength，面板开启后长度</li><li>DisplayMode 面板的显示模式，有四种：<ul><li>Inline，窗格始终可见，并且不会覆盖内容区域</li><li>CompactInline，始终可以看见狭窄的部分窗格。默认关闭窗格宽度为48px，可以使用CompactPaneLength进行修改。如果打开窗格，将减少用于内容的空间，从而会将内容挤出去</li><li>Overlay，在打开之前隐藏窗格。在打开时，窗格覆盖内容区域</li><li>CompactOverlay，始终可以看见狭窄的部分窗格。默认关闭窗格宽度为48px，可以使用CompactPaneLength进行修改。如果打开窗格，将覆盖内容区域</li></ul></li><li>CompactPaneLength，见上</li></ul><p>说白了，Overlay和Inline的本质区别就是Inline下打开时会把下面的内容推开，Overlay则会把下面的内容盖住；加了Compact之后区别就是关闭窗格之后能看到一个狭窄的小窗格。</p><p>仍然以网易云音乐为例，网易云音乐左侧的SplitView，IsPaneOpen的值默认为True，DisplayMode的值为CompactInline。<br>系统自带的MSN天气也类似，只不过应用开启时IsPaneOpen的值为False。</p><p>Windows 10 Fall Creators Update (introduced v10.0.16299.0)中引入了一个全新的构件NavigationView，在过去制作一个漂亮的Hamburger Menu需要由开发者利用SplitView从头到尾进行设计。但现在，借助于NavigationView，只需很少的代码就可以制作出一个美观的Hamburger Menu。<br>手工绘制一个Hamburger Menu：<a href="http://blog.jerrynixon.com/2015/04/implementing-hamburger-button-with.html" target="_blank" rel="noopener">Implementing an Awesome Hamburger Button with XAML’s new SplitView control in Windows 10</a><br>利用NavigationView制作一个Hamburger Menu：<a href="https://msdn.microsoft.com/en-us/magazine/mt814416.aspx" target="_blank" rel="noopener">A Developer’s Guide to the New Hamburger Menu in Windows 10</a></p><hr><h2 id="NavigationView-Class"><a href="#NavigationView-Class" class="headerlink" title="NavigationView Class"></a>NavigationView Class</h2><p><em>Namespace: Windows.UI.Xaml.Controls</em><br><em>Assemblies: Windows.UI.Xaml.Controls.dll, Windows.dll</em></p><p><del>别人的情人节在撩妹子，我的情人节就是在敲代码…..</del></p><p>参见：<a href="https://docs.microsoft.com/zh-cn/uwp/api/Windows.UI.Xaml.Controls.NavigationView" target="_blank" rel="noopener">NavigationView 类</a></p><p>拖进Visual Studio里试了一下，还是很漂亮的，而且用起来也很方便。</p><table><thead><tr><th>Properties</th><th></th></tr></thead><tbody><tr><td>IsSettingsVisible</td><td>设置按钮是否可见</td></tr><tr><td>PaneDisplayMode</td><td>显示模式</td></tr></tbody></table><p>IsSettingsVisible的值为Bool类型。</p><p>PaneDisplayMode属性需要 Windows 10 版本 1809 (SDK 17763) 或更高版本，或Windows UI 库支持。<br>PaneDisplayMode有五种值可选：</p><table><thead><tr><th>Value</th><th></th></tr></thead><tbody><tr><td>Top</td><td>面板位于顶端</td></tr><tr><td>Left</td><td>面板位于左端</td></tr><tr><td>LeftCompact</td><td>面板位于左端，且处于折叠状态，能看到所有图标</td></tr><tr><td>LeftMinimal</td><td>面板位于左端，且处于折叠状态，仅能看到菜单图标</td></tr><tr><td>Auto</td><td>根据窗口尺寸自适应变化</td></tr></tbody></table><p>另外NavigationView pane中可以包含这些Object：</p><ul><li>NavigationViewItem，用于导航到特定页面的导航项目。</li><li>NavigationViewItemSeparator，用作导航项的分隔符。</li><li>NavigationViewItemHeader，用做几个导航项的标题。</li></ul><p>NavigationView 面板的结构图可以看<a href="https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/navigationview#anatomy" target="_blank" rel="noopener">Navigation view–Anatomy</a>。</p><h3 id="如何调节Navigation高度、字体等参数？"><a href="#如何调节Navigation高度、字体等参数？" class="headerlink" title="如何调节Navigation高度、字体等参数？"></a>如何调节Navigation高度、字体等参数？</h3><p>可以参考Stack Overflow上的<a href="https://stackoverflow.com/questions/47776746/uwp-change-navigationviewitem-height" target="_blank" rel="noopener">这个</a>问题。</p><p>以调节NavigationViewItem高度为例，选中NavigationViewItem，在XAML设计器上右键-编辑模板-编辑副本。然后在Resource内修改LayoutRoot和SelectionIndicator的高度即可。</p><h3 id="NavigationViewItem-Object"><a href="#NavigationViewItem-Object" class="headerlink" title="NavigationViewItem Object"></a>NavigationViewItem Object</h3><p>就是指导航项目（Navigation Item），如系统设置-更新与安全左侧Hamburger Menu里的“Windows更新”、“Windows安全”等条目。</p><blockquote><p>Note that prior to Windows 10, version 1809 (10.0; Build 17763) you could only place NavigationViewItems in NavigationView.MenuItems.</p></blockquote><p>根据文档中的描述，1809之前的版本在使用时需要注意NavigationViewItems必须放置在NavigationView.MenuItems内，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"Windows更新"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"Windows安全"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"备份"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"疑难解答"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationView</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Properties</th><th></th></tr></thead><tbody><tr><td>Content</td><td>每个Item显示的文本，如“Windows更新”等</td></tr><tr><td>Icon</td><td>Content旁边的图标，如“Windows安全”左侧盾牌图标。</td></tr></tbody></table><p>如果需要插入FontIcon，可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"课程表"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationViewItem.Icon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FontIcon</span> <span class="attr">FontFamily</span>=<span class="string">"Segoe MDL2 Assets"</span> <span class="attr">Glyph</span>=<span class="string">"&amp;#xE163;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationViewItem.Icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationViewItem</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="NavigationViewItemHeader-Object"><a href="#NavigationViewItemHeader-Object" class="headerlink" title="NavigationViewItemHeader Object"></a>NavigationViewItemHeader Object</h3><p>导航项目的标题，比如：“更新与安全”、“我的音乐”、“创建的歌单”等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItemHeader</span> <span class="attr">Content</span>=<span class="string">"更新与安全"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"Windows更新"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationView</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="NavigationViewItemSeparator-Object"><a href="#NavigationViewItemSeparator-Object" class="headerlink" title="NavigationViewItemSeparator Object"></a>NavigationViewItemSeparator Object</h3><p>插入到Item之间起到空格的效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItemHeader</span> <span class="attr">Content</span>=<span class="string">"更新与安全"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItemSeparator</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> <span class="attr">Content</span>=<span class="string">"Windows更新"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插入后，“更新与安全” 和 “Windows更新”会被分割开一小块距离。</p><h3 id="设置SelectedItem-null-后无变化的解决办法"><a href="#设置SelectedItem-null-后无变化的解决办法" class="headerlink" title="设置SelectedItem = null 后无变化的解决办法"></a>设置SelectedItem = null 后无变化的解决办法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Tag</span>=<span class="string">"Transcript"</span>&gt;</span></span><br><span class="line">                成绩单</span><br><span class="line">            <span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.PaneFooter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">Content</span>=<span class="string">"登录"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">Tapped</span>=<span class="string">"NavigationViewPaneFooterLogin_Tapped"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.PaneFooter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于如上所示的页面，如果选中“成绩单”所在的NavigationViewItem，会在“成绩单”左侧出现一个用于指示选中项的蓝色小矩形，但问题是，由于在PaneFooter下的NavigationViewItem被选中时，不会有MenuItem下的动画变化，因此我如果再点击“登录”，这个指示器并不会消失，而是会继续留在“成绩单”的位置。</p><p>对此我尝试了用SelectedItem = null来消除上一次的选择，结果发现并没有变化。网上找了一圈也没找到原因所在，最后考虑设置一个空的NavigationViewItem来解决问题：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">NavigationView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Tag</span>=<span class="string">"Transcript"</span>&gt;</span></span><br><span class="line">                成绩单</span><br><span class="line">            <span class="tag">&lt;/<span class="name">TextBlock</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插入一个空的Item --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationViewItem</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">Name</span>=<span class="string">"ThisIsAHiddenItem"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">Visibility</span>=<span class="string">"Collapsed"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.MenuItems</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationView.PaneFooter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">NavigationViewItem</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">Content</span>=<span class="string">"登录"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">Tapped</span>=<span class="string">"NavigationViewPaneFooterLogin_Tapped"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">NavigationViewItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigationView.PaneFooter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">NavigationView</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>设置一个Visibility属性为Collapsed的Item后，在NavigationViewPaneFooterLogin_Tapped事件中设置<code>SelectedItem = ThisIsAHiddenItem</code>，运行一下，成功解决问题~</p><hr><h2 id="实现两个页面之间的导航"><a href="#实现两个页面之间的导航" class="headerlink" title="实现两个页面之间的导航"></a>实现两个页面之间的导航</h2><p>看这一部分视频教程的时候完全没看明白到底发生了什么，去补了一下UWP结构的知识，这方面的资料似乎比较少，结合自己的理解好像是这样的关系（不知道对不对）：</p><p>当运行一个应用（Application）时，应用会自动创建一个主视图，也就是我们看到的那个窗口（Window），根据需要，我们还可以创建其它辅助视图（更多的Window），不过一般只需一个主视图就够了。</p><blockquote><p>辅助视图和应用多开不一样！应用多开功能在Windows 10 （17134）中才被引入。</p></blockquote><p>在Window中又包含一个框架（Frame），Frame中则包含有任意数量的Page（也可以只有一个MainPage），Page中则包括了前面学到的各种控件，比如Button、TextBlock等，在这一点上，Frame和Page的关系有点像浏览器和它的所有标签页一样。<br>特别的，Page下也可以包含一个Frame，然后在这个Frame下又可以“加入”一些Page。</p><p>每一个页面就是一个Page，以网易云音乐UWP为例，在启动程序后，会弹出网易云音乐的主窗口，主窗口左侧的SplitView中，我们可以选择“搜索”、“发现音乐”、“MV”、“朋友”等内容。点击后就会跳转到相应的Page中。</p><p>具体来说，在主窗口中，包含有一个最顶层的Frame，也就是rootFrame，rootFrame下有一个MainPage。Bob的第19个教程就是在MainPage中添加一个名为“myFrame”的Frame，然后在这个新添加的Frame中引入Page1、Page2，Page3等。</p><p>回到最初的问题上，由于不同的Page都属于同一个Frame，所以页面间的导航就由Frame控制（就像在浏览器里切换页面，这一操作是通过浏览器实现的）。Frame类有一个方法Navigate，参数为要导航到的页面类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootFrame.Navigate(<span class="keyword">typeof</span>(MainPage), e.Arguments);</span><br></pre></td></tr></table></figure><p>上面给出了导航到MainPage的C#代码，第二个参数可省略，暂且不管。第一个参数并不是直接使用页面的名称MainPage，还要使用typeof()运算符。</p><p>Frame同时也保留了导航到的页面的历史记录，因此可以使用GoBack和GoForward方法实现前进/后退功能，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFrame.GoBack();</span><br></pre></td></tr></table></figure><p>但是如果历史记录是空的，比如说用户刚启动应用就尝试点击后退按钮怎么办？为了避免用户进入不存在的页面，Frame还提供了两个方法CanGoBack和CanGoForward，如果后退/前进历史记录中至少存在一条记录，则返回一个Bool值True，反之为False，因此代码可以这样修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(myFrame.CanGoBack)</span><br><span class="line">&#123;</span><br><span class="line">    myFrame.Goback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;想给爬虫写一个GUI，再挖一个新坑hhh&lt;/del&gt;&lt;br&gt;笔记主要整理自Bob Tabor的视频教程&lt;a href=&quot;https://www.bilibili.com/video/av7997007&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 10 development for absolute beginners&lt;/a&gt;、Microsoft官方文档以及&lt;a href=&quot;http://www.runoob.com/aboutus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Runoob&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Python实现QQ“穿越福城”辅助</title>
    <link href="http://wangyuyang.me/2019/01/31/%E7%94%A8Python%E5%AE%9E%E7%8E%B0QQ%E2%80%9C%E7%A9%BF%E8%B6%8A%E7%A6%8F%E5%9F%8E%E2%80%9D%E8%BE%85%E5%8A%A9/"/>
    <id>http://wangyuyang.me/2019/01/31/用Python实现QQ“穿越福城”辅助/</id>
    <published>2019-01-31T08:21:28.000Z</published>
    <updated>2019-01-31T15:47:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，腾讯QQ上线了一系列迎新春的活动，并在首页开放了一个名为“穿越福城”游戏。玩法类似于微信小程序跳一跳，emmmm…作为手残最高只能玩到140分，想起17年底Github有一个利用Python实现跳一跳辅助的项目（<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">戳这里</a>），决定自己也动手写一个辅助试一试。</p><a id="more"></a> <h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>整体思路和前面提到的项目大致相同，首先利用Android Debug Bridge(ADB)从设备上获取截图，然后利用Python的第三方库<code>Pillow</code>载入图像信息，并从截图中提取关键点坐标数据，计算出需要跳跃的距离。最后由距离乘以一个比例系数获得按压屏幕的时间，并利用ADB模拟按压动作。</p><hr><h3 id="一些遇到的问题"><a href="#一些遇到的问题" class="headerlink" title="一些遇到的问题"></a>一些遇到的问题</h3><p>整个程序的核心还是在于图像处理上，决定以方块中心的菱形橘色区域的颜色(255, 216, 116)作为筛选条件（一开始也考虑用方块两侧的两种不同的黄色来提取坐标，但是游戏后面会遇到红色方块和圆形方块，导致无法识别），提取边界点坐标，再利用中点坐标公式求方块中点。最后勾股定理计算两点距离。</p><p>程序的第一个版本只考虑了这些情况，然而运行时发现每一次都会多跳一些距离，在第四次时直接跳过头，游戏结束。仔细观察了一下，棋子每次完成跳跃后相机位置（或者说视角）都会发生变化，有时相机仅仅平移了一段距离，但有时相机高度会增加，有时相机又会降低。也就是说从图像上获得的距离并不是方块间的真实距离，需要进行修正。</p><p>修正的办法其实也很简单，相似图形对应边的比例都相同。只要找到游戏中长度固定的物体，以其长作为一个单位，计算距离与长度的比值即可。</p><p>至于物体的选择有且仅有三种：</p><blockquote><p>1.企鹅<br>2.白色桥梁的宽度<br>3.方块尺寸</p></blockquote><p>显然，方块尺寸并不固定，而游戏刚开始时看不到桥面，背景中的白色物体也会造成干扰。选择企鹅作为标准应该是最佳选择。</p><p>程序的第二个版本用上述方法进行了改进，效果显著，能够很轻松的跳到二三十分（虽然还是挺低的hhh），但又暴露出几个问题：</p><blockquote><p>1.广告牌颜色有时和选定区域颜色较为接近，造成干扰(说的就是你们，某酸灵，某新闻APP，还有PuPu鹅)</p><p>2.企鹅经常性跳来跳去的，跳跃过程中企鹅大小会发生明显变化，把录屏拖进<code>Adobe Premiere Pro CC</code>逐帧分析，企鹅每5s进行一次跳跃，每次跳跃持续35~40帧，如果截到的图中企鹅正在跳跃，就会导致计算出的企鹅宽度偏大，引入误差（直接表现在远距离跳跃时，桥长偏短）</p></blockquote><p>程序第三个版本对上述两个问题进行了修正，广告牌干扰还算容易解决，只要增加取样点求均值即可。但企鹅尺寸的变化没能找到一个很好的解决方法。我采用的方法是增加截图次数至四次，每次间隔1.33s，求四次长度并取中位数。但这种做法绝对算不上优雅，此外也明显的延长了两次跳跃的时间间隔，实在是蠢。不过这样修正后最高成绩可达到115<del>（还没有我自己手动玩的多Orz）</del>，效果还不错<del>（强行不错）</del>，暂时就这样吧，回头有更好的方法时再改。</p><p>另外代码有很多重复的地方可以封装为函数达到简化目的，懒得改了，显得很乱。</p><hr><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">screenshot</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 截图并保存到手机</span></span><br><span class="line">    os.system(<span class="string">'adb shell screencap -p /sdcard/screenshot.png'</span>)</span><br><span class="line">    <span class="comment"># 将截图发送至电脑</span></span><br><span class="line">    os.system(<span class="string">'adb pull /sdcard/screenshot.png'</span>)</span><br><span class="line">    <span class="comment"># 删除手机中的截图</span></span><br><span class="line">    os.system(<span class="string">'adb shell rm /sdcard/screenshot.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_coordinate</span><span class="params">(im)</span>:</span></span><br><span class="line">    <span class="comment"># 获得图像尺寸</span></span><br><span class="line">    w, h = im.size</span><br><span class="line">    im_pixel = im.load()</span><br><span class="line"></span><br><span class="line">    points_x2 = []</span><br><span class="line">    points_y2 = []</span><br><span class="line">    points_x1 = []</span><br><span class="line">    points_y1 = []</span><br><span class="line">    pixel = [<span class="keyword">None</span>] * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 寻找目标方块中心坐标</span></span><br><span class="line">    endy = <span class="number">0</span></span><br><span class="line">    find_nothing = <span class="keyword">False</span></span><br><span class="line">    already_find_point = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(int(h * <span class="number">2</span> / <span class="number">5</span>), h - <span class="number">10</span>, <span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果在找到上一个点之后又向下扫描60行，期间均未找到符合要求的点，则终止循环</span></span><br><span class="line">        <span class="keyword">if</span> y - endy == <span class="number">60</span> <span class="keyword">and</span> find_nothing <span class="keyword">and</span> already_find_point:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>, w - <span class="number">20</span>, <span class="number">1</span>):</span><br><span class="line">            pixel0 = im_pixel[x, y]</span><br><span class="line">            pixel1 = im_pixel[x + <span class="number">10</span>, y]</span><br><span class="line">            pixel2 = im_pixel[x + <span class="number">8</span>, y + <span class="number">5</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 排除广告牌干扰</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                pixel[i] = (pixel0[i] + pixel1[i] + pixel2[i]) * <span class="number">0.333</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">254</span> &lt;= pixel[<span class="number">0</span>] &lt;= <span class="number">255</span> <span class="keyword">and</span> <span class="number">213</span> &lt;= pixel[<span class="number">1</span>] &lt;= <span class="number">217</span> <span class="keyword">and</span> <span class="number">110</span> &lt;= pixel[<span class="number">2</span>] &lt;= <span class="number">115</span>):</span><br><span class="line">                points_x1.append(x)</span><br><span class="line">                points_y1.append(y)</span><br><span class="line">                endy = y</span><br><span class="line">                find_nothing = <span class="keyword">False</span></span><br><span class="line">                already_find_point = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                find_nothing = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理已经找到的点</span></span><br><span class="line">    destination_min_x = min(points_x1)</span><br><span class="line">    destination_max_x = max(points_x1)</span><br><span class="line"></span><br><span class="line">    destination_min_y = points_y1[points_x1.index(destination_min_x)]</span><br><span class="line">    destination_max_y = points_y1[points_x1.index(destination_max_x)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找横坐标时为了消除广告牌干扰，取右端10px位置处颜色平均值，故destination_max_x比真实值小10</span></span><br><span class="line">    centre_x1 = (destination_max_x + destination_min_x) / <span class="number">2</span> + <span class="number">5</span></span><br><span class="line">    centre_y1 = (destination_max_y + destination_min_y) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找企鹅所在方块中心坐标</span></span><br><span class="line">    endy = <span class="number">0</span></span><br><span class="line">    find_nothing = <span class="keyword">False</span></span><br><span class="line">    already_find_point = <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 如果目标在中轴线右边，则企鹅必定在左边</span></span><br><span class="line">    <span class="keyword">if</span> (w/<span class="number">2</span> - centre_x1) &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1550</span>, h - <span class="number">10</span>, <span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果在找到上一个点之后又向下扫描60行，期间均未找到符合要求的点，则终止循环</span></span><br><span class="line">            <span class="keyword">if</span> y - endy == <span class="number">60</span> <span class="keyword">and</span> find_nothing <span class="keyword">and</span> already_find_point:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>, destination_min_x - <span class="number">10</span>, <span class="number">1</span>):</span><br><span class="line">                pixel0 = im_pixel[x, y]</span><br><span class="line">                pixel1 = im_pixel[x + <span class="number">5</span>, y]</span><br><span class="line">                pixel2 = im_pixel[x + <span class="number">2</span>, y + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">                <span class="comment"># 排除广告牌干扰</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    pixel[i] = (pixel0[i] + pixel1[i] + pixel2[i]) * <span class="number">0.333</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">254</span> &lt;= pixel[<span class="number">0</span>] &lt;= <span class="number">255</span> <span class="keyword">and</span> <span class="number">213</span> &lt;= pixel[<span class="number">1</span>] &lt;= <span class="number">217</span> <span class="keyword">and</span> <span class="number">110</span> &lt;= pixel[<span class="number">2</span>] &lt;= <span class="number">115</span>):</span><br><span class="line">                    points_x2.append(x)</span><br><span class="line">                    points_y2.append(y)</span><br><span class="line">                    endy = y</span><br><span class="line">                    find_nothing = <span class="keyword">False</span></span><br><span class="line">                    already_find_point = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_nothing = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1550</span>, h - <span class="number">10</span>, <span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果在找到上一个点之后又向下扫描60行，期间均未找到符合要求的点，则终止循环</span></span><br><span class="line">            <span class="keyword">if</span> y - endy == <span class="number">60</span> <span class="keyword">and</span> find_nothing <span class="keyword">and</span> already_find_point:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(destination_max_x + <span class="number">10</span>, w<span class="number">-10</span>, <span class="number">1</span>):</span><br><span class="line">                pixel0 = im_pixel[x, y]</span><br><span class="line">                pixel1 = im_pixel[x + <span class="number">5</span>, y]</span><br><span class="line">                pixel2 = im_pixel[x + <span class="number">2</span>, y + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">                <span class="comment"># 排除广告牌干扰</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    pixel[i] = (pixel0[i] + pixel1[i] + pixel2[i]) * <span class="number">0.333</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">254</span> &lt;= pixel[<span class="number">0</span>] &lt;= <span class="number">255</span> <span class="keyword">and</span> <span class="number">213</span> &lt;= pixel[<span class="number">1</span>] &lt;= <span class="number">217</span> <span class="keyword">and</span> <span class="number">110</span> &lt;= pixel[<span class="number">2</span>] &lt;= <span class="number">115</span>):</span><br><span class="line">                    points_x2.append(x)</span><br><span class="line">                    points_y2.append(y)</span><br><span class="line">                    endy = y</span><br><span class="line">                    find_nothing = <span class="keyword">False</span></span><br><span class="line">                    already_find_point = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_nothing = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理已经找到的点</span></span><br><span class="line">    penguin_min_x = min(points_x2)</span><br><span class="line">    penguin_max_x = max(points_x2)</span><br><span class="line"></span><br><span class="line">    penguin_min_y = points_y2[points_x2.index(penguin_min_x)]</span><br><span class="line">    penguin_max_y = points_y2[points_x2.index(penguin_max_x)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找横坐标时为了消除广告牌干扰，取右端10px位置处颜色平均值，故penguin_max_x比真实值小10</span></span><br><span class="line">    centre_x2 = (penguin_max_x + penguin_min_x) / <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    centre_y2 = (penguin_max_y + penguin_min_y) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centre_x1, centre_y1, centre_x2, centre_y2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure_penguin_width</span><span class="params">(im)</span>:</span></span><br><span class="line">    w, h = im.size</span><br><span class="line">    im_pixel = im.load()</span><br><span class="line">    <span class="comment"># 找出企鹅宽度</span></span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(int(h * <span class="number">2</span> / <span class="number">5</span>), h, <span class="number">1</span>):</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, w):</span><br><span class="line">            pixel = im_pixel[x, y]</span><br><span class="line">            <span class="keyword">if</span>(pixel[<span class="number">0</span>] &lt;= <span class="number">70</span> <span class="keyword">and</span> pixel[<span class="number">1</span>] &lt;= <span class="number">70</span> <span class="keyword">and</span> pixel[<span class="number">2</span>] &lt;= <span class="number">70</span>):</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                points.append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 增加白色区域宽度</span></span><br><span class="line">    penguin_width = max(points) + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> penguin_width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swipe</span><span class="params">(centre_x1, centre_y1, centre_x2, centre_y2, penguin_width)</span>:</span></span><br><span class="line">    <span class="comment"># 计算图像上距离</span></span><br><span class="line">    distance = math.sqrt((centre_x1 - centre_x2) ** <span class="number">2</span> + (centre_y1 - centre_y2) ** <span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以企鹅宽度为一个单位，计算“真实”距离</span></span><br><span class="line">    actual_distance = (distance / penguin_width)</span><br><span class="line"></span><br><span class="line">    scaling_factor = <span class="number">157</span></span><br><span class="line">    press_time = int(scaling_factor * actual_distance)</span><br><span class="line"></span><br><span class="line">    print(press_time, distance)</span><br><span class="line"></span><br><span class="line">    os.system(<span class="string">'adb shell input swipe 720 1080 920 1280 &#123;duration&#125;'</span>.format(duration = press_time))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_coordinate</span><span class="params">(centre_x1, centre_y1, centre_x2, centre_y2, count, im)</span>:</span></span><br><span class="line">    <span class="comment"># 载入像素数据</span></span><br><span class="line">    im_pixel = im.load()</span><br><span class="line">    <span class="comment"># 标记取样点</span></span><br><span class="line">    im_pixel[centre_x1, centre_y1] = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    im_pixel[centre_x2, centre_y2] = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">    fp = <span class="string">'D:\\2019test\\screenshots\\&#123;count&#125;.png'</span>.format(count = count)</span><br><span class="line">    im.save(fp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        </span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        screenshot()</span><br><span class="line">        im = Image.open(<span class="string">'screenshot.png'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取关键坐标</span></span><br><span class="line">        centre_x1, centre_y1, centre_x2, centre_y2 = find_coordinate(im)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测量并修正企鹅宽度</span></span><br><span class="line">        penguin_width1 = measure_penguin_width(im)</span><br><span class="line">        time.sleep(<span class="number">1.33</span>)</span><br><span class="line">        </span><br><span class="line">        screenshot()</span><br><span class="line">        im = Image.open(<span class="string">'screenshot.png'</span>)</span><br><span class="line">        penguin_width2 = measure_penguin_width(im)</span><br><span class="line">        time.sleep(<span class="number">1.33</span>)</span><br><span class="line">        </span><br><span class="line">        screenshot()</span><br><span class="line">        im = Image.open(<span class="string">'screenshot.png'</span>)</span><br><span class="line">        penguin_width3 = measure_penguin_width(im)</span><br><span class="line">        time.sleep(<span class="number">1.33</span>)</span><br><span class="line">        </span><br><span class="line">        screenshot()</span><br><span class="line">        im = Image.open(<span class="string">'screenshot.png'</span>)</span><br><span class="line">        penguin_width4 = measure_penguin_width(im)</span><br><span class="line"></span><br><span class="line">        penguin_width = <span class="number">0.5</span> * (sorted([penguin_width1, penguin_width2, penguin_width3, penguin_width4])[<span class="number">1</span>] + sorted([penguin_width1, penguin_width2, penguin_width3, penguin_width4])[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算距离并完成跳跃</span></span><br><span class="line">        swipe(centre_x1, centre_y1, centre_x2, centre_y2, penguin_width)</span><br><span class="line">        <span class="comment"># 在截图中标出坐标点，并保存至指定文件夹</span></span><br><span class="line">        check_coordinate(centre_x1, centre_y1, centre_x2, centre_y2, count, im)</span><br><span class="line"></span><br><span class="line">        im.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设定延迟，保证落地</span></span><br><span class="line">        time.sleep(<span class="number">1.9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        os.system(<span class="string">'adb kill-server'</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，腾讯QQ上线了一系列迎新春的活动，并在首页开放了一个名为“穿越福城”游戏。玩法类似于微信小程序跳一跳，emmmm…作为手残最高只能玩到140分，想起17年底Github有一个利用Python实现跳一跳辅助的项目（&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这里&lt;/a&gt;），决定自己也动手写一个辅助试一试。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模拟登录HFUT新教务系统</title>
    <link href="http://wangyuyang.me/2019/01/20/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E6%96%B0%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wangyuyang.me/2019/01/20/模拟登录HFUT新教务系统/</id>
    <published>2019-01-20T06:16:35.000Z</published>
    <updated>2019-02-16T09:51:48.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天继续试一试模拟登录学校的新教务系统，新教务系统是由上海树维开发的。</p></blockquote><h2 id="思路寻找"><a href="#思路寻找" class="headerlink" title="思路寻找"></a>思路寻找</h2><p>和模拟登录信息门户一样，切到开发者模式，登录一次看一看请求过程。<br>login中可以看到网页后台提交了一个Request Payload：<br><a id="more"></a><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    username: "2019123456", </span><br><span class="line">    password: "91abd3f34f9de4fccfb71eade0dd825e275939ebf", </span><br><span class="line">    captcha: ""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>username是直接明文提交的，没什么问题，但password明显是加密过的。加密方式倒也很好判断，网页在加载时载入了一个名为<code>sha1.js</code>的文件，肯定是对密码进行了SHA-1加密。但是直接用密码在<a href="http://www.sha1-online.com/" target="_blank" rel="noopener">这里</a>试了一下，得到的结果和Request Payload并不一样。试着用<code>CTRL + F</code> 搜一下sha1.js中出现的<code>CryptpJS</code>，在login的Response中找到这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encryptPassword = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">$.get(&#123;</span><br><span class="line">  url: <span class="built_in">window</span>.CONTEXT_PATH + <span class="string">"/login-salt"</span>,</span><br><span class="line">  <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">salt</span>) </span>&#123;</span><br><span class="line">    encryptPassword = <span class="keyword">new</span> <span class="built_in">String</span>(CryptoJS.SHA1(salt + <span class="string">'-'</span> + $(<span class="string">"#p"</span>).val())) + <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postData = &#123;</span><br><span class="line">  username: $form.find(<span class="string">"[name=u]"</span>).val(),</span><br><span class="line">  password: encryptPassword,</span><br><span class="line">  captcha: $form.find(<span class="string">"[name=c]"</span>).val()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到实际提交的encryptPassword，加密前为<code>salt + &#39;-&#39; + password</code>, 而salt则从login-salt中获得。</p><p>需要注意，和登录信息门户时提交Form Data的方法不同，Post Payload请求需要另外做一些处理。</p><p>流程已经基本明确，剩下的就是要靠requests库来实现这一过程。</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录页</span></span><br><span class="line">login = <span class="string">'http://jxglstu.hfut.edu.cn/eams5-student/login'</span></span><br><span class="line"><span class="comment"># salt</span></span><br><span class="line">login_salt = <span class="string">'http://jxglstu.hfut.edu.cn/eams5-student/login-salt'</span></span><br><span class="line"><span class="comment"># 学籍信息</span></span><br><span class="line">student_info = <span class="string">'http://jxglstu.hfut.edu.cn/eams5-student/for-std/student-info/'</span></span><br><span class="line"></span><br><span class="line">UA = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">         <span class="string">'User-Agent'</span> : UA ,</span><br><span class="line">         <span class="string">'Connection'</span> : <span class="string">'keep-alive'</span> ,</span><br><span class="line">         <span class="string">'Content-Type'</span> : <span class="string">'application/json'</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">request_payload = &#123;</span><br><span class="line">                  <span class="string">'username'</span> : <span class="string">'2019123456'</span>, </span><br><span class="line">                  <span class="string">'password'</span> : <span class="string">''</span>, </span><br><span class="line">                  <span class="string">'captcha'</span> : <span class="string">''</span></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">jwxt_session = requests.session()</span><br><span class="line">salt = jwxt_session.get(url=login_salt, headers=header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算摘要</span></span><br><span class="line">password = salt.text + <span class="string">'-'</span> + <span class="string">'这里填入密码'</span></span><br><span class="line">encryptPassword = hashlib.sha1(password.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">request_payload[<span class="string">'password'</span>] = encryptPassword.hexdigest()</span><br><span class="line"></span><br><span class="line">request_payload = json.dumps(request_payload, separators=(<span class="string">','</span>, <span class="string">':'</span>)).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">jwxt_session.post(login, data=request_payload, headers=header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开学籍信息页，验证是否登录成功</span></span><br><span class="line">r = jwxt_session.get(student_info)</span><br><span class="line">r.text</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'学籍信息.txt'</span>,<span class="string">'w'</span>,encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(r.text)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;今天继续试一试模拟登录学校的新教务系统，新教务系统是由上海树维开发的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思路寻找&quot;&gt;&lt;a href=&quot;#思路寻找&quot; class=&quot;headerlink&quot; title=&quot;思路寻找&quot;&gt;&lt;/a&gt;思路寻找&lt;/h2&gt;&lt;p&gt;和模拟登录信息门户一样，切到开发者模式，登录一次看一看请求过程。&lt;br&gt;login中可以看到网页后台提交了一个Request Payload：&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wangyuyang.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>模拟登录HFUT信息门户</title>
    <link href="http://wangyuyang.me/2019/01/19/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7/"/>
    <id>http://wangyuyang.me/2019/01/19/模拟登录HFUT信息门户/</id>
    <published>2019-01-19T12:11:45.000Z</published>
    <updated>2019-02-16T09:41:48.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚刚开始接触爬虫，尝试用requests库模拟登录HFUT信息门户</p></blockquote><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><p>首先用Chrome的开发者模式来看一看登录过程，切换Tab到Network页，注意勾选<code>Preserve log</code>，保证登录成功跳转页面后记录不会被清除，然后输入账号、密码和验证码开始登录。<br><a id="more"></a><br>可以看到整个登录过程还算是比较清晰的，在点击登录按钮后，浏览器首先会向<code>userPasswordValidate.portal</code>提交一个Form Data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Login.Token1: 2019123456</span><br><span class="line">Login.Token2: 123456</span><br><span class="line">captchaField: abcd</span><br><span class="line">goto: http://my.hfut.edu.cn/loginSuccess.portal</span><br><span class="line">gotoOnFail: http://my.hfut.edu.cn/loginFailure.portal</span><br></pre></td></tr></table></figure></p><p>显然Login.Token1是登录账号，Token2为密码，captchaField为验证码，只需将信息填入dict，再用post命令提交到相应网址即可。</p><p>需要稍微留意的是验证码网址的抓取，讲道理这一步浪费了我不少时间。审查元素可以看到验证码地址：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"captchaImg"</span> <span class="attr">src</span>=<span class="string">"captchaGenerate.portal?s=0.7016079522553234"</span> <span class="attr">width</span>=<span class="string">"52"</span> <span class="attr">height</span>=<span class="string">"25"</span> <span class="attr">align</span>=<span class="string">"absmiddle"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>captchaGenerate.portal?s=</code>后有一个随机的参数，每一次刷新页面可以发现参数都会改变，一开始我猜测，这个参数是服务器根据访问者cookies生成的，因此我最初的思路是用<code>re.findall()</code>函数配合正则表达式从网页源码中爬出来，结果发现信息门户主页面居然是动态加载的，只好另外寻找方法（说白了还是太菜hhh</p><p>在寻找方法的过程，注意到portal-login.js中有这样一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadCaptcha</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cImg.src = <span class="string">"captchaGenerate.portal?s="</span> + <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cImg肯定就是指captchaImg了，然后……他喵的这个小数居然是在本地调用<code>random()</code>函数随机生成的？！那岂不是我随便输一个小数就行了？？？老子还废了半天劲去学Selenium…</p><p>然后试了一下随便输一个0~1之间的小数作为验证码url参数，人肉识别验证码，print一下页面，确实成功登录进了教务系统~</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录认证地址</span></span><br><span class="line">login_url = <span class="string">'http://my.hfut.edu.cn/userPasswordValidate.portal'</span></span><br><span class="line"><span class="comment"># 验证码地址,随便输一个参数</span></span><br><span class="line">captchaImg_url = <span class="string">'http://my.hfut.edu.cn/captchaGenerate.portal?s=0.5105653379102382'</span></span><br><span class="line"><span class="comment"># 信息门户主界面 &amp; 主登录页</span></span><br><span class="line">login1_url = <span class="string">'http://my.hfut.edu.cn/'</span></span><br><span class="line"></span><br><span class="line">UA = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">          <span class="string">'User-Agent'</span>: UA ,</span><br><span class="line">          <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过requests.Session管理cookies，同一个Session实例发出的所有请求都保持同一个cookies</span></span><br><span class="line">jwxt_session = requests.session()</span><br><span class="line">response1 = jwxt_session.get(url=login1_url, headers=headers)</span><br><span class="line">response1.encoding = <span class="string">'utf-8'</span></span><br><span class="line">login1_text = response1.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证码的获取和保存</span></span><br><span class="line">captcha = jwxt_session.get(captchaImg_url)</span><br><span class="line">f = open(<span class="string">'captcha.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="comment"># 将response的二进制内容写入到文件中</span></span><br><span class="line">f.write(captcha.content)</span><br><span class="line"><span class="comment"># 关闭文件流对象</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">form_data = &#123;</span><br><span class="line">             <span class="string">'captchaField'</span>: <span class="string">''</span>, </span><br><span class="line">             <span class="string">'Login.Token1'</span>: <span class="string">'2019123456'</span>, </span><br><span class="line">             <span class="string">'Login.Token2'</span>: <span class="string">'123456'</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人工输入验证码，后期再改为机器识别</span></span><br><span class="line">code = input(<span class="string">'请输入验证码：'</span>)</span><br><span class="line">form_data[<span class="string">'captchaField'</span>] = str(code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交数据</span></span><br><span class="line">s = jwxt_session.post(login_url, data=form_data, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次访问信息门户并写入文件，判断是否成功登录</span></span><br><span class="line">s = jwxt_session.get(login1_url)</span><br><span class="line">s.text</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>,<span class="string">'w'</span>,encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(s.text)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;刚刚开始接触爬虫，尝试用requests库模拟登录HFUT信息门户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;具体思路&quot;&gt;&lt;a href=&quot;#具体思路&quot; class=&quot;headerlink&quot; title=&quot;具体思路&quot;&gt;&lt;/a&gt;具体思路&lt;/h2&gt;&lt;p&gt;首先用Chrome的开发者模式来看一看登录过程，切换Tab到Network页，注意勾选&lt;code&gt;Preserve log&lt;/code&gt;，保证登录成功跳转页面后记录不会被清除，然后输入账号、密码和验证码开始登录。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wangyuyang.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>对Python中class的理解</title>
    <link href="http://wangyuyang.me/2018/06/10/%E5%AF%B9Python%E4%B8%ADclass%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wangyuyang.me/2018/06/10/对Python中class的理解/</id>
    <published>2018-06-10T11:38:48.000Z</published>
    <updated>2019-02-01T04:44:27.158Z</updated>
    
    <content type="html"><![CDATA[<p>初学，浅薄的见解。</p><p>假设有一家宠物店养了十几只狗，为了便于管理，决定把狗的信息录入计算机中。<br>录入信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name: Adam</span><br><span class="line">age: 1</span><br><span class="line">color: white</span><br><span class="line"></span><br><span class="line">name: Barry</span><br><span class="line">age: 3</span><br><span class="line">color: black</span><br><span class="line"></span><br><span class="line">name: Carl</span><br><span class="line">age: 6</span><br><span class="line">color: grey</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在录入信息的开始，你可能并不觉得麻烦。但随着狗的数量增加，你发现你有一半的时间都在重复输入这些东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name:</span><br><span class="line">age:</span><br><span class="line">color:</span><br></pre></td></tr></table></figure><p>你所做的一切无非就是套用这个模板，把每一条狗的<code>name, age, color</code>等属性(properties)的值(如white, black等)输进去而已。既然如此，完全可以先将模板输入计算机。然后在需要时，用一个语句调用模板，然后根据需要为每个属性赋值即可。</p><p>再来重新回顾一下上面这一过程：首先，Adam, Berry, Carl等都是狗这一种生物，即它们都是属于同一类(class)的，我们不妨给这个<code>类</code>一个名字，称之为：<code>Dog</code>。每一只狗，如Adam,Berry都是<code>Dog</code>这一类别下的实际的例子,我们称之为实例。即Adam, Berry, Carl等都是Dog类的实例。</p><p>具体到每一只狗而言，Adam是<code>Dog</code>类所描述的一个对象，Berry也是一个对象，Carl也是。</p><p>概括一下，对象是类的实例，基于类来创建每一个对象的过程被称为实例化。</p><p>在Python中，这样进行描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""先创建一个Dog类"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, color)</span>:</span></span><br><span class="line">        <span class="string">"""定义类具有的属性"""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line"><span class="string">"""根据类创建实例"""</span></span><br><span class="line">first_dog = Dog(<span class="string">'Adam'</span>, <span class="number">1</span>, <span class="string">'white'</span>)</span><br><span class="line">second_dog = Dog(<span class="string">'Berry'</span>, <span class="number">3</span>, <span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><p>你可能会觉得这样做并没有使问题得到简化，下面的语句并没有让录入信息变得更加简单，甚至还麻烦不少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_dog = Dog(<span class="string">'Adam'</span>, <span class="number">1</span>, <span class="string">'white'</span>)</span><br></pre></td></tr></table></figure><p>客观来说，对于宠物店这个例子来说，使用类的概念确实没有简化问题。但对于某些情况则未必，例如，假如某一宠物店的宠物狗都是黑色的，今年全都是两岁，那么我们可以在创建类的时候给予age, color属性一个初始值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""先创建一个Dog类"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""定义类具有的属性"""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="number">2</span>        //初始值为 <span class="number">2</span></span><br><span class="line">        self.color = black  //初始值为 black</span><br><span class="line"></span><br><span class="line"><span class="string">"""根据类创建实例"""</span></span><br><span class="line">first_dog = Dog(<span class="string">'Adam'</span>)</span><br><span class="line">second_dog = Dog(<span class="string">'Berry'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学，浅薄的见解。&lt;/p&gt;
&lt;p&gt;假设有一家宠物店养了十几只狗，为了便于管理，决定把狗的信息录入计算机中。&lt;br&gt;录入信息如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;name: Adam&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;color: white&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name: Barry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;color: black&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name: Carl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;color: grey&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wangyuyang.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="http://wangyuyang.me/2018/05/30/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2018/05/30/Python-学习笔记/</id>
    <published>2018-05-30T05:35:10.000Z</published>
    <updated>2019-05-16T12:04:18.108Z</updated>
    
    <content type="html"><![CDATA[<p>小白，初学。</p><h2 id="Visual-Studio-Code-配置-Python-开发环境"><a href="#Visual-Studio-Code-配置-Python-开发环境" class="headerlink" title="Visual Studio Code 配置 Python 开发环境"></a>Visual Studio Code 配置 Python 开发环境</h2><p>可参考：<br><a href="https://code.visualstudio.com/docs/languages/python" target="_blank" rel="noopener">Python in Visual Studio Code</a><br><a href="https://bespohk.com/blog/configuring-python-visual-studio-code" target="_blank" rel="noopener">Improving your Python workflow with Visual Studio Code</a><br><a id="more"></a> </p><h2 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h2><p>方法<code>__init__</code>中共有四个下划线而不是两个！</p><h2 id="对象、类-class-与实例-instance"><a href="#对象、类-class-与实例-instance" class="headerlink" title="对象、类(class)与实例(instance)"></a>对象、类(class)与实例(instance)</h2><p>对象是类的实例<br>实例是根据类创建出来的一个个具体的对象</p><h2 id="创建一个指定长度的list"><a href="#创建一个指定长度的list" class="headerlink" title="创建一个指定长度的list"></a>创建一个指定长度的list</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="keyword">None</span>] * n</span><br><span class="line"></span><br><span class="line">list2 = list(range(n))</span><br><span class="line"></span><br><span class="line">list3 = [<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中还可以用这种方法：</span></span><br><span class="line"></span><br><span class="line">list4 = range(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3中已废除，range()返回对象已经不再是一个list</span></span><br></pre></td></tr></table></figure><h2 id="让函数返回多个值"><a href="#让函数返回多个值" class="headerlink" title="让函数返回多个值"></a>让函数返回多个值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    .......</span></span><br><span class="line">    return 1, 2, 3</span><br><span class="line"></span><br><span class="line">    a, b, c = function()    </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">    e = function()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">    a = 1</span></span><br><span class="line"><span class="string">    b = 2</span></span><br><span class="line"><span class="string">    c = 3</span></span><br><span class="line"><span class="string">或：</span></span><br><span class="line"><span class="string">    e = (1, 2, 3)</span></span><br><span class="line"><span class="string">注意e为一个tuple，函数在返回多个值时，是先创建一个tuple，然后将其返回</span></span><br><span class="line"><span class="string">有意思的是，我们在return后并没有给元素增加'()'，但依然生成了一个tuple，只不过在接收函数返回值时，既可以直接接收一个tuple，也可以直接接收tuple中每个元素的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="Tuple的“更新”"><a href="#Tuple的“更新”" class="headerlink" title="Tuple的“更新”"></a>Tuple的“更新”</h2><p>从刚开始学习Python时就被灌输了这样一个概念：元组（tuple）是不可变的，即无法直接对tuple进行元素的增加，修改和删除操作。<br>但对tuple进行“更新”从某种意义上来说也是可能的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 现在我希望在'tuple1'这个变量名下的tuple内增加一个数4,可以：</span></span><br><span class="line">tuple1 = tuple1 + [<span class="number">4</span>,]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">print一下就会发现，tuple1已经变成了[1, 2, 3, 4]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">从表面上看，我们确实修改了一个tuple，但实际上，如果我们使用id()来查看一下tuple1的地址，很容易发现tuple1的地址发生了改变，也就是说最初的tuple1和更新后的tuple1仅仅只是名称相同，指向的地址不同，并不是同一个tuple。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="Python-中的-if-name-‘main‘-该如何理解"><a href="#Python-中的-if-name-‘main‘-该如何理解" class="headerlink" title="Python 中的 if name == ‘main‘ 该如何理解"></a>Python 中的 if <strong>name</strong> == ‘<strong>main</strong>‘ 该如何理解</h2><p>参见<a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" target="_blank" rel="noopener">这篇文章</a></p><h2 id="Python-中调用函数时括号的作用"><a href="#Python-中调用函数时括号的作用" class="headerlink" title="Python 中调用函数时括号的作用"></a>Python 中调用函数时括号的作用</h2><p>疑问来源于廖雪峰的Python教程中<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017434209254976" target="_blank" rel="noopener">这篇文章</a></p><blockquote><p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p><blockquote><blockquote><blockquote><p>f = lazy_sum(1, 3, 5, 7, 9)<br>f</p></blockquote></blockquote></blockquote><p>&lt;function lazy_sum.<locals>.sum at 0x101c6ed90&gt;</locals></p><p>调用函数f时，才真正计算求和的结果：</p><blockquote><blockquote><blockquote><p>f()<br>25</p></blockquote></blockquote></blockquote></blockquote><p>查了一下，StackOverflow上有问题<a href="https://stackoverflow.com/questions/46001292/what-is-the-difference-between-calling-function-with-parentheses-and-without-in" target="_blank" rel="noopener">What is the difference between calling function with parentheses and without in python?</a><br>知乎上也有类似问题<a href="https://www.zhihu.com/question/285012402" target="_blank" rel="noopener">python里面方法后面的小括号作用是什么？</a></p><p>大致意思是说，当且仅当在函数名后使用括号时才真正的调用函数。<code>f</code>只是绑定到某一个上函数的名称，或者说，他调用的是整个函数体，是一个函数对象。而<code>f()</code>才是调用函数的值。</p><p>也有说法是，括号为一个函数调用运算符，其的作用是对括号前面的表达式计算出的结果进行一次调用。</p><h2 id="Keras中文文档"><a href="#Keras中文文档" class="headerlink" title="Keras中文文档"></a>Keras中文文档</h2><blockquote><p>Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。</p></blockquote><p>官方文档：<a href="https://keras.io/zh/" target="_blank" rel="noopener">这里</a><br>非官方文档（已停止更新）：<a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">这里</a></p><h2 id="更改PyPi镜像为清华大学镜像"><a href="#更改PyPi镜像为清华大学镜像" class="headerlink" title="更改PyPi镜像为清华大学镜像"></a>更改PyPi镜像为清华大学镜像</h2><p>提升pip下载速度。<br>THU镜像每5分钟同步一次。<br>详见<a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">官网</a></p><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>注意，simple 不能少, 是 https 而不是 http</p><h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><h2 id="Python-编程-从入门到实践-一书的资源"><a href="#Python-编程-从入门到实践-一书的资源" class="headerlink" title="Python 编程 从入门到实践 一书的资源"></a>Python 编程 从入门到实践 一书的资源</h2><p>可以在<a href="https://nostarch.com/pythoncrashcourse" target="_blank" rel="noopener">这里</a>或者<a href="http://www.ituring.com.cn/book/1861" target="_blank" rel="noopener">这里（中文）</a>找到随书资源及错误修正。</p><h2 id="使用-Pygame-创作一个小游戏"><a href="#使用-Pygame-创作一个小游戏" class="headerlink" title="使用 Pygame 创作一个小游戏"></a>使用 Pygame 创作一个小游戏</h2><p>Pygame下载地址及官方文档：<a href="https://www.pygame.org" target="_blank" rel="noopener">戳这里</a></p><h2 id="有用的资料"><a href="#有用的资料" class="headerlink" title="有用的资料"></a>有用的资料</h2><p>廖雪峰的中文教程:<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python教程</a><br>英文官方文档：<a href="https://www.python.org/doc/" target="_blank" rel="noopener">Documentation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小白，初学。&lt;/p&gt;
&lt;h2 id=&quot;Visual-Studio-Code-配置-Python-开发环境&quot;&gt;&lt;a href=&quot;#Visual-Studio-Code-配置-Python-开发环境&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Code 配置 Python 开发环境&quot;&gt;&lt;/a&gt;Visual Studio Code 配置 Python 开发环境&lt;/h2&gt;&lt;p&gt;可参考：&lt;br&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/languages/python&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python in Visual Studio Code&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://bespohk.com/blog/configuring-python-visual-studio-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Improving your Python workflow with Visual Studio Code&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wangyuyang.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C 学习笔记</title>
    <link href="http://wangyuyang.me/2018/05/26/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2018/05/26/C-学习笔记/</id>
    <published>2018-05-26T12:56:16.000Z</published>
    <updated>2019-10-18T08:14:09.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于浮点数不宜使用-或-运算符"><a href="#对于浮点数不宜使用-或-运算符" class="headerlink" title="对于浮点数不宜使用 == 或 != 运算符"></a>对于浮点数不宜使用 == 或 != 运算符</h2><p>写作业时遇到了一个奇怪的bug，精简一下，代码大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">-5</span>;</span><br><span class="line">    </span><br><span class="line">    x = x + <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">-4.9</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>执行如上语句后，发现语句<code>printf(&quot;\n&quot;);</code>并未执行.换句话说，if后表达式的值为false.</p><p>这个结果就有点让人感到困惑了，显然当程序执行完第四行后，x的值应当为1.1，为何表达式<code>x == 1.1</code>的值为0？打开Visual Studio的调试功能才发现问题所在：执行完第四行后x的值并不是-4.900…000，而是-4.900…007，确实不等于-4.9.</p><p>发现问题之后便查了一下资料，才知道这一bug的产生原因：IEEE 754-1985标准中规定浮点数在计算机中以二进制形式储存，因此在转换为十进制时会产生截断误差，也就是说<code>float</code>和<code>double</code>型变量都有精度限制，当使用<code>==</code>或<code>!=</code>进行判断时，必须保证运算符两边的值均为字面量而非计算量，否则大概率会出现问题.</p><p>参考资料 &amp; 扩展阅读：<br> <a href="https://www.zhihu.com/question/21175703" target="_blank" rel="noopener">有没有使用“==”判断浮点数相等与否出现错误的例子？</a><br> <a href="http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html" target="_blank" rel="noopener">代码之谜（五）- 浮点数（谁偷了你的精度？）</a></p><hr><h2 id="关于二维数组的一些问题"><a href="#关于二维数组的一些问题" class="headerlink" title="关于二维数组的一些问题"></a>关于二维数组的一些问题</h2><p>见<a href="https://blog.csdn.net/u012938194/article/details/50526198" target="_blank" rel="noopener">这里</a></p><hr><h2 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a>实参与形参</h2><p>实参数组类型与形参数组类型可以不匹配。</p><hr><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="取反"><a href="#取反" class="headerlink" title="取反 ~"></a>取反 ~</h3><p>对一个二进制数的每一位执行逻辑反操作。使数字1成为0，0成为1。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ 3</span><br><span class="line">    NOT 0011</span><br><span class="line">      = 1100</span><br></pre></td></tr></table></figure><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><p>按位与处理两个长度相同的二进制数，两个相应的二进位都为1，该位的结果值才为1，否则为0。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 &amp; 5</span><br><span class="line">        0011</span><br><span class="line">    AND 0101</span><br><span class="line">      = 0001</span><br><span class="line"></span><br><span class="line">3 &amp; 3</span><br><span class="line">        0011</span><br><span class="line">    AND 0011</span><br><span class="line">      = 0011</span><br></pre></td></tr></table></figure><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><p>按位或处理两个长度相同的二进制数，两个相应的二进位中只要有一个为1，该位的结果值为1。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 | 5</span><br><span class="line">        0011</span><br><span class="line">    OR  0101</span><br><span class="line">      = 0111</span><br></pre></td></tr></table></figure><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h3><p>对等长二进制模式或二进制数的每一位执行逻辑异或操作。操作的结果是如果某位不同则该位为1，否则该位为0。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 ^ 5</span><br><span class="line">        0011</span><br><span class="line">    XOR 0101</span><br><span class="line">      = 0110</span><br></pre></td></tr></table></figure><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><p>移位后空缺的部分全部填0。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&lt; 3</span><br><span class="line">        0001</span><br><span class="line">    &lt;&lt;     3</span><br><span class="line">      = 1000</span><br></pre></td></tr></table></figure><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h3><p>右移运算的行为其实是很微妙的，由于C标准未对该运算做明确定义，因而该运算有可能产生两种不同的运算结果，具体产生哪一种结果与编译器的实现有关。</p><p>两种结果的产生实际上是因为存在两种不同的右移方式：</p><ul><li>逻辑右移</li><li>算术右移</li></ul><p>逻辑右移非常简单，和左移一样，空缺部分直接补0。</p><p>而算术左移是有符号类型引出的概念。移位后左边空缺的部分，正数左补0，负数左补1，右边丢弃。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15 &gt;&gt; 3</span><br><span class="line">        1111</span><br><span class="line">    &gt;&gt;     3</span><br><span class="line">      = 0001</span><br></pre></td></tr></table></figure><p>Java对这一问题的处理就比较明确，Java中规定<code>&gt;&gt;</code>为算术右移，<code>&gt;&gt;&gt;</code>为逻辑右移。</p><hr><h2 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h2><p>复合赋值运算符（compound assignment operators）过去很少见到，不过其实用起来也很简单，主要有以下几种：</p><table><thead><tr><th>Operator name</th><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td>Addition assignment</td><td>a += b</td><td>a = a + b</td></tr><tr><td>Subtraction assignment</td><td>a -= b</td><td>a = a - b</td></tr><tr><td>Multiplication assignment</td><td>a *= b</td><td>a = a * b</td></tr><tr><td>Division assignment</td><td>a /= b</td><td>a = a / b</td></tr><tr><td>Modulo assignment</td><td>a %= b</td><td>a = a % b</td></tr><tr><td>Bitwise AND assignment</td><td>a &amp;= b</td><td>a = a &amp; b</td></tr><tr><td>Bitwise OR assignment</td><td>a or= b</td><td>a = a or b</td></tr><tr><td>Bitwise XOR assignment</td><td>a ^= b</td><td>a = a ^ b</td></tr><tr><td>Bitwise left shift assignment</td><td>a &lt;&lt;= b</td><td>a = a &lt;&lt; b</td></tr><tr><td>Bitwise right shift assignment</td><td>a &gt;&gt;= b</td><td>a = a &gt;&gt; b</td></tr></tbody></table><p><em>因无法在表格中使用” | “，故用” or “替代</em><br><em>摘自<a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Compound_assignment_operators" target="_blank" rel="noopener">Operators in C and C++ - Compound assignment operators</a></em></p><p>需要注意的是，表格第二列和第三列并不完全等价，有说法称第二列的执行效率更高。个人觉得如果编译器优化比较好的话应该还是没有区别。</p><p>另外运算中还存在变量的数据类型问题，暂未深入研究。</p><hr><h2 id="存储类别、链接和内存管理"><a href="#存储类别、链接和内存管理" class="headerlink" title="存储类别、链接和内存管理"></a>存储类别、链接和内存管理</h2><p><del>帮同学查bug结果发现静态变量这一块理解不深，好好学习一下相关知识</del><br>两个基本概念：</p><ul><li>对象（object）：不同于OOP中对象的概念，这里对象指的是某一块内存，这一块内存中可以存储一个或多个值，也可能并没有存储任何值。</li><li>标识符（identifier）：一个名称，或者说一个代号，用来指定特定对象的内容。用现实生活作为例子，“Albert Einstein”就是一个名称，指的是德国的那一位物理学者。在C语言中，变量名（当然也包括指针变量名）就是一个标识符。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><em>scope 作用域</em></p><p>正如过去学到的知识，每一个变量都有一个作用范围。在一个函数中声明的变量，并不能直接在另一个函数中调用。作用域就是描述程序中可访问标识符的区域。作用域主要可以分为以下四个：</p><ul><li>块作用域（block scope）</li><li>函数作用域(function scope)</li><li>函数原型作用域(function prototype scope)</li><li>文件作用域(file scope)</li></ul><p>块作用域的概念最为熟悉，块内的变量的作用域从变量被定义的位置开始，到块的末尾位置结束。需要注意的就是C99将块的概念进行了延伸。在C99中，块并不仅仅局限为一对花括号<code>{ }</code>所包含的范围，for循环、（do）while循环、if语句都是一个块，如下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j++; j&lt;<span class="number">10</span>);</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序在编译时会报错，原因是for循环中声明的变量j，其作用域并不包括第四行的<code>j++;</code>。虽然它们都在同一个花括号内，但实际上是两个不同的块。</p><p>再考虑另外两个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问的，对于第二个程序，编译器会提示最后一行的j未定义。但是第一个程序执行后i的值是多少呢？调试模式下很容易看出最后结果为i = 7。显然，while语句测试条件中使用的是最外层函数的i，而循环体中使用的变量j与外层无关。</p><p>在 <em>C Primer Plus</em> 一书中，函数作用域的解释很绕，原文是这么说的：</p><blockquote><p>函数作用域（function scope）仅用于goto语句的标签。这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。</p></blockquote><p>不知道是不是翻译的问题，至少我前几次看的莫名其妙，后来自己写程序试了一下才大概知道是什么意思,考虑下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">goto</span> a;</span><br><span class="line">a: i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到，在块作用域里，变量的作用域从变量<strong>被定义的位置开始</strong>，到块的末尾位置结束。但在这个程序中，a标签明明在goto语句的后面（第五行）才被定义，goto语句却在a标签定义之前（第四行）就调用了a标签。</p><p>按照书上的解释，对于goto语句的标签而言，一旦标签出现在某一个函数中，那么就可以在这个函数中的任意位置调用标签。用原文的话来讲就是“标签的作用域延伸至整个函数”。这就是所谓“函数作用域”。</p><p>函数原型作用域和块作用域一样也很好理解，其范围是从形参定义处到原型声明结束。也就是说，在函数名后面的括号里声明的形参，在整个函数体内都有效。</p><p>至于最后一种作用域——文件作用域，根据链接属性又可以分为两种：</p><ul><li>外部链接的文件作用域</li><li>内部链接的文件作用域</li></ul><p>具体区别在下一部分分析。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><em>linkage 链接</em></p><p><em>C Primer Plus</em> 中并未对链接一词做明确定义，不过理解起来还算简单。书中C变量的链接属性主要分为三种：</p><ul><li>外部链接</li><li>内部链接</li><li>无链接</li></ul><p>具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。</p><p>具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元（源代码及其包含的所有头文件）中使用。</p><p>有存储类别说明符static修饰的文件作用域变量为外部链接变量，反之为内部链接变量。</p><p>总结：外部链接变量可以在多文件程序中使用，无链接和内部链接变量则与之相反。内部链接和外部链接的区别只在程序由多个翻译单元组成时体现。</p><h3 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h3><p><em>storage duration 存储期</em></p><p>程序运行时必然会产生各种数据（如一些变量），这些数据在程序运行时会被写入到内存当中。显然，被写入到内存中的数据并不可能一直在内存中存放，当程序不需要某些数据时，这些数据就会被丢弃。这就牵扯到了对象的生存期（生命期，存储期）。C对象有4种存储期：</p><ul><li>静态存储期</li><li>线程存储期</li><li>自动存储期</li><li>动态分配存储期</li></ul><p>重点学习静态存储器，自动存储期和动态分配存储期。</p><p>具有静态存储期的对象，会在程序执行期间一直存在。</p><p>块作用域的变量通常具有自动存储期，程序进入块内会自动为这些变量分配内存；退出块后则会前释放面分配的内存。</p><p>如果想要让块作用域变量也具有静态存储期，在块中声明变量前加上关键字static即可。这种具有块作用域的变量也叫“局部静态变量”。</p><p>所有的文件作用域变量，无论是否为外部链接，都具有静态存储期。</p><p>至于所谓的动态分配存储期，无非就是指<code>malloc()</code>等函数申请的内存块，只要<code>free()</code>函数没有将它们释放，就会一直保存下去，由程序员决定生存期的长短。</p><h3 id="变量的存储类别"><a href="#变量的存储类别" class="headerlink" title="变量的存储类别"></a>变量的存储类别</h3><p><em>storge class 存储类别</em></p><p>5种常见的存储类别：</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内，使用关键字 register</td></tr><tr><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外，使用关键字 static</td></tr><tr><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内，使用关键字 static</td></tr></tbody></table><p>寄存器变量不常用，暂时忽略，看剩下的4种类别，考虑下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;                <span class="comment">// 文件作用域，外部变量，外部链接变量，静态外部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;         <span class="comment">// 文件作用域，外部变量，内部链接变量，静态内部链接</span></span><br><span class="line">                      <span class="comment">// 内部链接的内部指的是链接属性，与外部变量一词并不冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;            <span class="comment">// 块作用域，无链接变量，自动</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;     <span class="comment">// 块作用域，无链接变量，静态无链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>声明在所有函数外部的变量一定具有文件作用域</li><li>具有文件作用域的变量自动具有静态存储期</li><li>声明在块内的变量具有块作用域</li><li>具有块作用域的变量一定为无链接变量，默认为自动存储期（除非使用static关键字）</li><li>静态变量（外部变量即使没有static关键字修饰依然是静态变量！）如果未被显式初始化，则会被自动初始化为0</li><li>静态变量只能使用常量表达式初始化</li></ul><p>自动、静态无链接、静态内部链接都比较简单，静态外部链接相对要复杂一些。</p><p>书上提到了外部变量的一些合法情况，这里记几种不合法的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述程序在编译时会报错：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">严重性       代码         说明</span></span><br><span class="line"><span class="comment">错误         LNK2001      无法解析的外部符号 "int j" (?j@@3HA)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">显然，外部变量必须在函数外部被声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类似上一种情况，第一行报错：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">严重性       代码         说明</span></span><br><span class="line"><span class="comment">错误         LNK2001      无法解析的外部符号 "int j" (?j@@3HA)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果在函数外使用了extern关键字，则j变量必须被定义在另一个文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：看到后面就知道书上实际上提到了这种情况，使用关键字extern的声明称为引用式声明，不可用其创建外部定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种情况也是不允许的，书上后面一点的内容其实提到了类似的情况，外部变量只能初始化一次。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">严重性       代码         说明</span></span><br><span class="line"><span class="comment">错误(活动)   E2442        不允许对外部变量的局部声明使用初始值设定项</span></span><br><span class="line"><span class="comment">错误         C2205        “j”: 不能对带有块范围的外部变量进行初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">声明外部变量时可以进行初始化，但是禁止在函数外部对外部变量赋值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">严重性       代码         说明</span></span><br><span class="line"><span class="comment">错误(活动)    E0077       此声明没有存储类或类型说明符</span></span><br><span class="line"><span class="comment">错误         C2086        “int j”: 重定义</span></span><br><span class="line"><span class="comment">错误         C4430        缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以改成 int j = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="函数的存储类别"><a href="#函数的存储类别" class="headerlink" title="函数的存储类别"></a>函数的存储类别</h3><p>函数的存储类别有三种：</p><ul><li>外部函数（默认）</li><li>静态函数</li><li>内联函数（C99新增）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alpha</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">// 外部函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beta</span><span class="params">(<span class="keyword">void</span>)</span></span>;       <span class="comment">// 静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">delta</span><span class="params">(<span class="keyword">void</span>)</span></span>;      <span class="comment">// 定义在其他文件中的外部函数</span></span><br></pre></td></tr></table></figure><p>外部函数可以被其他文件中的函数访问。</p><p>静态函数只能被本文件中的函数访问。</p><p>内联函数暂时略过。</p><h3 id="malloc-calloc-和realloc"><a href="#malloc-calloc-和realloc" class="headerlink" title="malloc( ), calloc( )和realloc( )"></a>malloc( ), calloc( )和realloc( )</h3><p>这三种函数都可以用于分配内存，用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc: memory allocation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototype: </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">( <span class="keyword">size_t</span> size )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">// ptr = (cast-type*) malloc(size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example: </span></span><br><span class="line">ptr = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// calloc: contiguous allocation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototype: </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">calloc</span><span class="params">( <span class="keyword">size_t</span> num, <span class="keyword">size_t</span> size )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">// ptr = (cast-type*)calloc(num, size);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">ptr = (<span class="keyword">float</span>*) <span class="built_in">calloc</span>(<span class="number">25</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// recalloc: re-allocation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototype: </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">// ptr = realloc(ptr, newSize);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">ptr = <span class="built_in">realloc</span>(ptr, <span class="number">101</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p><code>malloc()</code>函数会在内存中申请一块长度为size的连续区域，并返回一个void类型（可使用类型转换，将其转换为其他类型）的指针，指向该区域的首地址。</p><p><code>malloc()</code>不会对已分配的区域进行初始化，如果尝试读取块中的内容会获得垃圾值。</p><p><code>calloc()</code>函数有两个参数：</p><ul><li>要分配内存块的数量num</li><li>要分配每个内存块的大小size</li></ul><p>该函数会在内存中申请n块长度为size的连续区域，并返回一个void类型（可使用类型转换，将其转换为其他类型）的指针，指向该区域的首地址。</p><p><code>callnoc()</code>会在分配内存的同时对其进行初始化，将块中区域全部写为0，试了一下执行起来速度明显慢很多。</p><p><code>realloc()</code>函数可以重新分配内存块，如果使用<code>malloc()</code>和<code>callnoc()</code>分配块的大小不足/过剩，可以用该函数重新分配内存。</p><p><code>free()</code>函数可以释放内存。写了一个程序测试一下，不及时使用<code>free()</code>释放内存，轻轻松松就能把内存占满。</p><p>注：在测试内存泄漏时，发现VS创建的程序最多只占用2GB内存，恰好是32位系统最大支持内存的一半。查了一下，2GB是32位模式下程序所能占用内存的上限，剩余的2GB内存是给操作系统预留的。如果想要使用更多的内存也很容易，把配置管理器中的目标平台改成x64（默认Win32）即可尽情的使用<del>浪费</del>多余的内存了。</p><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构（struct）是一种数据类型，借助于结构变量能够更加清晰地表示一些相互关联的变量。</p><h3 id="创建结构"><a href="#创建结构" class="headerlink" title="创建结构"></a>创建结构</h3><p>和使用其他类型的变量（如int，float等）稍有区别，使用结构前首先要建立一个结构声明（struct declaration），结构声明描述了该结构的结构<del>hhhh绕口令一样</del>，或者说，结构声明是一个模板，描绘出了一个结构的框架。一个结构声明的例子如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> studentid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下C语言的基本数据类型，以int类型为例，创建并使用int类型变量需要以下两个步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> yakumo_yukari_age;       <span class="comment">// 声明int变量，这里会为变量创建一个实际的内存空间</span></span><br><span class="line">yakumo_yukari_age = <span class="number">17</span>;      <span class="comment">// 为变量赋值</span></span><br></pre></td></tr></table></figure><p>而在建立结构声明的时候，实际上并未真正的创建一个变量，并给该变量分配空间。这里实际上只是建立了一个结构的模板。如果想要创建结构变量，还需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">tom</span>;</span>          <span class="comment">// 创建一个名为 tom 的结构变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">jerry</span>;</span>        <span class="comment">// 再创建一个名为 jerry 的结构变量</span></span><br></pre></td></tr></table></figure><p>这里创建的两个结构变量都具有相同的结构，即都遵循模板<code>student</code>包含一个名为<code>age</code>、一个<code>studentid</code>的int类型变量。</p><p><code>struct student</code>二者合在一起才类似于<code>int</code>的作用，如下面两个语句都真正创建了两个变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">yakumo_yukari</span>;</span></span><br><span class="line"><span class="keyword">int</span> yakumo_yukari_age;</span><br></pre></td></tr></table></figure><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><p>很简单，按顺序赋值就行了，用逗号隔开，最后一个元素后不要加逗号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">jerry</span> = &#123;</span></span><br><span class="line">    <span class="number">20</span>,</span><br><span class="line">    <span class="number">2019000001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者也可以不按顺序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studet</span> <span class="title">jerry</span> = &#123;</span></span><br><span class="line">    .studentid = <span class="number">2019000001</span></span><br><span class="line">    .age = <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>甚至可以只初始化特定的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studet</span> <span class="title">jerry</span> = &#123;</span></span><br><span class="line">    .studentid = <span class="number">2019000001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构变量同样遵循前面提到的五种存储类别（自动、静态无链接……）。</p><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>类似OOP中的class，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, jerry.age);</span><br></pre></td></tr></table></figure><hr><h2 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h2><p><del>是时候系统的补一补这一部分的知识了</del></p><p>预处理指令：</p><ul><li>#define</li><li>#undef</li><li>#include</li><li>#ifdef</li><li>#else</li><li>#endif</li><li>#ifndef</li><li>#if</li><li>#elif</li><li>#line</li><li>#error</li><li>#pragma</li></ul><p>相对于存储类别等概念，预处理指令还是很容易理解的，不废话了，忘了再翻书看看就行。</p><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote><p>一个变量的值就是分配给这个变量的内存位置所存储的数值。</p></blockquote><p>下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br></pre></td></tr></table></figure><p>和这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line"></span><br><span class="line">b = &amp;a;</span><br></pre></td></tr></table></figure><p>是等价的（运算顺序），不要将第一个程序错误的理解为下面这种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line">*b = &amp;a;                     <span class="comment">// 是错误的！实际上根本无法通过编译————不能把整型量存储在指针变量中</span></span><br></pre></td></tr></table></figure><p>回顾大一学习指针时，犯下了许多在现在看来很可笑的错误，例如下面的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *&amp;a = <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>这是<em>Pointers on C</em>一书中提到的一个例子，第一次看时竟然将该语句理解为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *(&amp;a = <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这种理解方式不仅从逻辑上讲不通，压根就是对C语言的运算顺序有着十分可笑的误解，应当理解为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (* (&amp;a) ) = <span class="number">25</span>;          <span class="comment">// 等号的优先级最低</span></span><br></pre></td></tr></table></figure><p>所以a的值就是25。</p><h3 id="指针的大小"><a href="#指针的大小" class="headerlink" title="指针的大小"></a>指针的大小</h3><p>通过<code>sizeof()</code>函数可以很轻松的获知指针的大小，查阅了相关资料，指针的大小与CPU架构、操作系统以及编译器有关。</p><p>下摘自<a href="https://www.quora.com/What-is-the-size-of-a-pointer-in-C" target="_blank" rel="noopener">What is the size of a pointer in C?</a>里Kurt Guntheroth的回答：</p><blockquote><p>A pointer is the size of an address on the machine for which the C program is being compiled.</p><p>On the Z80 microprocessor, popular in the 1980s, a pointer is 16 bits.<br>On the original 8086, a pointer might be 16, 20, or 32 bits, even though the address space was only 20 bits wide. You had to give the C compiler a command line argument that said how wide a pointer should be. It was a nightmare. Look up “memory model” on wikipedia for a long and horrifying introduction.<br>On the 68000 microprocessor, pointers were 32-bits.<br>On the x86 model used for Intel processors up until about 5 years ago, and still usable, a pointer was 32 bits, allowing it to address about 4 GB. This limitation lead to creation of 64 bit addresses.<br>On the x64 model used for Intel processors of the last few generations, a pointer is 64 bits.</p><p>You cannot assume that a pointer is the same size as an int, or the same size as a long. The integer constant 0 can be converted to a pointer, but other integer constants may not be convertible. When you convert 0 to a pointer, there is no guarantee that the bits contained in the pointer will all be zeros, though this is typical. It could be anything at all. 0 is converted to a pointer that points to no valid address. You can add an integer to a pointer, yielding a pointer, or subtract an integer from a pointer, yielding a pointer. Anything else has undefined effect.</p></blockquote><p>VS里使用<code>sizeof()</code>测试了一下，数据指针的大小确实都是四字节（解决方案平台Win32），需要注意的函数指针和数据指针大小未必相同，参见<a href="https://www.zhihu.com/question/19691905/answer/15696437" target="_blank" rel="noopener">C 语言中不同类型指针的大小是否完全相同，为什么？ - 徐辰的回答</a>。</p><h3 id="warning-C6011-dereferencing-NULL-pointer"><a href="#warning-C6011-dereferencing-NULL-pointer" class="headerlink" title="warning C6011: dereferencing NULL pointer "></a>warning C6011: dereferencing NULL pointer <name></name></h3><p>VS里使用结构体指针时遇到了一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C6011: dereferencing NULL pointer &lt;name&gt;</span><br></pre></td></tr></table></figure><p>查了一下官方文档，<a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/c6011?view=vs-2019" target="_blank" rel="noopener">C6011</a>中解释了产生这一现象的原因：</p><blockquote><p>……<br>The following code generates this warning because a call to malloc might return null if there is insufficient memory available:<br>……</p></blockquote><p>就是说如果内存不足，<code>malloc()</code>函数有可能会分配内存失败，返回一个<code>NULL</code>，因此在对<code>malloc()</code>返回的指针进行操作之前，首先应当检查该指针是否为空，如果该指针不为空，才可以对其进行下一步操作。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对于浮点数不宜使用-或-运算符&quot;&gt;&lt;a href=&quot;#对于浮点数不宜使用-或-运算符&quot; class=&quot;headerlink&quot; title=&quot;对于浮点数不宜使用 == 或 != 运算符&quot;&gt;&lt;/a&gt;对于浮点数不宜使用 == 或 != 运算符&lt;/h2&gt;&lt;p&gt;写作业时遇到了一个奇怪的bug，精简一下，代码大致如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;-5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = x + &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(x == &lt;span class=&quot;number&quot;&gt;-4.9&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用PN532模块复制门禁卡</title>
    <link href="http://wangyuyang.me/2018/04/06/%E5%88%A9%E7%94%A8PN532%E6%A8%A1%E5%9D%97%E5%A4%8D%E5%88%B6%E9%97%A8%E7%A6%81%E5%8D%A1/"/>
    <id>http://wangyuyang.me/2018/04/06/利用PN532模块复制门禁卡/</id>
    <published>2018-04-06T13:18:49.000Z</published>
    <updated>2018-04-07T23:52:50.857Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;小区又双叒叕升级门禁系统，每户只给免费发两张门禁卡.额外购卡的话，每张卡居然收10元RMB.成本几毛钱的东西收这个价感觉略坑，查了一下资料决定自己动手复制一张卡.<del> 实际上最后算下来，钱花的更多了23333. </del></p><p>&emsp;&emsp;先了解一下非接触式智能卡（Contactless smart card）的基本知识：由ISO/IEC JTC 1颁布的ISO/ICE 14443协议定义了两种非接触卡（A型和B型）的技术标准，具体的技术细节不再赘述.概括一下过程就是非接触卡（PICC）接受由非接触读写器（PCD）传输的数据和能量，同时对数据进行解码和处理，然后PICC再将处理过的数据反馈给PCD.</p><p>&emsp;&emsp;基于ISO/IEC 14443标准中对Type A 13.56 MHz型智能卡的规定，1994年，NXP公司推出了MIFARE（名称源于MIkron FARE Collection System）系列智能卡的第一款产品： MIFARE Classic 1K（简称M1卡）. MIFARE Classic 1K 是目前最常见的一种非接触卡，每张卡具有一个独一无二且不可修改的UID编号，绝大多数门禁卡、学生卡、水卡等都是这种卡.这种卡也是被将要我复制的卡.<br><a id="more"></a><br>&emsp;&emsp;MIFARE系列还有其他产品，如MIFARE Ultralight,MIFARE Plus和MIFARE DESFire.这四类卡又有其他不同的分支，这里亦不在谈，<a href="https://en.wikipedia.org/wiki/MIFARE" target="_blank" rel="noopener">戳这里</a>可以进一步了解MIFARE卡的历史和种类.不过值得一提的是，MIFARE Ultralight和MIFARE DESFire被用于我国部分城市的交通卡中，任何尝试修改、复制交通卡内数据的行为都是触犯我国法律的。</p><p>&emsp;&emsp;2007年12月，MIFARE Classic被证实存在设计缺陷，可以被多种方式破解，正是这一原因使得我们可以在没有Key A,B的情况下完成卡的复制。</p><blockquote><p>这里描述的是复制非全加密的M1卡.全加密的M1卡需要使用Proxmark 3进行嗅探，成本较高，大概需要300+RMB，这里不做讨论（有说法称PN532亦可破解全加密卡，具体情况不详）.</p></blockquote><p>&emsp;&emsp;复制所需的工具：<br>&emsp;&emsp;&emsp;&emsp;PN532模块<br>&emsp;&emsp;&emsp;&emsp;PL2303 USB to Serial<br>&emsp;&emsp;&emsp;&emsp;CUID卡一张<br>&emsp;&emsp;成本大概30￥，其中一张CUID卡的价格大概在1￥左右.</p><blockquote><p>PN532可用ACR112U代替，但ACR112U价格较高(100+RMB).<br> CUID卡是UID卡（Chinese Magic Card,可修改一次UID编号）的变种，出厂时空白，可以重复、随意擦写卡中数据（包括0扇区的UID编号）.</p></blockquote><p>&emsp;&emsp;工具凑齐后需要将PL2303和PN532模块连接起来，连接时要注意线序：<br> PN532*&nbsp;&nbsp;&nbsp;&nbsp;PL2303<br>  GND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GND<br>  VCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5V<br>  TXD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RXD<br>  RXD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TXD</p><blockquote><p>*背面印刷有引脚说明，若不慎将GND和VCC反接会导致模块烧毁.</p></blockquote><p>&emsp;&emsp;连接完成后，将PL2303插入电脑，安装相应的驱动后即可利用上位机读取卡片中的信息，将读取的数据导出为”.dump”文件，再写入CUID卡中即可完成复制.拿到门禁上一试，成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;小区又双叒叕升级门禁系统，每户只给免费发两张门禁卡.额外购卡的话，每张卡居然收10元RMB.成本几毛钱的东西收这个价感觉略坑，查了一下资料决定自己动手复制一张卡.&lt;del&gt; 实际上最后算下来，钱花的更多了23333. &lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;先了解一下非接触式智能卡（Contactless smart card）的基本知识：由ISO/IEC JTC 1颁布的ISO/ICE 14443协议定义了两种非接触卡（A型和B型）的技术标准，具体的技术细节不再赘述.概括一下过程就是非接触卡（PICC）接受由非接触读写器（PCD）传输的数据和能量，同时对数据进行解码和处理，然后PICC再将处理过的数据反馈给PCD.&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;基于ISO/IEC 14443标准中对Type A 13.56 MHz型智能卡的规定，1994年，NXP公司推出了MIFARE（名称源于MIkron FARE Collection System）系列智能卡的第一款产品： MIFARE Classic 1K（简称M1卡）. MIFARE Classic 1K 是目前最常见的一种非接触卡，每张卡具有一个独一无二且不可修改的UID编号，绝大多数门禁卡、学生卡、水卡等都是这种卡.这种卡也是被将要我复制的卡.&lt;br&gt;
    
    </summary>
    
    
      <category term="RFID" scheme="http://wangyuyang.me/tags/RFID/"/>
    
  </entry>
  
  <entry>
    <title>对基于HEXO的NexT主题的美化</title>
    <link href="http://wangyuyang.me/2018/04/06/%E5%AF%B9%E5%9F%BA%E4%BA%8EHEXO%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E7%9A%84%E7%BE%8E%E5%8C%96/"/>
    <id>http://wangyuyang.me/2018/04/06/对基于HEXO的NexT主题的美化/</id>
    <published>2018-04-06T09:12:38.000Z</published>
    <updated>2018-06-05T02:33:52.115Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目录</span><br><span class="line">1.给博客增加一个萌萌哒看板娘</span><br><span class="line">2.修改页脚处，年份与姓名间的图标</span><br><span class="line">3.增加访客统计功能</span><br><span class="line">4.Back-to-top 按钮显示百分比</span><br><span class="line">5.如何设置「阅读全文」？</span><br><span class="line">6.将文章底部标签前的&quot;#&quot;替换为标签图标</span><br><span class="line">7.修改字体及字体大小</span><br><span class="line">8.在Markdown中写注释</span><br></pre></td></tr></table></figure><p>刚开始接触HEXO，这几天在一些大佬的博客和官方文档里学到了不少个性化设置。故记录于此，以备以后查阅。<br><blockquote><p>Tip：如果发现修改后页面部分内容未正常显示，先试试<code>$ hexo clean</code>,再进行生成和部署</p></blockquote></p><hr><h2 id="给博客增加一个萌萌哒看板娘"><a href="#给博客增加一个萌萌哒看板娘" class="headerlink" title="给博客增加一个萌萌哒看板娘"></a>给博客增加一个萌萌哒看板娘</h2><blockquote><p>*经测试该插件在IE及Microsoft Edge上会引起不同程度的卡顿，建议使用Chrome浏览</p></blockquote><p>Github项目地址：<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">戳这里</a></p><p>在根目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></p><p>然后<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">在这里</a>可以看到一些已有的模型，记下想要的模型名字,使用安装命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install <span class="string">"模型的包名"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>模型的包名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure></p><p>以koharu为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure></p><p>安装完成后，还需要在一些小小的修改<br>在<code>_config.yml</code>（HEXO或主题的<code>_config.yml</code>皆可）中，加入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">     enable: true</span><br><span class="line">     scriptFrom: local</span><br><span class="line">     pluginRootPath: live2dw/</span><br><span class="line">     pluginJsPath: lib/</span><br><span class="line">     pluginModelPath: assets/</span><br><span class="line">     model:</span><br><span class="line">       use: live2d-widget-model-koharu</span><br><span class="line">     display:</span><br><span class="line">       position: right</span><br><span class="line">       width: 150</span><br><span class="line">       height: 300</span><br><span class="line">     mobile:</span><br><span class="line">       show: true</span><br></pre></td></tr></table></figure></p><p>根据需要可修改<code>use:</code>后的包名；调整长度和宽度；选择是否停用插件等。</p><hr><h2 id="修改页脚处，年份与姓名间的图标"><a href="#修改页脚处，年份与姓名间的图标" class="headerlink" title="修改页脚处，年份与姓名间的图标"></a>修改页脚处，年份与姓名间的图标</h2><p>NexT主题默认图标为一个人像（user），可以将其改为心形图案。</p><p>先打开文件 <code>~/blog/themes/next/_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">icon:</span><br><span class="line">    # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons</span><br><span class="line">    # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">    name: user</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot;</span><br></pre></td></tr></table></figure></p><p>将第4行中的user替换为heart，注意不要删去分号后的空格。</p><p>然后打开文件 <code>~/blog/themes/next/layout/_partials</code></p><p>找到<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"with-love"</span> id=<span class="string">"animation"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>修改为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"with-love"</span> id=<span class="string">"heart"</span>&gt;</span><br></pre></td></tr></table></figure></p><hr><h2 id="增加访客统计功能"><a href="#增加访客统计功能" class="headerlink" title="增加访客统计功能"></a>增加访客统计功能</h2><blockquote><p>在用这种方法添加访客统计功能之后，才发现NexT已经已经内置了该脚本Orz<br>  <del>再去删改是不可能的，这辈子都不可能再改的，毕竟太懒</del><br>  方法附在后面。</p></blockquote><p><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">戳这里</a>进入作者的网站。</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>打开<code>~/blog/themes/next/layout/_partials/footer.swig</code></p><p>在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"copyright"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>前插入一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>然后滚动到文件最后（或者其他合适的地方），插入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"busuanzi-count"</span>&gt;</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-user-md"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    您是第<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>位客人呢| ω・´)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>如果不想要提示前的图标，直接删去<code>&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;</code>即可。</p><p>在这里有两种不同的统计方式：</p><p>pv的方式，按点击数来记录，即单个用户连续点击n篇文章，记录n次访问量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span><br><span class="line">    本站总访问量&lt;span id=<span class="string">"busuanzi_value_site_pv"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure></p><p>uv的方式，按用户数记录，即单个用户连续点击n篇文章，只记为1次访问量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><br><span class="line">    本站总访问量&lt;span id=<span class="string">"busuanzi_value_site_uv"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure></p><p>该部分参考了<a href="https://segmentfault.com/a/1190000009544924#articleHeader12" target="_blank" rel="noopener">这篇文章</a>的第十三条。</p><h3 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h3><p>只需要在主题配置文件<code>_config.yml</code>中找到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Show Views/Visitors of the website/page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: false</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p><p>按需修改即可。</p><hr><h2 id="Back-to-top-按钮显示百分比"><a href="#Back-to-top-按钮显示百分比" class="headerlink" title="Back-to-top 按钮显示百分比"></a>Back-to-top 按钮显示百分比</h2><p>打开文件 <code>~/blog/themes/next/_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: false</span><br></pre></td></tr></table></figure></p><p>将<code>scrollpercen:</code>的值改为<code>true</code>即可。</p><hr><h2 id="如何设置「阅读全文」？"><a href="#如何设置「阅读全文」？" class="headerlink" title="如何设置「阅读全文」？"></a>如何设置「阅读全文」？</h2><p>在首页显示全文无疑是严重影响阅读体验的，只显示文章部分内容，再由读者决定是否跳转是一种常见的需求。根据官方文档，有三种方法来达成这一目的，这里只记录一种方法：<br>手动在文章中合适位置添加<code>&lt;!-- more --&gt;</code>进行截断。<br>其他方法可以<a href="https://theme-next.iissnan.com/faqs.html" target="_blank" rel="noopener">戳这里</a></p><hr><h2 id="将文章底部标签前的”-”替换为标签图标"><a href="#将文章底部标签前的”-”替换为标签图标" class="headerlink" title="将文章底部标签前的”#”替换为标签图标"></a>将文章底部标签前的”#”替换为标签图标</h2><p>打开文件<code>~/blog/themes/next/layout/_macro/post.swig</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-footer"</span>&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-tags"</span>&gt;</span><br><span class="line">          &#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> post.tags %&#125;</span><br><span class="line">            &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">          &#123;% endfor %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p><p>将第五行<code>rel=&quot;tag&quot;&gt;#</code>中的<code>#</code>替换为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>即可。</p><hr><h2 id="修改字体及字体大小"><a href="#修改字体及字体大小" class="headerlink" title="修改字体及字体大小"></a>修改字体及字体大小</h2><h3 id="第一种方法-修改主题配置文件"><a href="#第一种方法-修改主题配置文件" class="headerlink" title="第一种方法 修改主题配置文件"></a>第一种方法 修改主题配置文件</h3><p>打开文件 <code>~/blog/themes/next/_config.yml</code><br>找到 <code>Font Settings</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line">font:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).---字体库外链地址</span></span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.---控制是否使用外链字体库，'true'表明使用</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.---指font-family属性？</span></span><br><span class="line">  <span class="comment"># `size: xx`. Use `px` as unit.---使用'px'作为单位，默认全局14px，我改为16px</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements in &lt;body&gt;.---全局字体</span></span><br><span class="line">  global:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Lato</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Headlines (H1, H2, H3, H4, H5, H6).---标题字体</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.---应当指的是用全局字体作为备用字体。参见知乎问题：字体话题中说的 fallback 具体是什么意思？ https://www.zhihu.com/question/21847989/answer/22547275</span></span><br><span class="line">  headings:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.---文章字体</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  posts:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Logo.---Logo字体</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  logo:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.---代码块及&lt;code&gt;字体</span></span><br><span class="line">  codes:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line">    size:</span><br></pre></td></tr></table></figure></p><h3 id="第二种方法-直接修改CSS文件中源码"><a href="#第二种方法-直接修改CSS文件中源码" class="headerlink" title="第二种方法 直接修改CSS文件中源码"></a>第二种方法 直接修改CSS文件中源码</h3><p>打开文件 <code>~blog/themes/next/source/css/_variables/base.styl</code><br>找到<code>Font size</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Font size</span><br><span class="line">$font-size-base           = 14px</span><br><span class="line">$font-size-base           = unit(hexo-config('font.global.size'), px) if hexo-config('font.global.size') is a 'unit'</span><br><span class="line">$font-size-small          = $font-size-base - 2px</span><br><span class="line">$font-size-smaller        = $font-size-base - 4px</span><br><span class="line">$font-size-large          = $font-size-base + 2px</span><br><span class="line">$font-size-larger         = $font-size-base + 4px</span><br></pre></td></tr></table></figure></p><p>直接修改<code>14px</code>即可，<code>base.styl</code>中还有对字体等内容更详细的设置。</p><p>但是，不建议使用这种直接修改源码的方式进行调整，原因很简单，直接修改源码后，以后会因为不知道初始设置而难以调整。此外，也难以区分设置是否被修改过，从而无法选择性备份自己修改过的设置，在升级。对此的解决方法是，在与<code>_variables</code>同目录处有一个<code>_custom</code>文件夹，文件夹内有一个名为<code>cumtom.styl</code>的空文件，在这个空文件中将需要修改的代码粘贴过去，改成需要的值并保存即可。</p><p>为什么可以这样做？<br>这一切似乎是在<code>~/css/main.styl</code>中规定的，由于作为小白尚未系统学习过css语法，只能根据实际情况推测：大概是因为<code>custom.styl</code>中的配置比<code>~/_variables</code> <code>~/_mixins</code>等文件夹内文件优先级要高，当<code>custom.styl</code>与<code>base.styl</code>中设置不同时，优先采用前者的设置，后者则会被覆盖。</p><p>下面将举例说明如何修改<code>custom.styl</code>文件。</p><h3 id="第三种方法-修改custom-styl"><a href="#第三种方法-修改custom-styl" class="headerlink" title="第三种方法 修改custom.styl"></a>第三种方法 修改custom.styl</h3><p>假设想要修改字体大小及字体族。<br>第一步，打开文件 <code>~blog/themes/next/source/css/_custom/custom.styl</code>和<code>~blog/themes/next/source/css/_variables/base.styl</code></p><p>先在<code>base.styl</code>中找到<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ font-size-base  =</span><br><span class="line">$ font-family-base  =</span><br></pre></td></tr></table></figure></p><p>在<code>custom.styl</code>中添加：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ font-size-base  =  14 px ; //默认是14px大小</span><br><span class="line">$ font-family-base  =  “Microsoft YaHei”，Verdana，sans-serif  //修改成你期望的字体族</span><br></pre></td></tr></table></figure></p><p>即完成了修改。</p><div style="display: none"><br>待更,，暂时隐藏掉。<br>另外，在<code>~/_variables</code> <code>~/_mixins</code>其实也各有一个名为<code>custom.styl</code>的空文件，在这些文件中加入你自己要修改的设置中也能起到相同的作用。自然的就会产生疑问：哪一个文件中的设置会被优先使用？为了弄明白这一问题，我做了一下测试：<br>在<code>~css/_variables/base.styl</code>中，将字体大小改为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$font-size-base           = 14px</span><br></pre></td></tr></table></figure><br><br>在<code>css/_variables/custom.styl</code>中，将字体大小改为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$font-size-base           = 20px</span><br></pre></td></tr></table></figure><br><br>在<code>~css/_custom/custom.styl</code>中，将字体大小改为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$font-size-base           = 25px</span><br></pre></td></tr></table></figure><br><br>在主题配置文件<code>~/blog/themes/next/_config.yml</code>中，将字体大小改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  global:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Lato</span><br><span class="line">    size:30</span><br><span class="line"></span><br><span class="line">最后显示的字体大小为：</span><br></pre></td></tr></table></figure><br><br></div><hr><h2 id="在Markdown中写注释"><a href="#在Markdown中写注释" class="headerlink" title="在Markdown中写注释"></a>在Markdown中写注释</h2><p>可参考<a href="https://www.imooc.com/article/23400" target="_blank" rel="noopener">这篇文章</a></p><hr><p>一些常用的资料：</p><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">HEXO官方文档</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a><br><a href="http://nipponcolors.com/" target="_blank" rel="noopener">日本の伝統色</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.给博客增加一个萌萌哒看板娘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.修改页脚处，年份与姓名间的图标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.增加访客统计功能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.Back-to-top 按钮显示百分比&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.如何设置「阅读全文」？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.将文章底部标签前的&amp;quot;#&amp;quot;替换为标签图标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7.修改字体及字体大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8.在Markdown中写注释&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;刚开始接触HEXO，这几天在一些大佬的博客和官方文档里学到了不少个性化设置。故记录于此，以备以后查阅。&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;Tip：如果发现修改后页面部分内容未正常显示，先试试&lt;code&gt;$ hexo clean&lt;/code&gt;,再进行生成和部署&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;给博客增加一个萌萌哒看板娘&quot;&gt;&lt;a href=&quot;#给博客增加一个萌萌哒看板娘&quot; class=&quot;headerlink&quot; title=&quot;给博客增加一个萌萌哒看板娘&quot;&gt;&lt;/a&gt;给博客增加一个萌萌哒看板娘&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;*经测试该插件在IE及Microsoft Edge上会引起不同程度的卡顿，建议使用Chrome浏览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Github项目地址：&lt;a href=&quot;https://github.com/EYHN/hexo-helper-live2d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在根目录下执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install --save hexo-helper-live2d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后&lt;a href=&quot;https://huaji8.top/post/live2d-plugin-2.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这里&lt;/a&gt;可以看到一些已有的模型，记下想要的模型名字,使用安装命令：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install &lt;span class=&quot;string&quot;&gt;&quot;模型的包名&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HEXO" scheme="http://wangyuyang.me/tags/HEXO/"/>
    
      <category term="NexT" scheme="http://wangyuyang.me/tags/NexT/"/>
    
  </entry>
  
</feed>
