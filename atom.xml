<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Y.-Y. Wang&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangyuyang.me/"/>
  <updated>2020-07-06T08:16:01.453Z</updated>
  <id>http://wangyuyang.me/</id>
  
  <author>
    <name>Y.-Y. Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用MATLAB解决误差理论典型习题</title>
    <link href="http://wangyuyang.me/2020/07/06/%E4%BD%BF%E7%94%A8MATLAB%E8%A7%A3%E5%86%B3%E8%AF%AF%E5%B7%AE%E7%90%86%E8%AE%BA%E5%85%B8%E5%9E%8B%E4%B9%A0%E9%A2%98/"/>
    <id>http://wangyuyang.me/2020/07/06/使用MATLAB解决误差理论典型习题/</id>
    <published>2020-07-06T08:00:42.000Z</published>
    <updated>2020-07-06T08:16:01.453Z</updated>
    
    <content type="html"><![CDATA[<p>误差理论与数据处理课很多习题<del>考试题</del>完全是同一个套路且冗长的计算，于是写了几个MATLAB脚本实现快速计算。</p><a id="more"></a> <h2 id="一元线性回归、方差分析和显著性分析"><a href="#一元线性回归、方差分析和显著性分析" class="headerlink" title="一元线性回归、方差分析和显著性分析"></a>一元线性回归、方差分析和显著性分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 一元线性回归分析</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>];</span><br><span class="line">y = [<span class="number">0.11</span>,  <span class="number">0.53</span>, <span class="number">0.95</span>,  <span class="number">1.56</span>, <span class="number">2.10</span>, <span class="number">2.63</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 元素数量</span></span><br><span class="line">N = <span class="built_in">numel</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 和</span></span><br><span class="line">sum_x = sum(x);</span><br><span class="line">sum_y = sum(y);</span><br><span class="line">sum_xy = sum(x.*y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 和的平方</span></span><br><span class="line">square_of_x_sum = sum_x^<span class="number">2</span>;</span><br><span class="line">square_of_y_sum = sum_y^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 平方和</span></span><br><span class="line">sum_of_x_square = sum(x.^<span class="number">2</span>);</span><br><span class="line">sum_of_y_square = sum(y.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 均值</span></span><br><span class="line">average_x = mean(x);</span><br><span class="line">average_y = mean(y);</span><br><span class="line"></span><br><span class="line">Lxx = sum( (x-average_x).^<span class="number">2</span> );</span><br><span class="line">Lyy = sum( (y-average_y).^<span class="number">2</span> );</span><br><span class="line">Lxy = sum( (x-average_x).*(y-average_y) );</span><br><span class="line"></span><br><span class="line">b = Lxy/Lxx;</span><br><span class="line">b0 = average_y - b * average_x;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 方差分析</span></span><br><span class="line">U = b * Lxy;          <span class="comment">% 回归平方和</span></span><br><span class="line">Q = Lyy - b * Lxy;    <span class="comment">% 残余平方和</span></span><br><span class="line">S = U + Q;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显著性检验</span></span><br><span class="line">F = U*(N - <span class="number">2</span>) / Q;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 残余方差</span></span><br><span class="line">square_of_sigma = Q / (N<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 残余标准差</span></span><br><span class="line">Sigma = <span class="built_in">sqrt</span>(Q / (N<span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 回归方程的稳定性</span></span><br><span class="line">temp = <span class="number">550</span>;           <span class="comment">% 自变量 x 的值</span></span><br><span class="line">SigmaY = Sigma * <span class="built_in">sqrt</span>(<span class="number">1</span>/N + (temp - average_x)^<span class="number">2</span> / Lxx );</span><br></pre></td></tr></table></figure><h2 id="重复实验的一元线性回归、方差分析和显著性检验"><a href="#重复实验的一元线性回归、方差分析和显著性检验" class="headerlink" title="重复实验的一元线性回归、方差分析和显著性检验"></a>重复实验的一元线性回归、方差分析和显著性检验</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 重复实验的的一元线性回归分析</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">x = [<span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line">y1 = [<span class="number">77.4</span>, <span class="number">76.7</span>, <span class="number">78.2</span>];</span><br><span class="line">y2 = [<span class="number">84.1</span>, <span class="number">84.5</span>, <span class="number">83.7</span>];</span><br><span class="line">y3 = [<span class="number">88.9</span>, <span class="number">89.2</span>, <span class="number">89.7</span>];</span><br><span class="line">y4 = [<span class="number">94.8</span>, <span class="number">94.7</span>, <span class="number">95.9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 元素数量</span></span><br><span class="line">N = <span class="built_in">numel</span>(x);</span><br><span class="line">m = <span class="built_in">numel</span>(y1);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 均值</span></span><br><span class="line">average_x = mean(x);</span><br><span class="line">average_y1 = mean(y1);</span><br><span class="line">average_y2 = mean(y2);</span><br><span class="line">average_y3 = mean(y3);</span><br><span class="line">average_y4 = mean(y4);</span><br><span class="line"></span><br><span class="line">y = [average_y1, average_y2, average_y3, average_y4];</span><br><span class="line">average_y = mean(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 和</span></span><br><span class="line">sum_x = sum(x);</span><br><span class="line">sum_y = sum(y);</span><br><span class="line">sum_xy = sum(x.*y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 和的平方</span></span><br><span class="line">square_of_x_sum = sum_x^<span class="number">2</span>;</span><br><span class="line">square_of_y_sum = sum_y^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 平方和</span></span><br><span class="line">sum_of_x_square = sum(x.^<span class="number">2</span>);</span><br><span class="line">sum_of_y_square = sum(y.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Lxx = sum( (x-average_x).^<span class="number">2</span> );</span><br><span class="line">Lyy = sum( (y-average_y).^<span class="number">2</span> );</span><br><span class="line">Lxy = sum( (x-average_x).*(y-average_y) );</span><br><span class="line"></span><br><span class="line">b = Lxy/Lxx;</span><br><span class="line">b0 = average_y - b * average_x;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 方差分析</span></span><br><span class="line">U = m * b * Lxy;</span><br><span class="line">QE = sum((y1 - average_y1).^<span class="number">2</span> ) + ...</span><br><span class="line">     sum((y2 - average_y2).^<span class="number">2</span> ) + ...</span><br><span class="line">     sum((y3 - average_y3).^<span class="number">2</span> ) + ...</span><br><span class="line">     sum((y4 - average_y4).^<span class="number">2</span> );</span><br><span class="line">QL = m * Lyy - U;</span><br><span class="line">S = U + QE + QL;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显著性检验</span></span><br><span class="line">VQE = N * (m <span class="number">-1</span>);</span><br><span class="line">VQL = N - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">F = U * VQE / QE;</span><br><span class="line">F1 = QL * VQE / (QE * VQL);</span><br><span class="line">F2 = U * (VQE + VQL) / (QE + QL);</span><br></pre></td></tr></table></figure><h2 id="二元线性回归分析"><a href="#二元线性回归分析" class="headerlink" title="二元线性回归分析"></a>二元线性回归分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 二元线性回归分析</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">x1 = [<span class="number">1.32</span>, <span class="number">2.69</span>, <span class="number">3.56</span>, <span class="number">4.41</span>, <span class="number">5.35</span>, <span class="number">6.20</span>, <span class="number">7.12</span>, <span class="number">8.87</span>, <span class="number">9.80</span>, <span class="number">10.65</span>];</span><br><span class="line">x2 = [<span class="number">1.15</span>, <span class="number">3.40</span>, <span class="number">4.10</span>, <span class="number">8.75</span>, <span class="number">14.82</span>, <span class="number">15.15</span>, <span class="number">15.32</span>, <span class="number">18.18</span>, <span class="number">35.19</span>, <span class="number">40.40</span>];</span><br><span class="line">y =  [<span class="number">6.40</span>, <span class="number">15.05</span>, <span class="number">18.75</span>, <span class="number">30.25</span>, <span class="number">44.85</span>, <span class="number">48.94</span>, <span class="number">51.55</span>, <span class="number">61.50</span>, <span class="number">100.44</span>, <span class="number">111.42</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 元素数量</span></span><br><span class="line">N = <span class="built_in">numel</span>(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 和</span></span><br><span class="line">sum_x1 = sum(x1);</span><br><span class="line">sum_x2 = sum(x2);</span><br><span class="line">sum_y = sum(y);</span><br><span class="line">sum_x1x2 = sum(x1.*x2);</span><br><span class="line">sum_x1y = sum(x1.*y);</span><br><span class="line">sum_x2y = sum(x2.*y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 平方和</span></span><br><span class="line">sum_of_x1_square = sum(x1.^<span class="number">2</span>);</span><br><span class="line">sum_of_x2_square = sum(x2.^<span class="number">2</span>);</span><br><span class="line">sum_of_y_square = sum(y.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 均值</span></span><br><span class="line">average_x1 = mean(x1);</span><br><span class="line">average_x2 = mean(x2);</span><br><span class="line">average_y = mean(y);</span><br><span class="line"></span><br><span class="line">L11 = sum_of_x1_square - <span class="number">1</span>/N * (sum_x1)^<span class="number">2</span>;</span><br><span class="line">L22 = sum_of_x2_square) - <span class="number">1</span>/N * (sum_x2)^<span class="number">2</span>;</span><br><span class="line">Lyy = sum_of_y_square - <span class="number">1</span>/N * (sum_y)^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">L12 = sum_x1x2 - <span class="number">1</span>/N * sum_x1 * sum_x2;</span><br><span class="line">L1y = sum_x1y - <span class="number">1</span>/N * sum_x1 * sum_y;</span><br><span class="line">L2y = sum_x2y - <span class="number">1</span>/N * sum_x2 * sum_y;</span><br><span class="line"></span><br><span class="line">L = [</span><br><span class="line">    L11, L12;</span><br><span class="line">    L12, L22;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">inv_L = inv(L);</span><br><span class="line"></span><br><span class="line">B = inv_L * [</span><br><span class="line">            L1y;</span><br><span class="line">            L2y</span><br><span class="line">            ];</span><br><span class="line"></span><br><span class="line">b1 = B(<span class="number">1</span>);</span><br><span class="line">b2 = B(<span class="number">2</span>);</span><br><span class="line">b0 = average_y - b1 * average_x1 - b2 * average_x2;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;误差理论与数据处理课很多习题&lt;del&gt;考试题&lt;/del&gt;完全是同一个套路且冗长的计算，于是写了几个MATLAB脚本实现快速计算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MATLAB" scheme="http://wangyuyang.me/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>利用Aliyun智能语音交互平台将视频课语音转文字稿</title>
    <link href="http://wangyuyang.me/2020/06/24/%E8%A7%86%E9%A2%91%E8%AF%BE%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E5%AD%97%E7%A8%BF/"/>
    <id>http://wangyuyang.me/2020/06/24/视频课语音转文字稿/</id>
    <published>2020-06-24T15:50:04.000Z</published>
    <updated>2020-06-24T16:32:35.269Z</updated>
    
    <content type="html"><![CDATA[<p>检测技术老师也太绝了，明确说考试内容书上没有，是课上讲的内容，于是决定利用阿里云的对象存储OSS服务配合智能语音交互平台的录音转文字服务提取文字稿。<br><a id="more"></a> </p><h2 id="第一步，获取音频文件"><a href="#第一步，获取音频文件" class="headerlink" title="第一步，获取音频文件"></a>第一步，获取音频文件</h2><p>之前为了提取PPT已经下载了课程录像。直接利用ffmpeg从视频中提取音频文件就行了。需要注意的是阿里云只支持支持单轨/双轨的wav格式、mp3格式的录音文件识别，另外采样率支持8000Hz、16000Hz。因此要在转换时注意一下，直接用ffmpeg就行了。</p><h2 id="第二步，将待识别文件上传至OSS"><a href="#第二步，将待识别文件上传至OSS" class="headerlink" title="第二步，将待识别文件上传至OSS"></a>第二步，将待识别文件上传至OSS</h2><p>根据文档说明：</p><blockquote><p>录音文件识别是针对已经录制完成的录音文件，进行识别的服务。录音文件识别是非实时的，识别的文件需要提交基于HTTP可访问的URL地址，不支持提交本地文件。</p></blockquote><p>之前租的VPS和内网穿透服务都很久没续费了，既然不支持本地文件识别，就按照官方建议开通了对象存储OSS服务，选标准型就好，按量付费价格也挺便宜的。然后上传音频文件并设置权限为公开可读就行了。</p><h2 id="第三步，开通智能语音交互平台"><a href="#第三步，开通智能语音交互平台" class="headerlink" title="第三步，开通智能语音交互平台"></a>第三步，开通智能语音交互平台</h2><p>按说明文档一步一步来就行，选择开通试用版每天可白嫖2h的免费转换服务。</p><h2 id="第四步，使用阿里云Python-SDK调用接口"><a href="#第四步，使用阿里云Python-SDK调用接口" class="headerlink" title="第四步，使用阿里云Python SDK调用接口"></a>第四步，使用阿里云Python SDK调用接口</h2><p>这个地方有点小坑，官方文档在两个看似完全相同的页面提供了不完全相同的Python Demo，其中一个程序调用时一直报41050015错误，文档中给出的解决方法是：“请确认请求参数appkey值是否设置正确，或者是否与阿里云账号的AccessKey ID同一个账号”。然而我反复确认，AccessKey ID和AppKey都填写的完全正确，对应的权限也在RAM控制台给了。</p><p>反复对比文档，最终发现另一个程序地域ID参数完全不同，不清楚两个文档为什么不一样，然后试了一下这个Demo完全正常。</p><p>由于服务器返回的转换结果是json格式文件，后附提取文稿的程序代码。</p><h2 id="效果评价"><a href="#效果评价" class="headerlink" title="效果评价"></a>效果评价</h2><p>一言难尽，连蒙带猜能大概知道在讲什么东西吧，果然便宜没好货。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[6:49] 这次呢我们把这个城市系统啊，就是说如 果说我们对一个我们说了，对于一个我们的一个仪器啊一个检测系统来讲。</span><br><span class="line">[6:58] 我们需要知道它的特性的情况下，那么我们一般的这种方法采用是都标准的方法来做的。但是这个标定呢。</span><br><span class="line">[7:5] 那么呃从之前的课程内容可以看出，那么他需要的是我们的输入量。</span><br><span class="line">[7:12] 呃，和输出量两个量预期呃，通过这两个量之间的一些有效的定位关系，来求出中间的这样一个量子关系。</span><br><span class="line">[7:21] 这个量子关系呢，那么你可以啊再成为一个标定。</span><br><span class="line">[7:25] 这个特或者这个特特性，然后这种标定在这个标定呢，我们上节课也说了一点，就是说。</span><br><span class="line">[7:31] 那么我们一个传感器或者测试性能测量系统的时候，它的标定的时候呢。</span><br><span class="line">[7:37] 有这种静态特性标定和动态特性标的。</span><br><span class="line">[7:41] 那么静态特性标定呢，那么从我们这个呃ppt给大家的这种概念上来讲，我们讲的是给出。</span><br><span class="line">[7:48] 呃，标定处于这样一个我们一个无关的这样一辆配置。也就是说它的一个放大。</span><br></pre></td></tr></table></figure><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>官网给的Demo，直接把AccessKey ID等参数填进去就行了，很像之前用requests库写的爬虫。</p><p>然后因为是轮询，转换过程中会返回大量无用的等待信息，可以对getResponse筛选一下，只存储状态码为21050000的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.request <span class="keyword">import</span> CommonRequest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fileTrans</span><span class="params">(akId, akSecret, appKey, fileLink)</span> :</span></span><br><span class="line">    <span class="comment"># 地域ID，常量内容，请勿改变</span></span><br><span class="line">    REGION_ID = <span class="string">"cn-shanghai"</span></span><br><span class="line">    PRODUCT = <span class="string">"nls-filetrans"</span></span><br><span class="line">    DOMAIN = <span class="string">"filetrans.cn-shanghai.aliyuncs.com"</span></span><br><span class="line">    API_VERSION = <span class="string">"2018-08-17"</span></span><br><span class="line">    POST_REQUEST_ACTION = <span class="string">"SubmitTask"</span></span><br><span class="line">    GET_REQUEST_ACTION = <span class="string">"GetTaskResult"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求参数key</span></span><br><span class="line">    KEY_APP_KEY = <span class="string">"appkey"</span></span><br><span class="line">    KEY_FILE_LINK = <span class="string">"file_link"</span></span><br><span class="line">    KEY_VERSION = <span class="string">"version"</span></span><br><span class="line">    KEY_ENABLE_WORDS = <span class="string">"enable_words"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 是否开启智能分轨</span></span><br><span class="line">    KEY_AUTO_SPLIT = <span class="string">"auto_split"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应参数key</span></span><br><span class="line">    KEY_TASK = <span class="string">"Task"</span></span><br><span class="line">    KEY_TASK_ID = <span class="string">"TaskId"</span></span><br><span class="line">    KEY_STATUS_TEXT = <span class="string">"StatusText"</span></span><br><span class="line">    KEY_RESULT = <span class="string">"Result"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 状态值</span></span><br><span class="line">    STATUS_SUCCESS = <span class="string">"SUCCESS"</span></span><br><span class="line">    STATUS_RUNNING = <span class="string">"RUNNING"</span></span><br><span class="line">    STATUS_QUEUEING = <span class="string">"QUEUEING"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建AcsClient实例</span></span><br><span class="line">    client = AcsClient(akId, akSecret, REGION_ID)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交录音文件识别请求</span></span><br><span class="line">    postRequest = CommonRequest()</span><br><span class="line">    postRequest.set_domain(DOMAIN)</span><br><span class="line">    postRequest.set_version(API_VERSION)</span><br><span class="line">    postRequest.set_product(PRODUCT)</span><br><span class="line">    postRequest.set_action_name(POST_REQUEST_ACTION)</span><br><span class="line">    postRequest.set_method(<span class="string">'POST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新接入请使用4.0版本，已接入(默认2.0)如需维持现状，请注释掉该参数设置</span></span><br><span class="line">    <span class="comment"># 设置是否输出词信息，默认为false，开启时需要设置version为4.0</span></span><br><span class="line">    task = &#123;KEY_APP_KEY : appKey, KEY_FILE_LINK : fileLink, KEY_VERSION : <span class="string">"4.0"</span>, KEY_ENABLE_WORDS : <span class="keyword">False</span>&#125;</span><br><span class="line">    <span class="comment"># 开启智能分轨，如果开启智能分轨 task中设置KEY_AUTO_SPLIT : True</span></span><br><span class="line">    <span class="comment"># task = &#123;KEY_APP_KEY : appKey, KEY_FILE_LINK : fileLink, KEY_VERSION : "4.0", KEY_ENABLE_WORDS : False, KEY_AUTO_SPLIT : True&#125;</span></span><br><span class="line">    task = json.dumps(task)</span><br><span class="line"></span><br><span class="line">    print(task)</span><br><span class="line"></span><br><span class="line">    postRequest.add_body_params(KEY_TASK, task)</span><br><span class="line">    taskId = <span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        postResponse = client.do_action_with_exception(postRequest)</span><br><span class="line">        postResponse = json.loads(postResponse)</span><br><span class="line">        <span class="keyword">print</span> (postResponse)</span><br><span class="line">        statusText = postResponse[KEY_STATUS_TEXT]</span><br><span class="line">        <span class="keyword">if</span> statusText == STATUS_SUCCESS :</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"录音文件识别请求成功响应！"</span>)</span><br><span class="line">            taskId = postResponse[KEY_TASK_ID]</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"录音文件识别请求失败！"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> ServerException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> (e)</span><br><span class="line">    <span class="keyword">except</span> ClientException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> (e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建CommonRequest，设置任务ID</span></span><br><span class="line">    getRequest = CommonRequest()</span><br><span class="line">    getRequest.set_domain(DOMAIN)</span><br><span class="line">    getRequest.set_version(API_VERSION)</span><br><span class="line">    getRequest.set_product(PRODUCT)</span><br><span class="line">    getRequest.set_action_name(GET_REQUEST_ACTION)</span><br><span class="line">    getRequest.set_method(<span class="string">'GET'</span>)</span><br><span class="line">    getRequest.add_query_param(KEY_TASK_ID, taskId)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交录音文件识别结果查询请求</span></span><br><span class="line">    <span class="comment"># 以轮询的方式进行识别结果的查询，直到服务端返回的状态描述符为"SUCCESS"、"SUCCESS_WITH_NO_VALID_FRAGMENT"，</span></span><br><span class="line">    <span class="comment"># 或者为错误描述，则结束轮询。</span></span><br><span class="line">    statusText = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</span><br><span class="line">        <span class="keyword">try</span> :</span><br><span class="line">            getResponse = client.do_action_with_exception(getRequest)</span><br><span class="line">            getResponse = json.loads(getResponse)</span><br><span class="line">            <span class="keyword">print</span> (getResponse)</span><br><span class="line"></span><br><span class="line">            statusText = getResponse[KEY_STATUS_TEXT]</span><br><span class="line">            <span class="keyword">if</span> statusText == STATUS_RUNNING <span class="keyword">or</span> statusText == STATUS_QUEUEING :</span><br><span class="line">                <span class="comment"># 继续轮询</span></span><br><span class="line">                time.sleep(<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="comment"># 退出轮询</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> ServerException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">        <span class="keyword">except</span> ClientException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">    <span class="keyword">if</span> statusText == STATUS_SUCCESS :</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"录音文件识别成功！"</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"录音文件识别失败！"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">accessKeyId = <span class="string">"xxxxxxxxxxxxxxx"</span></span><br><span class="line">accessKeySecret = <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">appKey = <span class="string">"xxxxxxxxxx"</span></span><br><span class="line">fileLink = <span class="string">"https://xxxxxxxxxxx.mp3"</span></span><br><span class="line"><span class="comment"># 执行录音文件识别</span></span><br><span class="line">fileTrans(accessKeyId, accessKeySecret, appKey, fileLink)</span><br></pre></td></tr></table></figure><p>对json文件进行简单的处理，获取需要的文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 毫秒转时间戳</span></span><br><span class="line"><span class="comment"># e.g. 70000ms = [1:10]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertmillis</span><span class="params">(milli)</span>:</span></span><br><span class="line">    milli /= <span class="number">1000</span></span><br><span class="line">    milli = int(milli)</span><br><span class="line">    minutes, seconds = divmod(milli, <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'['</span> + str(minutes) + <span class="string">':'</span> + str(seconds) + <span class="string">'] '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开已保存到本地的json文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"text.json"</span>,<span class="string">'r'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    raw_data = json.load(f)</span><br><span class="line"></span><br><span class="line">result_text = raw_data[<span class="string">"Result"</span>][<span class="string">"Sentences"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文本和对应的时间戳</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"outputText.txt"</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result_text:</span><br><span class="line">        f.write(convertmillis(i[<span class="string">"BeginTime"</span>]))</span><br><span class="line">        f.write(i[<span class="string">"Text"</span>])</span><br><span class="line">        f.write(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;检测技术老师也太绝了，明确说考试内容书上没有，是课上讲的内容，于是决定利用阿里云的对象存储OSS服务配合智能语音交互平台的录音转文字服务提取文字稿。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从腾讯课堂回放中提取PPT</title>
    <link href="http://wangyuyang.me/2020/06/01/%E4%BB%8E%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E5%9B%9E%E6%94%BE%E4%B8%AD%E6%8F%90%E5%8F%96PPT/"/>
    <id>http://wangyuyang.me/2020/06/01/从腾讯课堂回放中提取PPT/</id>
    <published>2020-06-01T09:12:11.000Z</published>
    <updated>2020-06-01T10:05:58.820Z</updated>
    
    <content type="html"><![CDATA[<p>检测技术老师不愿意提供课上所用的PPT文件，开卷考试总不能翻腾讯课堂回放吧，手动截图也很蠢。于是决定用Python从录屏里截图，去重后打包为PDF。<br><a id="more"></a> </p><h2 id="第一步，下载腾讯课堂的回放录像"><a href="#第一步，下载腾讯课堂的回放录像" class="headerlink" title="第一步，下载腾讯课堂的回放录像"></a>第一步，下载腾讯课堂的回放录像</h2><p>这个直接用一些能抓取视频网站的拓展程序就行了，写个爬虫工作量比较大不是很划算。我用的是<a href="https://chrome.google.com/webstore/detail/video-downloadhelper/lmjnegcaeklhafolokijcfjliaokphfk" target="_blank" rel="noopener">Video DownloadHelper</a>，收费软件，但是可以免费抓取一次视频文件，用掉免费次数后重装又可以白嫖一次。</p><h2 id="第二步，从视频文件中获取截图"><a href="#第二步，从视频文件中获取截图" class="headerlink" title="第二步，从视频文件中获取截图"></a>第二步，从视频文件中获取截图</h2><p>这个方法有很多，<del>比如一张一张的手动截图</del>，OpenCV就可以做到，但是看到有人反映OpenCV截图有点小问题？于是选择使用ffmpeg截图。</p><p>第一次用ffmpeg，看了看文档还是挺简单的，配置环境变量什么的就不提了，截图直接在命令行里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &quot;C:\video\xxx.mp4&quot; -r 0.02 D:\screenshot\%03d.png</span><br><span class="line"></span><br><span class="line">#  参数说明：</span><br><span class="line">#  -i &quot;C:\video\xxx.mp4&quot;</span><br><span class="line">## 视频路径，注意有引号</span><br><span class="line">#  -r 0.02</span><br><span class="line">## 每隔 1/0.02 秒截取一张图片</span><br><span class="line">#  D:\screenshot\%03d.png</span><br><span class="line">## 输出文件路径，注意没有引号，%03d.png的意思是文件命名为001.png，002.png，以此类推</span><br></pre></td></tr></table></figure><p>就行了，在Python里可以通过<code>os.system()</code>方法调用命令行。</p><h2 id="第三步，图片去重"><a href="#第三步，图片去重" class="headerlink" title="第三步，图片去重"></a>第三步，图片去重</h2><p>这里去重有一个前提，就是截图里只有老师的屏幕，并没有老师的摄像头（因为老师上课时没开摄像头），如果有的话可能还要额外处理一下（不断变化的摄像头界面会对相似图片的判断造成干扰）。</p><p>去重算法选择最简单的均值哈希（Average Hash, aHash），详见参考文献，这里引用一小段介绍：</p><blockquote><p>aHash算法 </p><p>aHash算法设计比较简单，主要利用图片的低频成分，通过缩小图片去除图片的高频成分，保留低频信息，并使用图像灰度方法化去除图像色彩来进一步去除高频成分。在此基础上，计算灰度图的像素平均值。遍历灰度图每一像素，将其与像素均值做比较，若大于均值，则记下1；否则，记下0，得到二进制串即为图像Hash值，也称为图像指纹。具体算法描述如下：</p><p>步骤1：将图片缩小到n×n，共n2个像素；<br>步骤2：将n×n图片转换为灰度图，记为Ga；<br>步骤3：计算灰度图Ga的像素平均值，记为pavg；<br>步骤4：遍历Ga中每一个像素pi，并将pi与pavg进行比较，若pi ≥ pavg，则记下1，否则记下0，得到n2个比特的二进制串即为图片aHash值，记为Ha；<br>步骤5：计算两张图片哈希值的海明距离，距离越小图片越相似，距离越大图片差异性越大。</p></blockquote><p>均值哈希的速度还是比较快的，300张截图大概只用了2s，还有很多可以优化的地方，比如由于处理的是视频序列，只需比较连续的几张图片就可以了（我这里比较了所有图片）。再比如把图片缩放到更小，如8*8，不过这个只在计算次数较多的时候有显著区别（见参考文献一），而且还会导致少量图片被错误的剔除。<br><del>对比一下，大二时写的“穿越福城”辅助是个什么辣鸡，一张图片处理十几秒，丢人</del></p><p>参考文献：</p><ol><li>黄嘉恒,李晓伟,陈本辉, 等.基于哈希的图像相似度算法比较研究[J].大理大学学报,2017,2(12):32-37.</li><li>干丽萍,许易,楼宋江, 等.基于感知哈希的作业相似度检测[J].台州学院学报,2016,38(3):10-14.</li></ol><h2 id="第四步，图片转PDF"><a href="#第四步，图片转PDF" class="headerlink" title="第四步，图片转PDF"></a>第四步，图片转PDF</h2><p>搜了一下，有一个image2pdf库挺好用的，可以直接把图片无损打包为PDF文件，唯一的问题就是官方例程会报TypeERROR错误（似乎只在Windows上有这一问题），需要稍微绕一下，详见代码。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> img2pdf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于 aHash 的图像去重</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_dedup_by_ahash</span><span class="params">(img_path)</span>:</span></span><br><span class="line">    img_list = os.listdir(img_path)</span><br><span class="line">    ahash_list = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">        <span class="comment"># 以灰度模式打开图像，丢弃高频成分</span></span><br><span class="line">        img = cv2.imread(img_path + img_name, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将图片缩小到 n*n，丢弃高频成分，取 8*8 时经常出现漏页</span></span><br><span class="line">        img = cv2.resize(img, (<span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算灰度图像素平均值</span></span><br><span class="line">        avg = np.mean(img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历像素并与均值比较，得到 aHash 值</span></span><br><span class="line">        img_ahash = np.where(img &gt; avg, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(ahash_list) &lt; <span class="number">1</span>:</span><br><span class="line">            ahash_list.append(img_ahash)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dup_flag = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> ahash_list:</span><br><span class="line">                <span class="comment"># 计算海明距离 </span></span><br><span class="line">                hamming_dis = np.bitwise_xor(img_ahash, i)</span><br><span class="line">                hamming_dis = np.sum(hamming_dis)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> hamming_dis &lt; <span class="number">5</span>:</span><br><span class="line">                    <span class="comment"># 根据海明距离删除重复照片</span></span><br><span class="line">                    os.remove(img_path + img_name)</span><br><span class="line">                    dup_flag = <span class="keyword">True</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> dup_flag <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">                <span class="comment"># 不重复则加入线性表</span></span><br><span class="line">                ahash_list.append(img_ahash)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"共删除了&#123;&#125;张重复图片~"</span>.format(count))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片打包为 PDF</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_image_to_pdf</span><span class="params">(img_path, pdf_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(pdf_path, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># img2pdf 有一个似乎只会在 Windows 上出现的问题，直接传入文件目录会报 TypeERROR</span></span><br><span class="line">        os.chdir(img_path)</span><br><span class="line">        f.write(img2pdf.convert([i <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(os.getcwd())]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 ffmpeg 截图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">capture_image_by_ffmpeg</span><span class="params">(video_path, img_path, interval_time)</span>:</span></span><br><span class="line">    interval_time = str(<span class="number">1</span>/interval_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(img_path) <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">        os.makedirs(img_path)</span><br><span class="line">        print(<span class="string">"路径不存在，已创建该文件夹\n"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ffmpeg -i "C:\Users\xxx.mp4" -r 0.02 dir\%03d.png</span></span><br><span class="line">    os.system(<span class="string">"ffmpeg -i \"&#123;&#125;\" -r &#123;&#125; &#123;&#125;\%03d.png"</span>.format(video_path, interval_time, img_path))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    video_name = <span class="string">"第四章 电参量测量.mp4"</span></span><br><span class="line">    video_path = <span class="string">"C:\\Users\\Yuyang Wang\\dwhelper\\"</span> + video_name</span><br><span class="line">    img_path = <span class="string">"D:\\dir\\chap4\\"</span></span><br><span class="line">    pdf_path = <span class="string">"D:\\dir\\"</span> + video_name.strip(<span class="string">".mp4"</span>) + <span class="string">".pdf"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用 ffmpeg 截图</span></span><br><span class="line">    capture_image_by_ffmpeg(video_path, img_path, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 均值哈希去重</span></span><br><span class="line">    image_dedup_by_ahash(img_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转 pdf</span></span><br><span class="line">    convert_image_to_pdf(img_path, pdf_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;检测技术老师不愿意提供课上所用的PPT文件，开卷考试总不能翻腾讯课堂回放吧，手动截图也很蠢。于是决定用Python从录屏里截图，去重后打包为PDF。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些有用的电子设计资料</title>
    <link href="http://wangyuyang.me/2020/04/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E8%B5%84%E6%96%99/"/>
    <id>http://wangyuyang.me/2020/04/27/一些有用的电子设计资料/</id>
    <published>2020-04-27T03:31:56.000Z</published>
    <updated>2020-06-01T10:00:57.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h2><p><a href="https://www.analog.com/cn/education/education-library/data-conversion-handbook.html" target="_blank" rel="noopener">ADI - The Data Conversion Handbook</a><br><blockquote><p>《数据转换手册》专为经常使用数据转换器和相应电路的设计工程师而著。此书包括数据转换器历史、数据采样系统基础、数据转换器架构、数据转换器工艺技术、数据转换器的测试、与数据转换器接口、数据转换器支持电路、数据转换器应用以及硬件设计技巧。它可能是涵盖内容最广的数据转换器相关产品书籍。此书最后一章讨论了一些实际问题，包括无源器件非理想特性的常见问题以及处理方法。</p></blockquote><br><a id="more"></a> </p><h2 id="MOSFET"><a href="#MOSFET" class="headerlink" title="MOSFET"></a>MOSFET</h2><p><a href="http://www.ti.com/lit/an/slva714c/slva714c.pdf" target="_blank" rel="noopener">TI - SLVA714C - Understanding Smart Gate Drive</a><br><blockquote><p>This application report describes the theory and methods behind enhancing a power MOSFET, how theIDRIVE and TDRIVE features are implemented in TI Smart Gate Drivers, and details many of the systemlevel benefits.</p></blockquote></p><p><a href="http://www.ti.com.cn/cn/lit/ml/zhca770/zhca770.pdf" target="_blank" rel="noopener">TI - MOSFET 和 IGBT 栅极驱动器电路的基本原理</a><br><a href="http://www.ti.com/lit/ml/slua618a/slua618a.pdf" target="_blank" rel="noopener">Fundamentals of MOSFET and IGBT Gate Driver Circuits</a><br><blockquote><p>本报告对目前较为流行的电路解决方案及其性能进行了分析，包括寄生器件的影响、瞬态和极端工作条件。本文从 MOSFET 技术和开关运行概述入手，按照由易而难的顺序，对各类问题进行了阐述。详细介绍了接地参考和高侧栅极驱动电路的设计流程，以及交流耦合和变压器隔离解决方案。本报告还包含了一个特殊部分，专门介绍了在同步整流器应用中 MOSFET 的栅极驱动 应用非常重要</p></blockquote></p><p><a href="https://toshiba.semicon-storage.com/content/dam/toshiba-ss/shared/docs/design-support/document/Reference-design/application-note/MOSFET-Gate-Drive-Circuit-Application-Notes_EN_36267-CN.pdf" target="_blank" rel="noopener">Toshiba - MOSFET 栅极驱动电路</a><br><a href="https://toshiba-semicon-storage.com/info/docget.jsp?did=59460" target="_blank" rel="noopener">MOSFET Gate Drive Circuit</a><br><blockquote><p>本文档说明了功率 MOSFET 的栅极驱动电路。</p></blockquote></p><p><a href="http://www.ti.com.cn/cn/lit/an/zhca637/zhca637.pdf" target="_blank" rel="noopener">TI - 关于减小 NexFET 功率 MOSFET 震荡的方法</a><br><blockquote><p>这篇应用文档中，会以一个典型非隔离同步 Buck 变换器的功率部分作为实例（见图 1），对设计中关于提升 NexFETTM 产品的性能和寿命进行讨论。开关管打开过程中叠加的电压<br>过冲是本文中讨论的最主要问题。此外，本文还会讨论开关管振铃的原理，精确测量振铃的方法以及减小振铃影响并维持良好系统性能的方法。</p></blockquote></p><p><a href="https://toshiba-semicon-storage.com/cn/semiconductor/knowledge/application-note.html" target="_blank" rel="noopener">Toshiba - MOSFET Gate Drive Circuit: Power MOSFET Application Notes.</a><br><blockquote><p>该页面中Toshiba给出了数十个MOSFET相关Application Notes。</p></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ADC&quot;&gt;&lt;a href=&quot;#ADC&quot; class=&quot;headerlink&quot; title=&quot;ADC&quot;&gt;&lt;/a&gt;ADC&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.analog.com/cn/education/education-library/data-conversion-handbook.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ADI - The Data Conversion Handbook&lt;/a&gt;&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;《数据转换手册》专为经常使用数据转换器和相应电路的设计工程师而著。此书包括数据转换器历史、数据采样系统基础、数据转换器架构、数据转换器工艺技术、数据转换器的测试、与数据转换器接口、数据转换器支持电路、数据转换器应用以及硬件设计技巧。它可能是涵盖内容最广的数据转换器相关产品书籍。此书最后一章讨论了一些实际问题，包括无源器件非理想特性的常见问题以及处理方法。&lt;/p&gt;
&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mosfet选型笔记</title>
    <link href="http://wangyuyang.me/2020/04/08/Mosfet%E9%80%89%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2020/04/08/Mosfet选型笔记/</id>
    <published>2020-04-08T15:03:19.000Z</published>
    <updated>2020-04-08T16:14:05.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择Mosfet应该考虑哪些因素"><a href="#选择Mosfet应该考虑哪些因素" class="headerlink" title="选择Mosfet应该考虑哪些因素?"></a>选择Mosfet应该考虑哪些因素?</h2><h4 id="厂家"><a href="#厂家" class="headerlink" title="厂家"></a>厂家</h4><p>NXP，TI，Infineon，Toshiba等公司都有Mosfet可选，善用官网提供的筛选工具对参数进行筛选。<br><a id="more"></a> </p><h4 id="确定N沟道还是P沟道"><a href="#确定N沟道还是P沟道" class="headerlink" title="确定N沟道还是P沟道"></a>确定N沟道还是P沟道</h4><p>这个没啥好说的，二者特性不一样，N沟道相对便宜一点，按需要来选。</p><p>还有一些Mos管会注明：N + Schottky或者Monolithically Integrated Schottky-like Diode。也就是说片内集成了肖特基二极管，根据需要还可以在外部并联一个二极管。</p><h4 id="考虑工作电压和电流"><a href="#考虑工作电压和电流" class="headerlink" title="考虑工作电压和电流"></a>考虑工作电压和电流</h4><p>主要是看Vgs，Vds之类的参数是否满足需求，这个都和应用有关，没有太大发挥的余地。</p><p>注：关于Mosfet各项参数的含义和等效电路模型可参考Texas Instruments的Application Report：<a href="http://www.ti.com/lit/an/slva714c/slva714c.pdf" target="_blank" rel="noopener">SLVA714C - Understanding Smart Gate Drive</a>。</p><h4 id="散热和成本"><a href="#散热和成本" class="headerlink" title="散热和成本"></a>散热和成本</h4><p><del>DIY不需要考虑，加铜管加散热片加硅脂硬怼，买买买就完事了，反正学校报销hhh</del></p><h4 id="导通电阻和寄生电容"><a href="#导通电阻和寄生电容" class="headerlink" title="导通电阻和寄生电容"></a>导通电阻和寄生电容</h4><p>这两个参数比较关键，导通电阻Rds(on)决定了功率损耗和额外热量的产生，越小越好，一般都在毫欧级。一些电源设计中为了减小Rds往往会令多个Mosfet并联。</p><p>寄生电容不仅影响充电速率（进而影响开关速率），还会影响系统的稳定性。例如栅极电容Qgd过大会导致Miller效应的产生，因此Qg越小越好，一般都在纳法级。</p><p>但是需要注意，<del>鱼和熊掌不可得兼</del>Rds越小，往往寄生电容越大，因此选型时两个都要考虑。</p><p>另外这两个参数都和工作时栅极电压有关，应根据实际情况来选。各半导体企业官网里的Filter都会提供4.5V，10V等电压下的筛选器。</p><h4 id="针对不同应用场合，对其他参数进行选择"><a href="#针对不同应用场合，对其他参数进行选择" class="headerlink" title="针对不同应用场合，对其他参数进行选择"></a>针对不同应用场合，对其他参数进行选择</h4><p>显然，不同的应用中对Mosfet特性的要求也不一样，例如在电机驱动中:</p><blockquote><p>Motor control is another application where power MOSFETs find use and where the most important selection criteria might again differ. A motor-control circuit doesn’t switch at the high frequencies found in modern switching power supplies. A typical half-bridge control circuit employs two MOSFETs (a full bridge uses four). But both of the MOSFETs spend a fair amount of time switched off – dead time.</p><p>Reverse Recovery Time (trr) becomes very important in such applications. When a control circuit switches a MOSFET in a bridge circuit to the off state when controlling an inductive load such as a motor winding, the other switch in the bridge conducts current in the reverse direction temporarily, via the body diode in the MOSFET–hence recirculating the current to continue to supply the motor. When the first MOSFET turns on again, the stored charge in the other MOSFET diode must be removed and discharged through the first, and that is a loss of energy, a short trr period minimizes such losses.</p></blockquote><p>说白了就是反向恢复时间trr越短越好，不同应用场景需求不一样<del>反正我也不懂</del>。</p><p>另外还有开启/关闭延迟，这个也是越快越好。开关速度慢会导致功率损耗。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><del>Infineon的DirectrFET Series金属封装看着好帅</del><br>主要影响散热、体积以及寄生电感等问题，TO220还有DPAK最常用。</p><p>扩展阅读：<br><a href="https://www.eetimes.com/the-application-guides-the-mosfet-selection-process/#" target="_blank" rel="noopener">The application guides the MOSFET selection process</a><br><a href="https://blog.csdn.net/gtkknd/article/details/26324397" target="_blank" rel="noopener">MOS管的导通特性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;选择Mosfet应该考虑哪些因素&quot;&gt;&lt;a href=&quot;#选择Mosfet应该考虑哪些因素&quot; class=&quot;headerlink&quot; title=&quot;选择Mosfet应该考虑哪些因素?&quot;&gt;&lt;/a&gt;选择Mosfet应该考虑哪些因素?&lt;/h2&gt;&lt;h4 id=&quot;厂家&quot;&gt;&lt;a href=&quot;#厂家&quot; class=&quot;headerlink&quot; title=&quot;厂家&quot;&gt;&lt;/a&gt;厂家&lt;/h4&gt;&lt;p&gt;NXP，TI，Infineon，Toshiba等公司都有Mosfet可选，善用官网提供的筛选工具对参数进行筛选。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="http://wangyuyang.me/2020/03/16/Nginx%E5%85%A5%E9%97%A8/"/>
    <id>http://wangyuyang.me/2020/03/16/Nginx入门/</id>
    <published>2020-03-16T12:22:30.000Z</published>
    <updated>2020-03-16T13:16:27.408Z</updated>
    
    <content type="html"><![CDATA[<p><del>终于知道大一时盲目的跟着教程在VPS上搭建WordPress博客时做的步骤有什么意义了，之后可以考虑抽空学一下计算机网络。</del><br><a id="more"></a></p><h2 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h2><p>Nginx是一个著名的开源Web和反向代理服务器。</p><h2 id="什么是Web服务器？"><a href="#什么是Web服务器？" class="headerlink" title="什么是Web服务器？"></a>什么是Web服务器？</h2><p>按顺序阅读以下内容，访问可能比较慢，需要挂代理：<br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_web_server" target="_blank" rel="noopener">什么是网络服务器？</a><br><a href="https://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html" target="_blank" rel="noopener">让我们一起来构建一个 Web 服务器（一）</a></p><h2 id="如何利用Nginx部署一个静态页面？"><a href="#如何利用Nginx部署一个静态页面？" class="headerlink" title="如何利用Nginx部署一个静态页面？"></a>如何利用Nginx部署一个静态页面？</h2><p>以Raspberry Pi 4为例，首先安装Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>安装完成后，在浏览器里输入Raspberry的IP地址<code>192.108.xxx.xxx</code>，就会看到如下的欢迎页：</p><blockquote><p>Welcome to nginx!<br>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p><p>For online documentation and support please refer to nginx.org.<br>Commercial support is available at nginx.com.</p><p>Thank you for using nginx.</p></blockquote><p>这里实际上就是Raspberry在接收到浏览器的请求后，将<code>/var/www/html</code>下的静态HTML文件<code>index.nginx-debian.html</code>（欢迎页）给浏览器。只需要把这个文件替换为我想要发送的文件（HTML、图像等）就可以了。</p><p>那么，如何指定Nginx发送什么文件呢？一种方法是通过修改<code>/etc/nginx.conf</code>来实现，只要把文件路径放到这个配置文件里就可以了。具体步骤可以参考Nginx的说明文档<a href="http://nginx.org/en/docs/beginners_guide.html#static" target="_blank" rel="noopener">Beginner’s Guide</a>。</p><p>除了上面这种方法外，还有一种更简单的方法，在<code>/var/www/html</code>下新建一个文件夹<code>test</code>，并在<code>/var/www/html/test</code>下新建一个文件<code>test.txt</code>（或者<code>tset.html</code>，都可以）。然后在文件中输入<code>Hello World!</code>，保存。回到浏览器。输入<code>192.168.xxx.xxx/test/test.txt</code>，即可。</p><p>利用Nginx + HTML + CSS + Javascript是可以实现非常漂亮的界面的，例如<a href="http://ariang.mayswind.net/latest/" target="_blank" rel="noopener">AriaNG</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;终于知道大一时盲目的跟着教程在VPS上搭建WordPress博客时做的步骤有什么意义了，之后可以考虑抽空学一下计算机网络。&lt;/del&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Raspberry Pi笔记</title>
    <link href="http://wangyuyang.me/2020/03/15/Raspberry-Pi%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2020/03/15/Raspberry-Pi笔记/</id>
    <published>2020-03-15T11:24:52.000Z</published>
    <updated>2020-04-10T01:56:43.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些个性化设置"><a href="#一些个性化设置" class="headerlink" title="一些个性化设置"></a>一些个性化设置</h2><p><strong>ssh欢迎信息</strong><br>直接修改<code>/etc/motd</code>即可，如：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      ______ ______</span><br><span class="line">    _/      Y      \_</span><br><span class="line">   // ~~ ~~ | ~~ ~  \\</span><br><span class="line">  // ~ ~ ~~ | ~~~ ~~ \\      </span><br><span class="line"> //________.|.________\\     欢迎回来~</span><br><span class="line">`----------`-&apos;----------&apos;</span><br></pre></td></tr></table></figure><p>推荐两个网站：<br><a href="https://www.asciiart.eu/" target="_blank" rel="noopener">ASCIIArt</a><br><a href="https://manytools.org/hacker-tools/convert-images-to-ascii-art/" target="_blank" rel="noopener">Convert Images to Ascii Art</a></p><p><strong>motd显示两次的问题</strong><br>只在win10上遇到了这一问题，占坑以后解决。</p><p><strong>Shell提示符颜色</strong><br>修改<code>/home/username/.bashrc</code>或<code>/root/.bashrc</code>即可。</p><p>自用设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;36m\]\u@\h\[\033[00m\]:\[\033[01;33m\]\w \$\[\033[00m\] &apos;</span><br></pre></td></tr></table></figure></p><p>转义符含义可参考<a href="https://blog.csdn.net/weixin_42205987/article/details/82056751" target="_blank" rel="noopener">这篇文章</a></p><h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p><strong>安装教程</strong><br>参考<a href="https://www.jianshu.com/p/5de3a2e688b4" target="_blank" rel="noopener">这里</a>和官方文档。</p><p><strong>Win10添加网络位置时提示“输入的文件夹似乎无效。请选择另一个”</strong><br>解决方法：不要使用“添加一个网络位置”，应选择“映射网络驱动器”。</p><p>原因参考<a href="https://blog.51cto.com/xdataplus/1875159" target="_blank" rel="noopener">这篇文章</a>。</p><p><strong>Failed to start Samba SMB Daemon</strong><br>解决思路看<a href="https://www.cnblogs.com/hehehe886/p/7605348.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><p>安装xrdp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br></pre></td></tr></table></figure><p>然后使用windows自带的“远程桌面连接”即可。</p><h2 id="Raspberry-Pi-4所有USB接口同时不识别设备的问题"><a href="#Raspberry-Pi-4所有USB接口同时不识别设备的问题" class="headerlink" title="Raspberry Pi 4所有USB接口同时不识别设备的问题"></a>Raspberry Pi 4所有USB接口同时不识别设备的问题</h2><p>问题表现：</p><ol><li>插入任意USB设备后，<code>/dev</code>目录无任何变化</li><li><code>lsusb</code>不返回任何结果（即使没有插入设备，<code>lsusb</code>也应当返回USB总线信息）</li><li><code>fdisk -l</code>也没有看到任何新设备。</li><li>所有USB口供电正常，VCC对GND电压均为5V</li><li>在出现问题之前，没有对USB进行任何操作，无论软件硬件（最为诡异的一点）</li></ol><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>把GPU Memory调整到512MB以下，重启。<br><del>MDZZ，谁能想到把显存大小拉高还会导致USB不能用啊</del></p><p>出问题以后，我一度以为是刚买来树莓派时，因为接了一个机械硬盘导致USB控制芯片过流烧毁。但是如果烧毁，USB口的供电也应该不正常才对，可万用表的测试结果表明电源是正常的。</p><p>最关键的一点是<code>lsusb</code>也没有返回任何信息。USB2.0和USB3.0居然同时失效，按理来说USB2.0不太可能出问题，毕竟一共就两根差分信号线。</p><p>中文互联网上也没有找到任何资料，正打算重刷系统时，突然发现了<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=253654" target="_blank" rel="noopener">这篇帖子</a>里作者测试发现显存太大会导致USB失效（原因不明）。试了一下，调到512MB以后USB果然又可以用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些个性化设置&quot;&gt;&lt;a href=&quot;#一些个性化设置&quot; class=&quot;headerlink&quot; title=&quot;一些个性化设置&quot;&gt;&lt;/a&gt;一些个性化设置&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ssh欢迎信息&lt;/strong&gt;&lt;br&gt;直接修改&lt;code&gt;/etc/motd&lt;/code&gt;即可，如：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C 语言的声明</title>
    <link href="http://wangyuyang.me/2020/02/14/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
    <id>http://wangyuyang.me/2020/02/14/C语言的声明/</id>
    <published>2020-02-14T11:15:43.000Z</published>
    <updated>2020-02-15T10:23:13.235Z</updated>
    
    <content type="html"><![CDATA[<p>对 <em>Expert C Programming</em> 第三章的理解。</p><a id="more"></a><h2 id="声明是如何形成的形成的？"><a href="#声明是如何形成的形成的？" class="headerlink" title="声明是如何形成的形成的？"></a>声明是如何形成的形成的？</h2><p>什么是声明？举几个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// 声明了一个名称为 i 的整型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="comment">// 声明了一个名称为 p 的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 声明了一个名称为 j 的不变量，并初始化为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 声明了一个名称为 array 的一维数组，数组中有 100 个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 声明了一个名称为 swap 的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> k;</span><br><span class="line"><span class="comment">// 一个复杂的变量，暂不分析</span></span><br></pre></td></tr></table></figure><p>如上所示，C语言里变量、数组或函数的声明都有类似的形式，或者说，这些语句都由下面三部分组成（对应书上表3-2）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明符       声明器              分号</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>    m ,n                ;</span><br><span class="line"><span class="keyword">int</span>          *p                  ;</span><br><span class="line"><span class="keyword">float</span>        <span class="built_in">array</span>[<span class="number">100</span>]          ;</span><br><span class="line"><span class="function"><span class="keyword">double</span>       <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  </span>;</span><br></pre></td></tr></table></figure><p>下面对说明符和声明器分别进行叙述。</p><h3 id="说明符"><a href="#说明符" class="headerlink" title="说明符"></a>说明符</h3><ul><li>specifier<ul><li>type-specifier, such as int, void, unsigned etc.</li><li>type-qualifier, such as const, volatile etc.</li><li>storage-class-specifier, such as static, extern etc.</li></ul></li></ul><p>说明符（specifier）的概念其实已经很熟悉了，包括类型说明符（type-specifier），也包括变量的存储类型说明符（storage-class-specifier）和类型限定符（type-qualifier）。显然，声明中至少要有一个类型说明符。</p><p>声明中specifier的顺序可以任意互换，例如下面的声明是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> *p2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">const</span> *p3;</span><br></pre></td></tr></table></figure><p>type-specifier和type-qualifier决定了declarator的返回类型。如上面的<code>*p1</code>的返回值类型应为<code>const unsigned int</code>，或者说，<code>p1</code>是指向<code>const unsigned int</code>类型的指针。</p><h3 id="声明器"><a href="#声明器" class="headerlink" title="声明器"></a>声明器</h3><p>声明器（declarator）的概念其实也很简单。一个声明中，可以有多个声明器（如前面的<code>m, n</code>），也可以只有一个声明器。</p><p>对于一个声明器，它也有着特定的结构（表3-1）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指针     直接声明器          初始化内容</span><br><span class="line">         i</span><br><span class="line">         j                  = <span class="number">10</span></span><br><span class="line">*        p</span><br><span class="line">*<span class="keyword">const</span>   k</span><br><span class="line">         <span class="built_in">array</span>[<span class="number">100</span>]</span><br><span class="line">         swap(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br></pre></td></tr></table></figure></p><p>指针（pointers）的数量不固定，可以有多个（如第五行），也可以只有一个（如第四行），还可以没有。</p><p>这里注意一下第五行，<code>const</code>在这里被划分为declarator的一部分，为什么这么划分可以参看第三章后面的内容。</p><p>考虑这三个声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> p2;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> p3;</span><br></pre></td></tr></table></figure><p><code>p1</code>、<code>p2</code>和<code>p3</code>都是指针，但这三个指针的含义并不相同。</p><p><code>const char *p1</code>的含义是，<code>*p1</code>的返回类型是<code>const char</code>，即<code>p1</code>是指向<code>const char</code>类型的指针，而<code>const</code>说明不能使用指针<code>p1</code>来修改其指向数据的值（但指针可以变）。</p><p><code>char *const p2</code>的含义是，<code>*const p2</code>的返回类型是<code>char</code>，即<code>const p2</code>是指向<code>char</code>类型的指针，而<code>const p2</code>说明指针不可变（但可以通过<code>p2</code>来修改其指向数据的值）。</p><p><code>const char *const p3</code>的分析方法类似，不仅指针<code>p3</code>指向的地址不可改变，也不可以使用该指针来修改其指向数据的值。</p><p>对三个指针可以进行的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="number">255</span>;           <span class="comment">// 合法的</span></span><br><span class="line">*p1 = <span class="number">255</span>;          <span class="comment">// 非法的</span></span><br><span class="line"></span><br><span class="line">p2 = <span class="number">255</span>;           <span class="comment">// 非法的</span></span><br><span class="line">*p2 = <span class="number">255</span>;          <span class="comment">// 合法的</span></span><br><span class="line"></span><br><span class="line">p3 = <span class="number">255</span>;           <span class="comment">// 非法的</span></span><br><span class="line">*p3 = <span class="number">255</span>;          <span class="comment">// 非法的</span></span><br></pre></td></tr></table></figure><blockquote><p>这里可以去看一下 <em>C Primer Plus</em> 数组和指针一章中关于<code>const</code>部分的内容。</p></blockquote><p>直接声明器（direct declarator）有且仅有一个。</p><p>初始化内容（initializer）可以没有，也可以有一个。</p><p>这样书上表3-1和表3-2的意思就很清楚了。<br><del>中文翻译的有些地方还是有点莫名其妙…对应的英文版看一遍就明白了</del></p><p>扩展阅读：<br><a href="https://www.zhihu.com/question/361938811/answer/943953531" target="_blank" rel="noopener">如何理解const char *p表示的是指针所指的值不变，但指针可以变？</a></p><p>2020年2月14日 Valentine’s Day</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 &lt;em&gt;Expert C Programming&lt;/em&gt; 第三章的理解。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MSP430F5529</title>
    <link href="http://wangyuyang.me/2020/01/22/MSP430F5529/"/>
    <id>http://wangyuyang.me/2020/01/22/MSP430F5529/</id>
    <published>2020-01-22T10:05:37.000Z</published>
    <updated>2020-01-22T11:20:40.231Z</updated>
    
    <content type="html"><![CDATA[<p>今天算是入门MSP430x5xx系列MCU。<br><a id="more"></a> </p><h2 id="MSP430x5xxx的GPIO"><a href="#MSP430x5xxx的GPIO" class="headerlink" title="MSP430x5xxx的GPIO"></a>MSP430x5xxx的GPIO</h2><p>读取GPIO稍微复杂一些，可分为四个步骤：</p><ol><li>配置是否引入内部电阻（PxREN Register）</li><li>如果引入内部电阻，配置该电阻为上拉电阻还是下拉电阻（PxOUT）</li><li>配置GPIO输入输出方向（PxDIR Register）</li><li>读取GPIO输入内容（PxIN Register）</li></ol><p>类似于MCS-51有两个外部中断源INT0和INT1（分别对应GPIO口P3.2和P3.2），MSP430的GPIO<br>如果需要启用GPIO的外部中断，还需设置I/O中断使能寄存器PxIE、中断标志位寄存器PxIFG和中断边沿选择寄存器PxIES。</p><p>由于MSP430只有一种输出方式———图腾柱输出，因此并不存在配置上下拉电阻的问题。向GPIO写数据只需两个步骤：</p><ol><li>配置GPIO输入输出方向（PxDIR Register）</li><li>写入GPIO输出内容（PxOUT Register）</li></ol><p>有些类似于MCS-51的第二功能概念，MSP430的一些GPIO引脚往往有其他功能，如果需要使用这些功能，那么还要配置功能寄存器PxSEL。</p><p>另外，如果需要调整GPIO的驱动能力，则可以调整输出驱动能力调节寄存器PxDS。相应的，驱动能力越强，EMI也会增加。</p><h3 id="输入寄存器PxIN"><a href="#输入寄存器PxIN" class="headerlink" title="输入寄存器PxIN"></a>输入寄存器PxIN</h3><p><em>Input Registers</em><br>只读寄存器，尝试向只读寄存器写入数据的指令会在该指令执行时增加电流消耗。</p><p>此外，经过测试，即使是I/O口被配置为输出状态，通过PxIN也能读取当前I/O状态，但这种操作往往没有任何意义，在某些有意义的情况下可能还有短路的问题……<br><del>幸亏没烧芯片</del></p><h3 id="输出寄存器PxOUT"><a href="#输出寄存器PxOUT" class="headerlink" title="输出寄存器PxOUT"></a>输出寄存器PxOUT</h3><p><em>Output Registers</em><br>I/O口作为输出功能时，由该寄存器决定输出内容。<br>I/O口作为输入功能时，由该寄存器配合PxREN决定上/下拉电阻的使用。</p><h3 id="上-下拉电阻使能寄存器PxREN"><a href="#上-下拉电阻使能寄存器PxREN" class="headerlink" title="上/下拉电阻使能寄存器PxREN"></a>上/下拉电阻使能寄存器PxREN</h3><p><em>Pullup or Pulldown Resistor Enable Registers</em></p><p>如下表，仅在输入时有效，需要配合PxOUT寄存器使用。</p><table><thead><tr><th>PxDIR</th><th>PxREN</th><th>PxOUT</th><th>I/O Configuration</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>x</td><td>Input</td></tr><tr><td>0</td><td>1</td><td>0</td><td>Input with pulldown resistor</td></tr><tr><td>0</td><td>1</td><td>1</td><td>Input with pullup resistor</td></tr><tr><td>1</td><td>x</td><td>x</td><td>Output</td></tr></tbody></table><h3 id="方向寄存器PxDIR"><a href="#方向寄存器PxDIR" class="headerlink" title="方向寄存器PxDIR"></a>方向寄存器PxDIR</h3><p><em>Direction Registers</em></p><p>值为0则引脚方向为输入，为1则引脚方向为输出。</p><p>2020年1月22日</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天算是入门MSP430x5xx系列MCU。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MSP430F5529 LaunchPad例程在CCS下编译失败的问题</title>
    <link href="http://wangyuyang.me/2020/01/21/MSP430F5529-LaunchPad%E4%BE%8B%E7%A8%8B%E5%9C%A8CCS%E4%B8%8B%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://wangyuyang.me/2020/01/21/MSP430F5529-LaunchPad例程在CCS下编译失败的问题/</id>
    <published>2020-01-21T15:38:51.000Z</published>
    <updated>2020-01-22T10:09:14.420Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一次使用MSP430系列MCU，使用<code>OutOfBox_EmulStorageKeyboard</code>例程时遇到的问题，解决方法在最后。</p></blockquote><a id="more"></a> <p>Texas Instruments官网提供的<code>OutOfBox_EmulStorageKeyboard</code>例程导入Code Composer Studio v9后总是编译失败，编译器一直报下面这种莫名其妙的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gmake: *** [all] Error 2</span><br><span class="line">gmake[1]: *** [OutOfBox_EmulStorageKeyboard.out] Error 1</span><br><span class="line">gmake[1]: Target &apos;secondary-outputs&apos; not remade because of errors.</span><br><span class="line">mklib: gmake error during rts430x_lc_ld_eabi.lib build</span><br><span class="line">unresolved symbol __mspabi_divu, first referenced in ./USB_API/USB_Common/usb.obj</span><br><span class="line">unresolved symbol __mspabi_mpyi, first referenced in ./USB_API/USB_Common/usb.obj</span><br><span class="line">unresolved symbol __mspabi_slli, first referenced in ./USB_API/USB_Common/usb.obj</span><br><span class="line">unresolved symbol __mspabi_srli, first referenced in ./USB_API/USB_Common/usb.obj</span><br><span class="line">unresolved symbol __TI_decompress_lzss</span><br><span class="line">unresolved symbol __TI_decompress_none</span><br><span class="line">unresolved symbol __TI_int41</span><br><span class="line">unresolved symbol __TI_int43</span><br><span class="line">unresolved symbol __TI_int44</span><br><span class="line">unresolved symbol __TI_int45</span><br><span class="line">unresolved symbol __TI_int46</span><br><span class="line">unresolved symbol __TI_int48</span><br><span class="line">unresolved symbol __TI_int49</span><br><span class="line">unresolved symbol __TI_int50</span><br><span class="line">unresolved symbol __TI_int52</span><br><span class="line">unresolved symbol __TI_int53</span><br><span class="line">unresolved symbol __TI_int54</span><br><span class="line">unresolved symbol __TI_int55</span><br><span class="line">unresolved symbol __TI_int56</span><br><span class="line">unresolved symbol __TI_int57</span><br><span class="line">unresolved symbol __TI_int58</span><br><span class="line">unresolved symbol __TI_int59</span><br><span class="line">unresolved symbol __TI_int60</span><br><span class="line">unresolved symbol __TI_int62</span><br><span class="line">unresolved symbol __TI_zero_init</span><br><span class="line">unresolved symbol memset, first referenced in ./USB_API/USB_HID_API/UsbHid.obj</span><br></pre></td></tr></table></figure><p>一开始先是针对每一个错误去Google对应的解决方法，看到很多人和我有一样的情况，一些TI员工说什么一定是导入时设置不对，吧啦吧啦讲了一堆。然而我照着做了一遍并没有什么卵用。。。。。</p><p>想想一百多块钱买来的玩具不能连第一个程序都烧不进去，太丢人了，于是就去看了一下Console，一长串的编译过程里看到这么三行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">warning #10366-D: automatic library build: using library &quot;D:\Program Files\ti\ccs930\ccs\tools\compiler\ti-cgt-msp430_18.12.4.LTS\lib\rts430x_lc_ld_eabi.lib&quot; for the first time, so it must be built.  This may take a few minutes.</span><br><span class="line"></span><br><span class="line">&apos;d:/program&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。</span><br><span class="line"></span><br><span class="line">&gt;&gt; ERROR: mklib: gmake error during rts430x_lc_ld_eabi.lib build</span><br></pre></td></tr></table></figure><p>注意到这个第二行“不是内部或外部命令……”我就去<code>D:\Program Files\ti\ccs930\ccs\tools\compiler\ti-cgt-msp430_18.12.4.LTS\lib\</code>文件夹看了一下，结果发现根本就没有名为<code>rts430x_lc_ld_eabi.lib</code>的文件，于是又去Google了一下，<a href="http://www.ti.com/cn/lit/ug/slau132u/slau132u.pdf" target="_blank" rel="noopener">MSP430 Optimizing C/C++ Compiler v19.6.0.STS User’s Guide</a>里有这么一段话：</p><blockquote><p>7.4 Library-Build Process</p><p>When using the C/C++ compiler, you can compile your code under a large number of different configurations and options that are not necessarily compatible with one another. Because it would be infeasible to include all possible run-time-support library variants, compiler releases pre-build only a small number of very commonly-used libraries such as rts430_eabi.lib.</p><p>To provide maximum flexibility, the run-time-support source code is provided as part of each compiler release. You can build the missing libraries as desired. The linker can also automatically build missing libraries. This is accomplished with a new library build process, the core of which is the executable mklib, which is available beginning with CCS 5.1.</p></blockquote><p><del>所以说老子编译例程还tm要先调用gmake把standard runtime support library编译一遍？有病？？？</del></p><p>耐着性子看完文档，于是在上面那个文件夹调用cmd试了一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklib --pattern=rts430x_lc_ld_eabi.lib</span><br></pre></td></tr></table></figure><p>然而并没有成功生成lib文件。粗略看了看<a href="https://processors.wiki.ti.com/index.php/Mklib#MKS_or_Cygwin_or_gmake_tools_in_your_path" target="_blank" rel="noopener">Mklib-Wiki</a>，似乎是因为Windows Defender的锅。就在实在没耐心折腾下去的时候，突然在TI的官方论坛的<a href="https://e2e.ti.com/support/tools/ccs/f/81/t/670991" target="_blank" rel="noopener">这篇帖子</a>里看到有人把已经编译好的库打包发了出来。下载<code>rts430x_lc_ld_eabi.rar</code>附件，把压缩包内的<code>rts430x_lc_ld_eabi.lib</code>放到<code>~\ti\ccs930\ccs\tools\compiler\ti-cgt-msp430_18.12.4.LTS\lib\</code>文件夹里，再点击Build，编译成功~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;第一次使用MSP430系列MCU，使用&lt;code&gt;OutOfBox_EmulStorageKeyboard&lt;/code&gt;例程时遇到的问题，解决方法在最后。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>山外库中UART部分的使用</title>
    <link href="http://wangyuyang.me/2019/12/06/%E5%B1%B1%E5%A4%96%E5%BA%93%E4%B8%ADUART%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wangyuyang.me/2019/12/06/山外库中UART部分的使用/</id>
    <published>2019-12-06T10:27:43.000Z</published>
    <updated>2019-12-06T11:48:23.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>相关文件目录：</p><ul><li>uart模块的定义：<code>~/Chip/Inc/MKL_uart.h</code></li><li>uart模块的实现：<code>~/Chip/Src/MKL_uart.c</code></li></ul><a id="more"></a> <p>使用串口的基本流程：初始化串口——发送/接收数据。</p><table><thead><tr><th>Functions</th><th>Features</th></tr></thead><tbody><tr><td>uart_init</td><td>初始化串口</td></tr><tr><td>uart_getchar</td><td>等待接收 1 个字节</td></tr><tr><td>uart_querychar</td><td>查询接收 1 个字符</td></tr><tr><td>uart_querystr</td><td>查询接收字符串</td></tr><tr><td>uart_querybuff</td><td>查询接收 buff</td></tr><tr><td>uart_putstr</td><td>发送字符串</td></tr><tr><td>uart_rx_irq_en</td><td>开串口接收中断</td></tr><tr><td>uart_rx_irq_dis</td><td>关串口接收中断</td></tr><tr><td>uart_tx_irq_en</td><td>开串口发送中断</td></tr><tr><td>uart_tx_irq_dis</td><td>关串口发送中断</td></tr><tr><td>uart_txc_irq_en</td><td>开串口发送完成中断</td></tr><tr><td>uart_txc_irq_dis</td><td>关串口发送完成中断</td></tr></tbody></table><h3 id="初始化串口"><a href="#初始化串口" class="headerlink" title="初始化串口"></a>初始化串口</h3><p><em>相关函数：uart_init()</em></p><p>直接调用<code>uart_init()</code>即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uart_init (UART1,<span class="number">115200</span>);               <span class="comment">// 初始化 串口 1 波特率为 115200</span></span><br></pre></td></tr></table></figure><h3 id="发送-接收数据"><a href="#发送-接收数据" class="headerlink" title="发送/接收数据"></a>发送/接收数据</h3><p><em>相关函数：uart_putchar(), uart_putbuff(), uart_putstr()</em></p><p>根据需要发送的数据量，可以分为发送/接收一个字节、发送/接收多个字节。</p><p>发送数据比较简单，直接调用以下任意一个函数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uart_putchar (UART2, <span class="string">'A'</span>);             <span class="comment">// 发送字节 'A'</span></span><br><span class="line">uart_putbuff (UART2,<span class="string">"1234567"</span>, <span class="number">3</span>);     <span class="comment">// 实际发送字符串 `1234567` 的前 3 个字节'1', '2', '3'</span></span><br><span class="line">uart_putstr (UART2,<span class="string">"1234567"</span>);         <span class="comment">// 实际发送了 7 个字节 `1234567`</span></span><br></pre></td></tr></table></figure><p>接收数据有两种实现：</p><h4 id="等待法"><a href="#等待法" class="headerlink" title="等待法"></a>等待法</h4><p><em>相关函数：uart_getchar()</em></p><p>如果没有接收到数据则原地等待，只有接收到数据程序才继续向下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">uart_getchar (UART2, &amp;ch);             <span class="comment">// 等待接收 1 个字节，保存到变量 ch 里</span></span><br></pre></td></tr></table></figure><p>等待法只能用于接收一个字节的数据。</p><h4 id="查询法"><a href="#查询法" class="headerlink" title="查询法"></a>查询法</h4><p><em>相关函数：uart_query(), uart_querychar(), uart_querystr(), uart_querybuff()</em></p><p>这四个名字里都带<code>query</code>的函数都有一个相同功能：每执行一次，就会判断一次单片机是否已经接收到了数据，如果接收到了数据则返回值1，否则返回0。</p><p>除此之外，在接收数据上与等待法不同的是，如果<strong>没有接收到数据，则程序继续向下执行</strong>；如果接收到数据，则将其保存到指定变量中，并继续向下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( uart_querychar (UART2,&amp;ch) == <span class="number">1</span>)   <span class="comment">//查询接收 1 个字符，保存到 ch 里</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"成功接收到一个字节"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，查询法接收多字节数据只需调用<code>uart_querystr()</code>即可，详见<em>攻城略地——一天攻破K60/KL26</em>。</p><p>关于<code>uart_getchar()</code>和<code>uart_querychar()</code>的区别，可以看下面两段代码，这两段代码的功能实际上是相同的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!uart_querychar (UART2, &amp;ch))    <span class="comment">// 等待接收到数据</span></span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"成功接收到一个字节"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">uart_getchar (UART2, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"成功接收到一个字节"</span>);</span><br></pre></td></tr></table></figure><p>山外库里还有两个名字接近的的函数<code>uart_query()</code>和<code>uart_querybuff()</code>，在<code>~/Chip/Src/MKL_uart.c</code>下可以看到<code>uart_query()</code>和<code>uart_querychar()</code>几乎完全一样，只不过<code>uart_query()</code>函数只判断有没有接收到数据，即使接收到数据也不保存。</p><p>而前面的<code>uart_querystr()</code>函数如果没有接收到数据，并不会改变传入数组的值， 但<code>uart_querybuff()</code>函数在没有接收到数据的情况下会将传入数组清零。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UART&quot;&gt;&lt;a href=&quot;#UART&quot; class=&quot;headerlink&quot; title=&quot;UART&quot;&gt;&lt;/a&gt;UART&lt;/h2&gt;&lt;p&gt;相关文件目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uart模块的定义：&lt;code&gt;~/Chip/Inc/MKL_uart.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;uart模块的实现：&lt;code&gt;~/Chip/Src/MKL_uart.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据的处理与表示</title>
    <link href="http://wangyuyang.me/2019/11/06/%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E8%A1%A8%E7%A4%BA/"/>
    <id>http://wangyuyang.me/2019/11/06/信息的处理与表示/</id>
    <published>2019-11-06T13:17:06.000Z</published>
    <updated>2019-12-13T13:24:02.281Z</updated>
    
    <content type="html"><![CDATA[<p>对一些知识的梳理。<br><a id="more"></a> </p><h2 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h2><p>原码（true form）：是指一个二进制数左边加上符号位后所得到的一串数，其中0代表正，1代表负。以一个八位二进制数为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +11 的原码：</span><br><span class="line">0000 1011</span><br><span class="line"></span><br><span class="line">// -11 的原码</span><br><span class="line">1000 1011</span><br></pre></td></tr></table></figure><p>反码（ones’ complement）：正数的反码是它本身；负数的反码是在原码的基础上，符号位不变，其它位按位取反。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +11 的反码：</span><br><span class="line">0000 1011</span><br><span class="line"></span><br><span class="line">// -11 的反码</span><br><span class="line">1111 0100</span><br></pre></td></tr></table></figure><p>补码（two’s-complement）：正数的补码是它本身；负数的补码是在反码的基础上加1。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +11 的补码：</span><br><span class="line">0000 1011</span><br><span class="line"></span><br><span class="line">// -11 的补码</span><br><span class="line">1111 0101</span><br></pre></td></tr></table></figure><p>已知一个数是补码，求原码：有两种计算方法，一种常用的思路是，补码的补码就是原码，故直接令这个数的符号位不变，其余位取反再加1即可。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// -11 的补码</span><br><span class="line">1111 0101</span><br><span class="line">// 符号位不变，其余位取反</span><br><span class="line">1000 1010</span><br><span class="line">// 加 1，得原码</span><br><span class="line">1000 1011      // 即-11</span><br></pre></td></tr></table></figure><p>关于补码运算详细的数学定义，可参见<em>CSAPP-Chapter 2</em></p><hr><h2 id="为什么有符号数会产生这三种表示法？"><a href="#为什么有符号数会产生这三种表示法？" class="headerlink" title="为什么有符号数会产生这三种表示法？"></a>为什么有符号数会产生这三种表示法？</h2><p>数学上，我们在表示十进制正数和负数时，会在这个数之前加上正负号，如“+5”、“-1024”等。在表示二进制有符号数时，也可以用同样的方法，如“+101”，“-100 0000 0000”。</p><p>但在计算机并不能理解“+”和“-”的概念，因而引入了原码的概念，使用最高位来表示正负。</p><p>原码的概念非常通俗易懂，但是使用这种方法来表示正数和负数有一个明显的缺陷——直接对两个使用原码表示的二进制数做运算时，有可能会产生错误的结果。例如，我们知道<code>1 + (-1) = 0</code>，但对于使用原码表示的二进制运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    0000 0001      // +1</span><br><span class="line">+   1000 0001      // -1</span><br><span class="line">=   1000 0010      // -2</span><br></pre></td></tr></table></figure><p>1000 0010对应的数为-2，这是明显错误的结果，而反码的引入成功解决了这一问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    0000 0001      // +1</span><br><span class="line">+   1111 1110      // -1</span><br><span class="line">=   1111 1111      // 对应的原码为 1000 0000，故结果为-0</span><br></pre></td></tr></table></figure><p>虽然反码解决了两个数相加结果不正确的问题，但是反码又引入了一个新的问题，这个问题在于0的表示上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000      // 对应原码 0000 0000，考虑符号位，即 +0</span><br><span class="line">1111 1111      // 对应原码 1000 0000，考虑符号位，即 -0</span><br></pre></td></tr></table></figure><p>讨论0的正负号是没有任何意义的。然而在补码的表示中，0却同时有了上述两种表示方法。于是在1945年，约翰·冯·诺依曼（John von Neumann）在一篇名为<em>First Draft of a Report on the EDVAC</em>的报告中提出了使用补码来表示二进制数。虽然补码的表示方法并不直观，但补码成功解决了所有原码和反码存在的问题。</p><blockquote><p>实际上，也正是在这篇<em>First Draft</em>中，冯·诺依曼首次提出了著名的冯·诺依曼架构（Von Neumann architecture），该架构也被称为普林斯顿架构（Princeton architecture）。</p></blockquote><p>以0为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    // 0 的原码</span><br><span class="line">    0000 0000</span><br><span class="line">    // 0 的反码</span><br><span class="line">    0000 0000</span><br><span class="line">or  1111 1111</span><br><span class="line">    // 0 的补码（正数不变，负数对反码加1）</span><br><span class="line">    0000 0000</span><br></pre></td></tr></table></figure><p>数学上可以证明补码运算时并不会像原码一样出现错误的结果，有兴趣的读者可自行阅读相关资料。</p><blockquote><p>如果有一串任意的二进制数，如<code>1111 1010</code>， 如何知道它表示的数是多少呢？显然，我们首先需要知道这串数到底是有符号数还是无符号数，如果是无符号数，那这个数就是+250；如果这个数是有符号数，我们就需要知道这个数是原码、反码，还是补码。如果这个数是原码，那它就是-122，如果是反码，那这个数就是-5，如果是补码，则其对应的数是-6。也就是说，不同的方法解读同一串二进制数，会得到完全不同的结果。</p><p>那么我们如何判断它是哪一种类型呢？答案是无法判断。无符号数和有符号数只是一个0/1序列，如果没有其它条件，我们并不能判断任意一串数字具体是哪一种表达方式。</p><p>事实上，即使知道一串数是有符号数，我们也依然无法判断这串数究竟是原码、反码还是补码。不过由于补码相对于原码和反码有着诸多优点，一般情况下都是用补码的形式来表示有符号数。</p></blockquote><hr><h2 id="使用不同的存储数据方式对汇编有哪些影响？"><a href="#使用不同的存储数据方式对汇编有哪些影响？" class="headerlink" title="使用不同的存储数据方式对汇编有哪些影响？"></a>使用不同的存储数据方式对汇编有哪些影响？</h2><p>以MCS-51汇编和8086汇编为例，立即数是由程序编写者指定的，存储在程序存储器中的一串二进制数。对于同一串二进制数，8051或者8086可以把它当作无符号数来运算，也可以当作有符号数来运算，或者说<strong>在机器级这一层次上，计算机是不会区分操作数的类型的</strong>，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; MCS-51</span><br><span class="line">    mov     a, #81H</span><br><span class="line">    add     a, #01H</span><br><span class="line"></span><br><span class="line">; 8086</span><br><span class="line">    mov     al, 81H</span><br><span class="line">    add     al, 01H</span><br></pre></td></tr></table></figure><p>如果把add指令的操作数当作无符号数，那么add指令相当于计算了<code>129 + 1 = 130</code>，而如果是看作使用补码存储的有符号数，那么add指令相当于计算了<code>-127 + 1 = -126</code>。</p><p>无论采用哪种形式来解读这段代码，add指令在执行时就已经包含了两种含义，得到了同一条信息记录的两种结果。具体采用那种结果应由实际需要来决定。</p><p>我们知道，程序状态字PSW内的CY（CF）（括号内为8086的标志位，下同）和OV（OF）标志位用于表示无符号运算时的进位和有符号运算时的溢出。我们在调用add指令时，必然会同时影响进/借位标志和溢出标志的值。如果我们认为add指令在进行无符号运算，那么就可以直接忽略溢出标志位的变化，只关注进/借位标志即可。如果我们认为add指令在进行有符号运算，那么直接忽略进/借位标志的变化，关注溢出标志位即可。</p><blockquote><p>其实在不同架构的机器上，由于硬件设计的不同，不同的汇编语言中对于有符号数和无符号数的处理是不同的。对于x86架构（即普通人在生活中能接触到的绝大多数计算机）而言，其设计和上述一样，加减法指令并不区分无符号数和有符号数。而对于某些指令集体系结构，如MIPS架构，其处理器的运算电路会区分是带符号数运算还是无符号整数运算，因而其汇编语言中有着专门的有（无）符号整数的加（减）运算指令（如add，sub，addu，subu）。</p></blockquote><hr><h2 id="存储数据的方式对C语言有哪些影响？"><a href="#存储数据的方式对C语言有哪些影响？" class="headerlink" title="存储数据的方式对C语言有哪些影响？"></a>存储数据的方式对C语言有哪些影响？</h2><p>在C语言中，程序员只需要使用<code>unsigned</code>和<code>signed</code>关键字来区分有符号数和无符号数，C语言标准并没有指定有符号数的表示方式，但几乎所有的机器都使用补码。虽然各种隐含的底层操作均由编译器实现，但是这种处理模式往往会带来一些难以察觉的问题。</p><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>最简单却在基地里几个同学的程序里都见过的bug：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">10</span>; i &lt; <span class="number">0</span>; i-- )          <span class="comment">// unsigned 类型永远也不可能小于 0</span></span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有符号数强制类型转换为无符号数"><a href="#有符号数强制类型转换为无符号数" class="headerlink" title="有符号数强制类型转换为无符号数"></a>有符号数强制类型转换为无符号数</h4><p><strong>强制类型转换不改变结果中的每一位，只改变解读这些位的方式</strong>，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> i = <span class="number">-1</span>;                       <span class="comment">// 补码 1111 1111</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> j = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)i;<span class="comment">// j = 1111 1111</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"j = %d"</span>, j);</span><br></pre></td></tr></table></figure><p>执行后命令行上显示 “j = 255”。</p><h4 id="无符号数强制类型转换为有符号数"><a href="#无符号数强制类型转换为有符号数" class="headerlink" title="无符号数强制类型转换为有符号数"></a>无符号数强制类型转换为有符号数</h4><p>和前面一样，强制类型转换不改变结果中的每一位，只改变解读这些位的方式，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">255</span>;             <span class="comment">// 1111 1111</span></span><br><span class="line"><span class="keyword">char</span> j = (<span class="keyword">char</span>)i;                  <span class="comment">// j = 1111 1111</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"j = %d"</span>, j);               <span class="comment">// j 为有符号类型，故 j 中存储的值被作为补码解读</span></span><br></pre></td></tr></table></figure><p>执行后命令行上显示 “j = -1”。</p><h4 id="比较无符号数和有符号数的大小"><a href="#比较无符号数和有符号数的大小" class="headerlink" title="比较无符号数和有符号数的大小"></a>比较无符号数和有符号数的大小</h4><p><strong>在C语言中执行一个运算时，如果一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号数强制类型转换为无符号数，并且假设这两个数都是非负的</strong>，在算数运算时这种行为并没有什么明显影响，但在使用关系运算符时，会产生明显错误的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = ( i &lt; j );                     <span class="comment">// 执行后 a = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> i = <span class="number">-1</span>;                       <span class="comment">// 补码 1111 1111</span></span><br><span class="line">    <span class="keyword">char</span> j = <span class="number">0</span>;                        <span class="comment">// 补码 0000 0000</span></span><br><span class="line"></span><br><span class="line">    a = ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)i &lt; j );      <span class="comment">// 因 1111 1111 &gt; 0000 0000</span></span><br><span class="line">                                       <span class="comment">// 执行后 a = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;                        <span class="comment">// 补码 1111 1111</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                         <span class="comment">// 补码 0000 0000</span></span><br><span class="line"></span><br><span class="line">    a = ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i &lt; j );       <span class="comment">// 因 1111 1111 &gt; 0000 0000</span></span><br><span class="line">                                       <span class="comment">// 执行后 a = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = ( i &lt; j );                     <span class="comment">// 执行后 a = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = ( i &lt; j );                     <span class="comment">// 执行后 a = 0</span></span><br></pre></td></tr></table></figure><h4 id="对浮点数使用运算符-或"><a href="#对浮点数使用运算符-或" class="headerlink" title="对浮点数使用运算符 == 或 !="></a>对浮点数使用运算符 == 或 !=</h4><p>关于IEEE规定的单精度浮点数和双精度浮点数这里不做过多介绍。只需知道很多能用十进制数精确表示的小数（如0.2）无法的用二进制数精确表示出来。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">x = x + <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">-4.9</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);                  <span class="comment">// 该语句永远不会被执行</span></span><br></pre></td></tr></table></figure><p>实际上，用调试工具可以看到，第三行执行后x的值为-4.900…007，确实不等于 -4.9。因此一定要避免对浮点数使用<code>==</code>或<code>!=</code>运算符。</p><p>参考资料：</p><ol><li>Bryant R E, O’Hallaron D R. 深入理解计算机系统[M]. 机械工业出版社, 2016.</li><li>王爽. 汇编语言[M]. 清华大学出版社有限公司, 2003.</li><li>袁春风. 计算机系统基础[M]. 机械工业出版社, 2014.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对一些知识的梳理。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PTA-数据结构与算法题目集</title>
    <link href="http://wangyuyang.me/2019/10/08/PTA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
    <id>http://wangyuyang.me/2019/10/08/PTA-数据结构与算法题目集/</id>
    <published>2019-10-08T00:44:09.000Z</published>
    <updated>2020-02-15T11:17:30.180Z</updated>
    
    <content type="html"><![CDATA[<p>学习数据结构时做的练习题。</p><a id="more"></a><h2 id="6-2-顺序表操作集"><a href="#6-2-顺序表操作集" class="headerlink" title="6-2 顺序表操作集"></a>6-2 顺序表操作集</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>本题要求实现顺序表的操作集。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>各个操作函数的定义为：</p><p>List MakeEmpty()：创建并返回一个空的线性表；</p><p>Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR；</p><p>bool Insert( List L, ElementType X, Position P )：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false；</p><p>bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    L = MakeEmpty();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        <span class="keyword">if</span> ( Insert(L, X, <span class="number">0</span>)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Insertion Error: %d is not in.\n"</span>, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Finding Error: %d is not in.\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is at position %d.\n"</span>, X, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P);</span><br><span class="line">        <span class="keyword">if</span> ( Delete(L, P)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Deletion Error.\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> ( Insert(L, <span class="number">0</span>, P)==<span class="literal">false</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" Insertion Error: 0 is not in.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FULL Insertion Error: <span class="number">6</span> is <span class="keyword">not</span> in.</span><br><span class="line">Finding Error: <span class="number">6</span> is <span class="keyword">not</span> in.</span><br><span class="line"><span class="number">5</span> is at position <span class="number">0.</span></span><br><span class="line"><span class="number">1</span> is at position <span class="number">4.</span></span><br><span class="line">POSITION <span class="number">-1</span> EMPTY Deletion Error.</span><br><span class="line">FULL Insertion Error: <span class="number">0</span> is <span class="keyword">not</span> in.</span><br><span class="line">POSITION <span class="number">6</span> EMPTY Deletion Error.</span><br><span class="line">FULL Insertion Error: <span class="number">0</span> is <span class="keyword">not</span> in.</span><br></pre></td></tr></table></figure></p><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><p>改了很多次，最后发现是printf()函数输出内容大小写问题……</p><p>下附自己写的答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    </span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(L)                                                  <span class="comment">// 如不检查 L 是否为空，VS2019 会报 C6011 警告</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Last == <span class="number">-1</span> || L == <span class="literal">NULL</span>)                        <span class="comment">// 线性表为空或指针为 NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L-&gt;Last; i++)                     <span class="comment">// 从 0 开始遍历数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X == L-&gt;Data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Last == MAXSIZE - <span class="number">1</span>)                            <span class="comment">// 线性表已满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (P &lt; <span class="number">0</span> || P &gt; L-&gt;Last+<span class="number">1</span>)                       <span class="comment">// 插入位置错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ILLEGAL POSITION"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L-&gt;Last; i &gt;= P; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Data[i + <span class="number">1</span>] = L-&gt;Data[i];                   <span class="comment">// 右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L-&gt;Data[P] = X;</span><br><span class="line">        L-&gt;Last++;                                         <span class="comment">// 更新表中元素数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P &lt; <span class="number">0</span> || P &gt; L-&gt;Last)                              <span class="comment">// 删除位置错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"POSITION %d EMPTY"</span>, P);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = P; i &lt; L-&gt;Last; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Data[i] = L-&gt;Data[i + <span class="number">1</span>];                   <span class="comment">// 左移</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        L-&gt;Last--;                                         <span class="comment">// 更新表中元素数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一句话需要注意一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的</span></span><br><span class="line">L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br></pre></td></tr></table></figure><p>正确的代码是我之前的写法，提交后也能通过检测，确实没问题。但后来第二次写程序时写成了第二种写法，发现不对。</p><p>正确的这一行代码的目的很简单，就是向操作系统申请一块内存，这块内存的大小要能放下一个结构体，同时定义一个指向这块内存首地址的指针L。因此这块内存的长度和L指向的数据类型（即struct LNode）应当相等（长了浪费，短了不够）。</p><p>所以正确的这一行代码实际上干了三件事：</p><ul><li>求出结构体类型的长度（这里为24字节）</li><li>使用malloc()函数获取24个字节的内存，并返回一个void类型指针</li><li>将malloc()返回的指针强制转换为List类型</li></ul><p>那么再继续看这两行代码，它们的区别实际上在于内存长度的不同，sizeof(struct LNode)的返回值为24，而List指针长度为4。显然，第二种写法中只申请了一块4字节的地址，无法容纳下要存放的结构体，是错误的。</p><p><del>总结：还是malloc()函数不熟</del></p><p>2019年10月8日 寒露</p><hr><h2 id="6-3-求链式表的表长"><a href="#6-3-求链式表的表长" class="headerlink" title="6-3 求链式表的表长"></a>6-3 求链式表的表长</h2><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><p>本题要求实现一个函数，求链式表的表长。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">( List L )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure></p><p>L是给定单链表，函数Length要返回链式表的长度。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">( List L )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = Read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Length(L));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 4 5 2 -1</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><h3 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h3><p>自己写的答案：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; L != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2020年2月8日 元宵节</p><hr><h2 id="6-4-链式表的按序号查找"><a href="#6-4-链式表的按序号查找" class="headerlink" title="6-4 链式表的按序号查找"></a>6-4 链式表的按序号查找</h2><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h3><p>本题要求实现一个函数，找到并返回链式表的第K个元素。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">( List L, <span class="keyword">int</span> K )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure></p><p>L是给定单链表，函数FindKth要返回链式表的第K个元素。如果该元素不存在，则返回ERROR。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">( List L, <span class="keyword">int</span> K )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    ElementType X;</span><br><span class="line">    List L = Read();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">        X = FindKth(L, K);</span><br><span class="line">        <span class="keyword">if</span> ( X!= ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, X);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NA "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">-1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> NA <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer"></a>Answer</h3><p>自己写的答案：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(List L, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == K)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> L-&gt;Data;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2020年2月8日 元宵节</p><hr><h2 id="6-5-链式表操作集"><a href="#6-5-链式表操作集" class="headerlink" title="6-5 链式表操作集"></a>6-5 链式表操作集</h2><h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question"></a>Question</h3><p>本题要求实现链式表的操作集。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure></p><p>各个操作函数的定义为：</p><p>Position Find( List L, ElementType X )：返回线性表中首次出现X的位置。若找不到则返回ERROR；</p><p>List Insert( List L, ElementType X, Position P )：将X插入在位置P指向的结点之前，返回链表的表头。如果参数P指向非法位置，则打印“Wrong Position for Insertion”，返回ERROR；</p><p>List Delete( List L, Position P )：将位置P的元素删除并返回链表的表头。若参数P指向非法位置，则打印“Wrong Position for Deletion”并返回ERROR。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P, tmp;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        L = Insert(L, X, L);</span><br><span class="line">        <span class="keyword">if</span> ( L==ERROR ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Finding Error: %d is not in.\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L = Delete(L, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is found and deleted.\n"</span>, X);</span><br><span class="line">            <span class="keyword">if</span> ( L==ERROR )</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong Answer or Empty List.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L = Insert(L, X, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( L==ERROR ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is inserted as the last element.\n"</span>, X);</span><br><span class="line">    P = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    tmp = Insert(L, X, P);</span><br><span class="line">    <span class="keyword">if</span> ( tmp!=ERROR ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    tmp = Delete(L, P);</span><br><span class="line">    <span class="keyword">if</span> ( tmp!=ERROR ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( P=L; P; P = P-&gt;Next ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, P-&gt;Data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">12 2 4 87 10 2</span><br><span class="line">4</span><br><span class="line">2 12 87 5</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 is found and deleted.</span><br><span class="line">12 is found and deleted.</span><br><span class="line">87 is found and deleted.</span><br><span class="line">Finding Error: 5 is not in.</span><br><span class="line">5 is inserted as the last element.</span><br><span class="line">Wrong Position for Insertion</span><br><span class="line">Wrong Position for Deletion</span><br><span class="line">10 4 2 5</span><br></pre></td></tr></table></figure></p><h3 id="Answer-3"><a href="#Answer-3" class="headerlink" title="Answer"></a>Answer</h3><p>自己写的答案：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Data == X)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(List L, ElementType X, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PtrToLNode ptr;</span><br><span class="line">    PtrToLNode head;</span><br><span class="line"></span><br><span class="line">    ptr = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    head = L;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (L == P)                                            <span class="comment">// 插在表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr-&gt;Data = X;</span><br><span class="line">        ptr-&gt;Next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Next == P)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;Data = X;</span><br><span class="line">            ptr-&gt;Next = L-&gt;Next;</span><br><span class="line">            L-&gt;Next = ptr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wrong Position for Insertion\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PtrToLNode head;</span><br><span class="line"></span><br><span class="line">    head = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L == P)                                            <span class="comment">// 删除表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = L-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(L);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Next == P)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Next = P-&gt;Next;</span><br><span class="line">            <span class="built_in">free</span>(P);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wrong Position for Deletion\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交时遇到了Presentation Error，查了一下，解释见这里：<a href="https://www.zhihu.com/question/20676665" target="_blank" rel="noopener">Presentation Error是什么意思？</a></p><p>2020年1月29日</p><hr><h2 id="6-6-带头结点的链式表操作集"><a href="#6-6-带头结点的链式表操作集" class="headerlink" title="6-6 带头结点的链式表操作集"></a>6-6 带头结点的链式表操作集</h2><h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question"></a>Question</h3><p>本题要求实现带头结点的链式表操作集。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure></p><p>各个操作函数的定义为：</p><p>List MakeEmpty()：创建并返回一个空的线性表；</p><p>Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR；</p><p>bool Insert( List L, ElementType X, Position P )：将X插入在位置P指向的结点之前，返回true。如果参数P指向非法位置，则打印“Wrong Position for Insertion”，返回false；</p><p>bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“Wrong Position for Deletion”并返回false。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line">    L = MakeEmpty();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        flag = Insert(L, X, L-&gt;Next);</span><br><span class="line">        <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Finding Error: %d is not in.\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = Delete(L, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is found and deleted.\n"</span>, X);</span><br><span class="line">            <span class="keyword">if</span> ( flag==<span class="literal">false</span> )</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong Answer.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = Insert(L, X, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is inserted as the last element.\n"</span>, X);</span><br><span class="line">    P = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    flag = Insert(L, X, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    flag = Delete(L, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( P=L-&gt;Next; P; P = P-&gt;Next ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, P-&gt;Data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">12 2 4 87 10 2</span><br><span class="line">4</span><br><span class="line">2 12 87 5</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 is found and deleted.</span><br><span class="line">12 is found and deleted.</span><br><span class="line">87 is found and deleted.</span><br><span class="line">Finding Error: 5 is not <span class="keyword">in</span>.</span><br><span class="line">5 is inserted as the last element.</span><br><span class="line">Wrong Position <span class="keyword">for</span> Insertion</span><br><span class="line">Wrong Position <span class="keyword">for</span> Deletion</span><br><span class="line">10 4 2 5</span><br></pre></td></tr></table></figure></p><h3 id="Answer-4"><a href="#Answer-4" class="headerlink" title="Answer"></a>Answer</h3><p>和上题思路几乎一样，只是简化了头结点的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line"></span><br><span class="line">    L = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line"></span><br><span class="line">    L-&gt;Data = <span class="number">-1</span>;</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = L-&gt;Next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Data == X)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(List L, ElementType X, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PtrToLNode ptr;</span><br><span class="line">    PtrToLNode head;</span><br><span class="line"></span><br><span class="line">    head = L;</span><br><span class="line">    ptr = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Next == P)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;Data = X;</span><br><span class="line">            ptr-&gt;Next = P;</span><br><span class="line">            L-&gt;Next = ptr;</span><br><span class="line">            head-&gt;Data++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wrong Position for Insertion\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PtrToLNode head;</span><br><span class="line"></span><br><span class="line">    head = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;Next == P)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Next = P-&gt;Next;</span><br><span class="line">            <span class="built_in">free</span>(P);</span><br><span class="line">            head-&gt;Data--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wrong Position for Deletion\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2020年2月7日</p><hr><h2 id="6-7-在一个数组中实现两个堆栈"><a href="#6-7-在一个数组中实现两个堆栈" class="headerlink" title="6-7 在一个数组中实现两个堆栈"></a>6-7 在一个数组中实现两个堆栈</h2><h3 id="Question-5"><a href="#Question-5" class="headerlink" title="Question"></a>Question</h3><p>本题要求在一个数组中实现两个堆栈。</p><p>函数接口定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="keyword">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="keyword">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="keyword">int</span> Tag )</span></span>;</span><br><span class="line">```  </span><br><span class="line">其中Tag是堆栈编号，取<span class="number">1</span>或<span class="number">2</span>；MaxSize堆栈数组的规模；Stack结构定义如下：</span><br><span class="line">```C</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br></pre></td></tr></table></figure></p><p>注意：如果堆栈已满，Push函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则Pop函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。</p><p>裁判测试程序样例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 1e8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; push, pop, end &#125; Operation;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125; <span class="keyword">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="keyword">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="keyword">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="keyword">int</span> Tag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Operation <span class="title">GetOp</span><span class="params">()</span></span>;  <span class="comment">/* details omitted */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStack</span><span class="params">( Stack S, <span class="keyword">int</span> Tag )</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Tag, X;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    S = CreateStack(N);</span><br><span class="line">    <span class="keyword">while</span> ( !done ) &#123;</span><br><span class="line">        <span class="keyword">switch</span>( GetOp() ) &#123;</span><br><span class="line">        <span class="keyword">case</span> push: </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Tag, &amp;X);</span><br><span class="line">            <span class="keyword">if</span> (!Push(S, X, Tag)) <span class="built_in">printf</span>(<span class="string">"Stack %d is Full!\n"</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> pop:</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Tag);</span><br><span class="line">            X = Pop(S, Tag);</span><br><span class="line">            <span class="keyword">if</span> ( X==ERROR ) <span class="built_in">printf</span>(<span class="string">"Stack %d is Empty!\n"</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> end:</span><br><span class="line">            PrintStack(S, <span class="number">1</span>);</span><br><span class="line">            PrintStack(S, <span class="number">2</span>);</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure></p><p>输入样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">Push 1 1</span><br><span class="line">Pop 2</span><br><span class="line">Push 2 11</span><br><span class="line">Push 1 2</span><br><span class="line">Push 2 12</span><br><span class="line">Pop 1</span><br><span class="line">Push 2 13</span><br><span class="line">Push 2 14</span><br><span class="line">Push 1 3</span><br><span class="line">Pop 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack 2 Empty</span><br><span class="line">Stack 2 is Empty!</span><br><span class="line">Stack Full</span><br><span class="line">Stack 1 is Full!</span><br><span class="line">Pop from Stack 1: 1</span><br><span class="line">Pop from Stack 2: 13 12 11</span><br></pre></td></tr></table></figure></p><h3 id="Answer-5"><a href="#Answer-5" class="headerlink" title="Answer"></a>Answer</h3><p>自己写的答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;Top1 = <span class="number">-1</span>;</span><br><span class="line">        S-&gt;Top2 = MaxSize;</span><br><span class="line">        S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">        S-&gt;MaxSize = MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X, <span class="keyword">int</span> Tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (S-&gt;Top2 == S-&gt;Top1 + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack Full\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == Tag)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;Data[++S-&gt;Top1] = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;Data[--S-&gt;Top2] = X;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S, <span class="keyword">int</span> Tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == Tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == S-&gt;Top1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Stack 1 Empty\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S-&gt;Data[S-&gt;Top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;MaxSize == S-&gt;Top2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Stack 2 Empty\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S-&gt;Data[S-&gt;Top2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要忘记换行符！</del><br><del>不要忘记换行符！</del><br><del>不要忘记换行符！</del></p><p>2020年2月10日</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习数据结构时做的练习题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AVR单片机熔丝位设置</title>
    <link href="http://wangyuyang.me/2019/10/06/AVR%E5%8D%95%E7%89%87%E6%9C%BA%E7%86%94%E4%B8%9D%E4%BD%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>http://wangyuyang.me/2019/10/06/AVR单片机熔丝位设置/</id>
    <published>2019-10-06T06:58:23.000Z</published>
    <updated>2019-10-07T07:28:41.903Z</updated>
    
    <content type="html"><![CDATA[<p>第一次用AVR单片机，试着用Atmega32U4搭建了一个最小系统板，从datasheet里了解到AVR单片机还有一个叫做熔丝（fuse）的东西，记一下学到的知识。<br><a id="more"></a> </p><h2 id="什么是熔丝？"><a href="#什么是熔丝？" class="headerlink" title="什么是熔丝？"></a>什么是熔丝？</h2><p>fuse实际是保险丝的意思，但中文资料一般将avr芯片中的fuse翻译作熔丝。这里的熔丝和电工里用到的保险丝几乎没什么关系，并不是用于过载保护，而是指芯片上一个长度为3字节的特殊存储区域。在这个存储区域内保存的数据决定着该芯片的工作方式，从这个角度来讲，有点类似于51单片机中的一些特殊功能寄存器（如TMOD等）。该区域中保存的数据并不会因为断电而消失，而且单片机正常运行时不能修改。因此正确配置熔丝位（fuse bits）是十分重要的。事实上，如果设置熔丝位时设置错误，会有让单片机直接锁死的风险，届时只能采取一些特殊措施来解锁芯片。</p><h2 id="熔丝位的具体设置"><a href="#熔丝位的具体设置" class="headerlink" title="熔丝位的具体设置"></a>熔丝位的具体设置</h2><p>前面提到，fuse是指芯片上一个长度为3字节的特殊存储区域。所以对熔丝的修改，实际上就是修改该区域内存储的数据。先随便来看一个Atmega32U4的熔丝位设置：</p><ul><li>Fuse Bits:  0xFF9941</li></ul><p>这是一个长度为3字节的数，实际上为三部分构成：</p><ul><li>Low:        0x41</li><li>High:       0x99</li><li>Extend:     0xFF</li></ul><p>对应的二进制数为</p><ul><li>Low:        0100  0001</li><li>High:       1001  1001</li><li>Extend:     1111  1111</li></ul><p>这里熔丝低位和熔丝高位中的每一位都有着特殊含义，如熔丝低位中的0001是指单片机工作时使用芯片内部频率为1MHz的RC振荡器。当使用有源/无源的高频/低频晶振时，这四位也要进行相应的修改。具体的设置可参考datasheet。</p><p>熔丝扩展位里的低四位和前两者一样，有着特殊的含义。但扩展位的高四位没有任何功能。</p><p>2019年10月6日</p><hr><p><a href="http://www.ladyada.net/learn/avr/fuses.html" target="_blank" rel="noopener">http://www.ladyada.net/learn/avr/fuses.html</a><br><a href="http://blog.sina.com.cn/s/blog_870ad0e00100tug9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_870ad0e00100tug9.html</a><br><a href="https://blog.csdn.net/wowocpp/article/details/80715172" target="_blank" rel="noopener">https://blog.csdn.net/wowocpp/article/details/80715172</a><br><a href="https://www.amobbs.com/thread-4644881-1-1.html" target="_blank" rel="noopener">https://www.amobbs.com/thread-4644881-1-1.html</a><br><a href="https://www.amobbs.com/forum.php?mod=viewthread&amp;tid=29462" target="_blank" rel="noopener">https://www.amobbs.com/forum.php?mod=viewthread&amp;tid=29462</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次用AVR单片机，试着用Atmega32U4搭建了一个最小系统板，从datasheet里了解到AVR单片机还有一个叫做熔丝（fuse）的东西，记一下学到的知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DS1302</title>
    <link href="http://wangyuyang.me/2019/08/18/DS1302/"/>
    <id>http://wangyuyang.me/2019/08/18/DS1302/</id>
    <published>2019-08-18T01:20:36.000Z</published>
    <updated>2019-08-23T06:07:00.338Z</updated>
    
    <content type="html"><![CDATA[<p>课程需要，学习DS1302的用法。</p><a id="more"></a> <h2 id="Datasheet"><a href="#Datasheet" class="headerlink" title="Datasheet"></a>Datasheet</h2><p><a href="https://datasheets.maximintegrated.com/en/ds/DS1302.pdf" target="_blank" rel="noopener">DS1302-Datasheet</a><br><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2007&amp;filename=NKDZ200702019" target="_blank" rel="noopener">Application Note 58: Crystal Considerations for Dallas Real-Time Clocks</a></p><hr><h2 id="Vcc1和Vcc2的区别"><a href="#Vcc1和Vcc2的区别" class="headerlink" title="Vcc1和Vcc2的区别"></a>Vcc1和Vcc2的区别</h2><p>一开始，我是觉得Vcc1和Vcc2没啥区别随便接电源，看到datasheet里这段话更是觉得没有区别：</p><blockquote><p>Vcc2<br>Primary Power-Supply Pin in Dual Supply Configuration. VCC1 is connected to a backup source to maintain the time and date in the absence of primary power. The DS1302 operates from the larger of VCC1 or VCC2. When VCC2 is greater than VCC1 + 0.2V, VCC2 powers the DS1302. When VCC2 is less than VCC1, VCC1 powers the DS1302.</p></blockquote><p>但是看到Vcc1的引脚说明就知道还是有一点区别的：</p><blockquote><p>Vcc1<br>Low-Power Operation in Single Supply and Battery-Operated Systems and LowPower Battery Backup. In systems using the trickle charger, the rechargeable energy source is connected to this pin. UL recognized to ensure against reverse charging current when used with a lithium battery. </p></blockquote><p>简单地说就是Vcc1支持给电池充电（如果使用了可充电电池的话），Vcc2不支持。</p><hr><h2 id="晶振负载电容（load-capacitance）的影响"><a href="#晶振负载电容（load-capacitance）的影响" class="headerlink" title="晶振负载电容（load capacitance）的影响"></a>晶振负载电容（load capacitance）的影响</h2><p>首先，什么是负载电容？晶振的负载电容并非指连接在晶振外部的电容，而是指晶振本身串接在电路中的等效电容值。关于负载电容的更详细的内容，可参考<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2007&amp;filename=NKDZ200702019" target="_blank" rel="noopener">王跃, 张晰泊, 王彬, 高清运. 用于RTC的32.768 kHz晶振电路的设计</a></p><p>根据datasheet：</p><blockquote><p>Connections for Standard 32.768kHz Quartz Crystal. The internal oscillator is designed for operation with a crystal having a specified load capacitance of 6pF.<br>For more information on crystal selection and crystal layout considerations, refer to Application Note 58: Crystal Considerations for Dallas Real-Time Clocks. </p></blockquote><p>选择32.768kHz晶振很好理解，但是这里强调了晶振的负载电容为6pF，原因没有作详细解释。于是我就去查了一下文中提到的<a href="http://www.emesystems.com/pdfs/parts/DS1307_xtal.pdf" target="_blank" rel="noopener">Application Note 58: Crystal Considerations for Dallas Real-Time Clocks</a>，这篇文档里给出了答案：</p><blockquote><p>The frequency accuracy of a crystal-based oscillator circuit is mainly dependent upon the accuracy of the crystal and the accuracy of the match between the crystal and the oscillator capacitive load. If the capacitive load is less than the crystal was designed for, the oscillator runs fast. If the capacitive load is greater than what the crystal was designed for, the oscillator runs slow. </p><p>……</p><p>Wrong crystal. An RTC typically runs fast if a crystal with a specified load capacitance (CL) greater than the RTC-specified load capacitance is used. The severity of the inaccuracy is dependent on the value of the CL. For example, using a crystal with a CL of 12pF on an RTC designed with a 6pF CL causes the RTC to be about 3 to 4 minutes per month fast.</p></blockquote><p>也就是说，如果使用负载电容大于6pF的晶振，DS1302计时会更快。反之，如果小于6pF,计时会变慢。个人觉得如果对计时精准度没有较高的要求，完全可以忽略这一问题，用12pF的晶振来提供时钟信号也不过每个月快3到4分钟而已。</p><p>如果过晶振的负载电容不等于6pF，又希望计时精度更高，也可以选择通过串/并联电容进行修正，详见<a href="http://www.cqvip.com/qk/83588x/200101/4871613.html" target="_blank" rel="noopener">屠运武, 谷松, 王甬生, 钟英华. 时钟芯片DS1302可靠起振的方法</a>。</p><p>2019年8月18日</p><hr><h2 id="向-DS1302-中写入数据"><a href="#向-DS1302-中写入数据" class="headerlink" title="向 DS1302 中写入数据"></a>向 DS1302 中写入数据</h2><p>DS1302一共有三个引脚用于通信：</p><ul><li>CE</li><li>I/O</li><li>SCLK</li></ul><p>其中CE在datasheet的早期版本中也被叫做RST，虽然名字改了但功能未变。对DS1302读写数据时CE必须输入高电平。</p><p>SCLK为时钟信号输入，用于保证数据发送方和接收方的同步。</p><p>I/0引脚则是真正用于传输数据的引脚，数据传输时先发送低位然后才发送高位。</p><p>根据datasheet：</p><blockquote><p>COMMAND BYTE<br>Figure 3 shows the command byte. A command byte initiates each data transfer. The MSB (bit 7) must be a logic 1. If it is 0, writes to the DS1302 will be disabled. Bit 6 specifies clock/calendar data if logic 0 or RAM data if logic 1. Bits 1 to 5 specify the designated registers to be input or output, and the LSB (bit 0) specifies a write operation (input) if logic 0 or read operation (output) if logic 1. The command byte is always input starting with the LSB (bit 0).</p><p>DATA INPUT<br>Following the eight SCLK cycles that input a write command byte, a data byte is input on the rising edge of the next eight SCLK cycles. Additional SCLK cycles are ignored should they inadvertently occur. Data is input starting with bit 0.</p></blockquote><p>简单地说，就是每次向DS1302发送数据，都只能发送两个字节。先发送的第一个字节是控制命令，第二个字节才是真正想要传送的数据。</p><p>控制命令中，第七位必须为1，否则写入会被禁用无效；第六位用于选择RAM或clock/calender；第一到第五位是要写入（读取）的寄存器的地址；最低位则用于指示读取数据（为1）还是写入数据（为0）。套用微机原理中的概念，I/O引脚同时充当了数据总线、地址总线和控制总线的作用。</p><p>概括：写入时钟数据时，控制命令的构成为（从高到低）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BIN: 1 0 xxxxx 0</span><br><span class="line">// `xxxxx`为目标寄存器的地址。</span><br><span class="line"></span><br><span class="line">HEX: 0x80 | xxxx</span><br><span class="line">// `xxxx`为目标寄存器的地址（十六进制）。</span><br></pre></td></tr></table></figure><hr><h2 id="从-DS1302-中读取数据"><a href="#从-DS1302-中读取数据" class="headerlink" title="从 DS1302 中读取数据"></a>从 DS1302 中读取数据</h2><p>和写入数据类似，首先要发送一个控制命令，命令包含要读取的寄存器地址、指示本次操作的目的为读取信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BIN: 1 0 xxxxx 1</span><br><span class="line">// `xxxxx`为目标寄存器的地址。</span><br><span class="line"></span><br><span class="line">HEX: 0x80 | xxxx</span><br><span class="line">// `xxxx`为目标寄存器的地址（十六进制）。</span><br></pre></td></tr></table></figure><p>2019年8月21日</p><hr><h2 id="DS1302-中的寄存器"><a href="#DS1302-中的寄存器" class="headerlink" title="DS1302 中的寄存器"></a>DS1302 中的寄存器</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程需要，学习DS1302的用法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MCS 51</title>
    <link href="http://wangyuyang.me/2019/08/06/MCS-51/"/>
    <id>http://wangyuyang.me/2019/08/06/MCS-51/</id>
    <published>2019-08-06T00:29:51.204Z</published>
    <updated>2019-12-05T13:20:03.958Z</updated>
    
    <content type="html"><![CDATA[<p>正式开始学习8051及C51。</p><h2 id="Cx51-的数据类型"><a href="#Cx51-的数据类型" class="headerlink" title="Cx51 的数据类型"></a>Cx51 的数据类型</h2><p>摘自<a href="http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm" target="_blank" rel="noopener">Cx51 User’s Guide</a><br><a id="more"></a> </p><table><thead><tr><th>Data Types</th><th>Bits</th><th>Bytes</th><th>Value Range</th></tr></thead><tbody><tr><td>bit</td><td>1</td><td></td><td>0 to 1</td></tr><tr><td>signed char</td><td>8</td><td>1</td><td>-128 — +127</td></tr><tr><td>unsigned char</td><td>8</td><td>1</td><td>0 — 255</td></tr><tr><td>enum</td><td>8 / 16</td><td>1 or 2</td><td>-128 — +127 or -32768 — +32767</td></tr><tr><td>signed short int</td><td>16</td><td>2</td><td>-32768 — +32767</td></tr><tr><td>unsigned short int</td><td>16</td><td>2</td><td>0 — 65535</td></tr><tr><td>signed int</td><td>16</td><td>2</td><td>-32768 — +32767</td></tr><tr><td>unsigned int</td><td>16</td><td>2</td><td>0 — 65535</td></tr><tr><td>signed long int</td><td>32</td><td>4</td><td>-2147483648 — +2147483647</td></tr><tr><td>unsigned long int</td><td>32</td><td>4</td><td>0 — 4294967295</td></tr><tr><td>float</td><td>32</td><td>4</td><td>±1.175494E-38 — ±3.402823E+38</td></tr><tr><td>double</td><td>32</td><td>4</td><td>±1.175494E-38 — ±3.402823E+38</td></tr><tr><td>sbit</td><td>1</td><td></td><td>0 or 1</td></tr><tr><td>sfr</td><td>8</td><td>1</td><td>0 — 255</td></tr><tr><td>sfr16</td><td>16</td><td>2</td><td>0 — 65535</td></tr></tbody></table><p>仔细看一下表，实际上Cx51对ANSI C是做了简化，在Cx51中，有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int = short int</span><br><span class="line">double = float</span><br></pre></td></tr></table></figure></p><p>2019年8月6日</p><hr><h2 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器 / 计数器"></a>定时器 / 计数器</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>51单片机内有两个16位定时器/计数器T0和T1，与之相关的特殊功能寄存器有三个，分别是：</p><ul><li>定时值存储寄存器 TH / TL</li><li>定时器控制寄存器 TCON</li><li>定时器模式寄存器 TMOD</li></ul><p>三种寄存器的功能也比较明显，看名字就知道，第一个用来设定定时器开始计数的初值；第二个控制定时器的启动/停止，此外还可以指示定时器是否发生溢出；最后一个寄存器指定定时器的工作模式，比如定时器模式和计数器模式、8/16位定时器等。</p><p>显然，由三个寄存器的功能可以看出，使用定时器的步骤（不使用中断）：</p><ol><li>设定TMOD参数    （指定是定时器还是计数器，以及定时器/计数器的工作模式，一般16位工作模式即可满足需求）</li><li>设定TH / TL的初始值    （有点类似数电课程设计里用74LS90和74LS192芯片做计数器）</li><li>设定TCON参数    （让定时器开始计数）</li><li>校验TCON参数</li></ol><p>事实上前三步已经实现了定时计数功能，但是，只通过前三步我们并不能知道计时是否已经结束。而TCON中的TF位可以指示定时器是否溢出（有点像计数器芯片里的借位输出端BO），通过检测TF变量的变化次数，就可以知道定时器发生了多少次溢出。而发生一次溢出所需要的时间是确定的（与TH / TL初值和时钟信号频率有关），因此很容易就知道定时器已经计数了多长时间。</p><p>其它补充知识：</p><ul><li>三个寄存器各位的复位值均为0。</li><li>TMOD不可位寻址，另外两种寄存器可位寻址。</li><li>TMOD中GATE置为0禁用定时器，置为1解除禁用状态。</li><li>16位定时器可应付几乎所有场景，此时直接令 TMOD = 0x01 即可。 </li><li>TCON的TR置为1后开始计数，置为0后暂停计数。</li><li>每次计数时，每经过一个机器周期，定时器值会增加1。</li><li>暂停计数时定时器的值不会被重置，还会保持暂停前的状态。</li></ul><p>附代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">char delay(unsigned int time)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入参数单位为毫秒</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;               <span class="comment">//清零TMOD低四位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;               <span class="comment">//设定T0为16位模式定时器</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;</span><br><span class="line">    TL0 = <span class="number">0x18</span>;                 <span class="comment">//设置定时器初始值，满足每次循环用时1ms</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                    <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF0 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;</span><br><span class="line">            TH0 = <span class="number">0xFC</span>;</span><br><span class="line">            TL0 = <span class="number">0x18</span>;         <span class="comment">//设置每次溢出后定时器初始值</span></span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面是使用查询法实现定时器定时功能，下面是利用中断来实现定时功能的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED0 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    TMOD = <span class="number">0x01</span>;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt_timer</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = <span class="number">0x0</span>;</span><br><span class="line">    TL0 = <span class="number">0x0</span>;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        LED0 = ~LED0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与查询法相比较，主要有以下几点不同之处：</p><ol><li>查询法中TF位需要在程序中手动置0，而在中断法中，一旦程序进入了中断函数，TF位会被自动置0。</li><li>查询法中用于统计溢出次数的变量count可以和定时函数封装在同一个函数中，而中断法中应将之申明为全局变量（因为中断函数禁止传参，见下文）。</li><li>中断函数不需要声明。</li></ol><p>2019年8月6日</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>就本质上来讲，定时器和计数器并没有太大的区别。唯一的区别在于，定时器是对机器周期进行计数，而计数器是对输入Tn的脉冲进行计数，二者使用方法几乎完全相同，只需将TMOD中的C/T位置1即可。<br>下附代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BEEP = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;           <span class="comment">//清零TMOD高四位</span></span><br><span class="line">    TMOD |= <span class="number">0x60</span>;           <span class="comment">//设定T1为8位自动重装模式计数器</span></span><br><span class="line">    TH1 = <span class="number">256</span> - number;</span><br><span class="line">    TL1 = <span class="number">256</span> - number;     <span class="comment">//设置计数器初始值，满足每计数十次即溢出</span></span><br><span class="line">    TR1 = <span class="number">1</span>;                <span class="comment">//开始计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TF1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TF1 = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            TH1 = <span class="number">256</span> - number;</span><br><span class="line">            TL1 = <span class="number">256</span> - number;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == number)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                BEEP = <span class="number">0</span>;   <span class="comment">//计数number次后蜂鸣提示</span></span><br><span class="line">                delay(<span class="number">50</span>);</span><br><span class="line">                BEEP = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end of if (TF1 == 1) </span></span><br><span class="line">    &#125;<span class="comment">//end of while (1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2019年8月10日</p><hr><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断的优先级有两种，当程序执行时，若低优先级中断执行时，发生了高优先级中断，则：</p><ul><li>固有优先级：处理完低优先级中断后才进入高优先级中断，即不发生中断嵌套。</li><li>抢占优先级：打断低优先级中断并立刻进入高优先级中断，处理完高优先级中断后，返回低优先级中断。</li></ul><p>根据<a href="http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm" target="_blank" rel="noopener">Cx51 User’s Guide</a>，8051内置六个标准中断源：</p><table><thead><tr><th>InterruptNumber</th><th>Description</th><th>Address</th></tr></thead><tbody><tr><td>0</td><td>EXTERNAL INT 0</td><td>0003h</td></tr><tr><td>1</td><td>TIMER/COUNTER 0</td><td>000Bh</td></tr><tr><td>2</td><td>EXTERNAL INT 1</td><td>0013h</td></tr><tr><td>3</td><td>TIMER/COUNTER 1</td><td>001Bh</td></tr><tr><td>4</td><td>SERIAL PORT</td><td>0023h</td></tr><tr><td>5</td><td>TIMER/COUNTER 2 (8052)</td><td>002Bh</td></tr></tbody></table><p>与之相关的寄存器有两个（参考STC89C52的datasheet中 图6-1 STC89C52系列中断系统结构图）：</p><ul><li>中断允许控制寄存器        IE，XICON寄存器</li><li>中断优先级控制寄存器      IP，XICON，IPH寄存器</li></ul><blockquote><p>注：XICON，IPH寄存器为STC89C52独有，可实现4个中断优先级，而传统的8051单片机只能实现2级中断优先级</p></blockquote><p>显然，由中断相关寄存器的名称可以知道，要想使用中断，首先要在中断允许寄存器中启用中断功能，然后调整中断优先级寄存器中优先级的设定（也可不调整直接使用默认优先级）。</p><p>当单片机收到中断信息后，应当转去执行中断信息的处理程序，但是单片机是如何根据中断信息找到处理程序的入口呢？显然，在单片机内部，中断信息和其处理程序建立了某种联系。上表中每一个中断源都对应唯一的一个InterruptNumber——中断类型码，单片机会根据中断类型码，在中断向量表中找到对应的处理程序入口地址，进而开始执行中断服务程序。</p><p><em>2019年10月22日更新</em><br>这里中断向量实际上就是指中断服务程序的入口地址（知乎上有对中断向量为什么叫中断向量的讨论），满足：<code>中断向量 = 中断号 * 8 + 3</code>，加3是为了为LJMP指令（三字节指令）留出足够的空间，从而使单片机复位后能通过0000H处的LJMP指令正确的跳转到程序的起始位置，否则复位后就会进入中断。</p><p>至于为什么中断向量全部间隔8个单元而不是3个，这个问题有待以后了解。</p><h3 id="中断允许控制寄存器"><a href="#中断允许控制寄存器" class="headerlink" title="中断允许控制寄存器"></a>中断允许控制寄存器</h3><p><em>IE: Interrupt Enable  中断允许寄存器  可位寻址</em><br><em>Adress: A8H</em></p><p>单片机对任意中断源是否做出响应均由该寄存器进行控制。</p><ul><li>EA 总中断控制位</li><li>ET0 定时器/计数器 0 中断允许位</li><li>ET1 定时器/计数器 1 中断允许位</li><li>EX0 外部中断 0 中断允许位</li><li>EX1 外部中断 1 中断允许位</li><li>ES 串行口中断允许位</li></ul><p>置1为允许中断，置0为禁止中断。</p><h3 id="中断优先级控制寄存器"><a href="#中断优先级控制寄存器" class="headerlink" title="中断优先级控制寄存器"></a>中断优先级控制寄存器</h3><p><em>IP: Interrupt Priority  中断优先级寄存器  可位寻址</em><br><em>Adress: B8H</em></p><p>各个中断源属于两级中断中的哪一级由该寄存器控制。</p><ul><li>PT0 定时器/计数器 0 中断优先级控制位</li><li>PT1 定时器/计数器 1 中断优先级控制位</li><li>PX0 外部中断 0 中断优先级控制位</li><li>PX1 外部中断 1 中断优先级控制位</li><li>PS 串行口中断优先级控制位</li></ul><p>置1为高优先级中断，置0为低优先级中断。</p><p>若两中断源被设定为相同优先级，当两中断源同时请求中断时，按照默认优先级别响应中断。</p><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>中断函数的调用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function_Name</span><span class="params">()</span> interrupt Interrupt_Number <span class="keyword">using</span> Register_Bank</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中<code>Interrupt_Number</code>参考上表，无论是否为默认优先级，该值均不变。<br><code>using Register_Bank</code>语句可省略。</p><p>即使中断函数写在main函数后面，也不需要在main函数前先对中断函数进行声明。</p><p>如果定义两个中断处理函数时，使他们能对同一个中断源进行响应（如两个函数声明时使用了相同的中断向量<code>interrupt 0</code>），那么程序在执行时会发生什么？<br>测试了一下，这样的程序能够通过Keil编译（虽然会有警告<code>WARNING L5: CODE SPACE MEMORY OVERLAP</code>，实际上Keil的官方文档中，<a href="http://www.keil.com/support/docs/839.htm" target="_blank" rel="noopener">对WARING L5的描述</a>也提到了这种情况，但并未说明后果），暂未测试实际执行情况。</p><p>一些关于中断函数的注意事项：</p><blockquote><p>No function arguments may be specified for an interrupt function. The compiler emits an error message if an interrupt function is declared with any arguments.<br>声明中断函数时不能有参数，否则编译器会报错。</p><p>Interrupt function declarations may not include a return value. They must be declared as void. The compiler emits an error message if any attempt is made to define a return value for the interrupt function. The implicit int return value, however, is ignored by the compiler.<br>声明中断函数时不能包含返回值。中断函数必须声明为 void 类型。对于任何试图将中断函数声明为有返回值类型的函数的行为，编译器都会报错。不过，如果返回值为隐式 int 类型则会被编译器忽略。</p><p>The compiler recognizes direct calls to interrupt functions and rejects them. It is pointless to call interrupt procedures directly, because exiting the procedure causes execution of the RETI instruction which affects the hardware interrupt system of the 8051 chip. Because no interrupt request on the part of the hardware existed, the effect of this instruction is indeterminate and usually fatal. Do not call an interrupt function indirectly through a function pointer.<br>编译器会识别到任何对中断函数的直接调用并报错。直接调用中断程序是没有意义的，因为退出程序会导致RETI指令的执行， 从而影响8051芯片的硬件中断系统。由于硬件部分并没有中断请求，因此该指令的效果是不确定的，通常是致命的。不要通过函数指针间接调用中断函数。</p><p>The Cx51 Compiler allows interrupt numbers within the 0-31 range. Refer to your 8051 derivative document to determine which interrupts are available.<br>Cx51编译器允许0-31范围内的中断位。请参阅8051衍生文档以确定可用的中断。</p></blockquote><p>2019年8月7日 七夕</p><hr><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>通信可以分为两大类：</p><ul><li>串行传输：一次发送/接收一个位<ul><li>异步传输</li><li>同步传输</li><li>等时传输</li></ul></li><li>并行传输：一次发送/接收多个位</li></ul><p>以8051为例，8051的RXD和TXD口一次只能接收/发送一个位，为串行传输。<br>以8086为例，8086的数据总线宽度为16，一次可以向内存中读取/写入16位数据，为并行传输。</p><p>直觉上觉得并行传输速度快，更先进。查了一下结果发现居然还真不是这样，串行传输反而有取代并行传输的趋势。</p><p>PCI和PATA都是并行传输，家里十几年前买的电脑里用的非常宽的硬盘线就是PATA接口，现在已经被淘汰。<br>PCI Express（即PCIe）和SATA均为串行传输，笔记本里的Intel 530和Samsung 860EVO就分别是PCIe和SATA接口，体积很小，但速度依然很快。</p><p>串行通信制式的概念：</p><ul><li>单工：接收端和发送端固定，数据只能从发送端传输到接收端，二者只需一条线连接即可。</li><li>半双工：在某一时刻接收端和发送端是固定的，即一次数据传输时一定有一个为接收端，另一个为发送端。二者地位可互换。二者需要一条信号线和一条接地线连接。</li><li>全双工：在任一时刻接收端和发送端都可变，即两个设备都可以同时接收和发送数据。二者需要一条接地线和两条信号线连接。</li></ul><p><a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87" target="_blank" rel="noopener">比特率（Bit rate）</a>：指单位时间内传输送或处理的比特的数量，规定使用“比特每秒”（bit/s或bps）为单位。</p><p>对于单片机而言，波特率数值大小不同于单片机发送或者接收数据的时钟频率，波特率大小可以是单片机时钟频率的1/16或者1/64。</p><h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><em>Universal asynchronous receiver-transmitter 通用异步收发传输器</em></p><p>UART是什么？摘自<a href="http://www.circuitbasics.com/basics-uart-communication/" target="_blank" rel="noopener">这里</a>：</p><blockquote><p>UART stands for Universal Asynchronous Receiver/Transmitter. It’s not a communication protocol like SPI and I2C, but a physical circuit in a microcontroller, or a stand-alone IC. A UART’s main purpose is to transmit and receive serial data.</p></blockquote><p>简单地说，UART不是具体的某一个独立的芯片，而是一种异步串行通信的方式，但这种方式还不能称之为“通信协议”。<br><del>其实我觉得这不就是一种通信协议么…</del></p><p>UART通信只需要两个接口：</p><ul><li>RXD 串行接收引脚</li><li>TXD 串行发送引脚</li></ul><p><del>RXD和TXD中的X有什么含义？</del></p><p>显然，在进行UART通信时，要将一个设备的RXD端和另一个设备的TXD端连接。</p><p>前面提到，UART是一种异步通信，这意味着没有时钟信号两设备上的让RXD和TXD保持同步。为了保证RXD能够完整的接收到所有数据，传输数据时要满足的条件和步骤大致如下：</p><ul><li>数据以数据包的形式传送，数据包的结构是可以修改的，只需提前在数据接收方和发送方处设置好即可。</li><li>数据接收方和发送方的通信波特率应保持一致。</li><li>通信未开始时，线路保持高电平。</li><li>通信开始时，TXD首先发送一位0（低电平）作为起始位通知接收方开始传输数据。</li><li>发送数据。</li><li>发送一位1作为停止位，完成一个数据包的传输。</li></ul><p><del>终于知道以前用PN532时连的线是干啥用的了</del></p><h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p><em>Recommended Standard 232 RS-232</em></p><p><a href="https://zh.wikipedia.org/wiki/RS-232" target="_blank" rel="noopener">RS-232</a>是美国电子工业联盟（EIA）制定的串行数据通信的接口标准，原始编号全称是EIA-RS-232。它被广泛用于计算机串行接口外设连接。</p><p>RS-232接口最初规定为25个引脚，但大部分设备进行了简化，只使用了其中的9个引脚：</p><table><thead><tr><th>Pin</th><th>Abbreviation</th><th>Name</th></tr></thead><tbody><tr><td>Pin1</td><td>DCD</td><td>Data Carrier Detect</td></tr><tr><td>Pin2</td><td>RXD</td><td>Receiver</td></tr><tr><td>Pin3</td><td>TXD</td><td>Transmit</td></tr><tr><td>Pin4</td><td>DTR</td><td>Data Terminal Ready</td></tr><tr><td>Pin5</td><td>GND</td><td>Ground</td></tr><tr><td>Pin6</td><td>DSR</td><td>Data Set Ready</td></tr><tr><td>Pin7</td><td>RTS</td><td>Request To Send</td></tr><tr><td>Pin8</td><td>CTS</td><td>Clear To Send</td></tr><tr><td>Pin9</td><td>RI</td><td>Ring Indicator</td></tr></tbody></table><p>需要注意的是，RS-232标准采用的电平为RS-232电平而不是TTL电平，RS-232电平为负逻辑电平，即-15V~-3V代表逻辑”1”，+3V~+15V代表逻辑”0”。<br>可使用MAX232芯片进行转换。</p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p><em>Universal Serial Bus 通用串行总线</em></p><p><a href="https://zh.wikipedia.org/wiki/USB" target="_blank" rel="noopener">USB</a>已经非常熟悉了，其USB接口类型有很多：</p><ul><li>Standard<ul><li>Type-A</li><li>Type-A SuperSpeed</li><li>Type-B</li><li>Type-B SuperSpeed</li><li>Type-C</li></ul></li><li>Mini<ul><li>Mini-A</li><li>Mini-B</li><li>Mini-AB </li></ul></li><li>Micro<ul><li>Micro-A</li><li>Micro-B</li><li>Micro-B SuperSpeed</li><li>Micro-AB</li></ul></li></ul><p>在上述接口中，含SuperSpeed后缀的接口以及Type-C接口均支持USB3.0标准，其余仅支持USB2.0标准。<br><del>转眼间USB4.0标准就要公布了，时间过得真快</del></p><p>Type-A SuperSpeed和Type-B SuperSpeed接口一般为蓝色。</p><p>同类型的接口可以混插，如Type-A接头可以插入Type-A SuperSpeed接口中，反过来也一样。</p><p>不同的接口引脚数往往不同，但所有的接口一定有以下四个引脚（其实核心也就是Pin 3和Pin 4）：</p><table><thead><tr><th>Pin</th><th>Name</th><th>Cable color</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>VCC</td><td>Red</td><td>+5 VDC</td></tr><tr><td>2</td><td>D-</td><td>White</td><td>Data -</td></tr><tr><td>3</td><td>D+</td><td>Green</td><td>Data +</td></tr><tr><td>4</td><td>GND</td><td>Black</td><td>Ground</td></tr></tbody></table><p><em>摘自<a href="https://pinouts.ru/Slots/USB_pinout.shtml" target="_blank" rel="noopener">USB pinout</a></em></p><p>Type-A和Type-B接口有且仅有这四个引脚。</p><p>Type-A SuperSpeed的引脚如下，可以看到虽然多了5个引脚，但1-4引脚依然存在。</p><table><thead><tr><th>PinNumber</th><th>PinName</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>VBus</td><td>+5V Power</td></tr><tr><td>2</td><td>USB D-</td><td>USB 2.0 data</td></tr><tr><td>3</td><td>USB D+</td><td></td></tr><tr><td>4</td><td>GND</td><td>Ground for power return</td></tr><tr><td>5</td><td>StdA_SSRX-</td><td>SuperSpeed receiver</td></tr><tr><td>6</td><td>StdA_SSRX+</td><td>SuperSpeed receiver</td></tr><tr><td>7</td><td>GND_DRAIN</td><td>Ground for signal return</td></tr><tr><td>8</td><td>StdA_SSTX-</td><td>SuperSpeed transmitter</td></tr><tr><td>9</td><td>StdA_SSTX+</td><td>SuperSpeed transmitter</td></tr></tbody></table><p>USB标准采用的电平依然不是TTL电平，其D-和D+引脚传输的是差分信号。可使用<a href="http://www.winchiphead.com/download/CH340/CH340DS1.PDF" target="_blank" rel="noopener">CH340</a>芯片进行转换。</p><p>2019年8月8日 立秋</p><h3 id="串行口控制寄存器"><a href="#串行口控制寄存器" class="headerlink" title="串行口控制寄存器"></a>串行口控制寄存器</h3><p><em>SCON: Serial Control 串行口控制寄存器 可位寻址</em><br><em>Address: 98H</em></p><p>类似TCON，控制串口的工作模式及指示串口状态。</p><ul><li>RI 接收中断标志位</li><li>TI 发送中断标志位</li><li>RB8 模式 2 和 3 中接收到的第九位数据</li><li>TB8 模式 2 和 3 中要发送的第九位数据</li><li>REN 使能串行接收</li><li>SM2 多机通信控制位</li><li>SM1 控制工作模式</li><li>SM0 控制工作模式</li></ul><h3 id="串行口数据缓冲寄存器"><a href="#串行口数据缓冲寄存器" class="headerlink" title="串行口数据缓冲寄存器"></a>串行口数据缓冲寄存器</h3><p><em>SBUF: Serial Buffer 串行口数据缓冲寄存器 不可位寻址</em><br><em>Adress: 99H</em></p><p>表面上SBUF是一个寄存器，但其实它是由一个只读寄存器和一个只写寄存器构成的。使用时并不需要选择具体使用哪一个寄存器，当对SBUF作读操作时，单片机会自动调用只读寄存器。反过来，当程序对SBUF作写操作时，单片机会自动调用只写寄存器。</p><p>看起来挺复杂，实际上SBUF的工作原理也挺简单的，STC89C52RC的datasheet写的很详细：</p><blockquote><p>······在写入SBUF信号的控制下，把数据装入相同的9位移位寄存器，前面8位为数据字节，其最低位为移位寄存器的输出位。根据不同的工作方式会自动将“1”或TB8的值装入移位寄存器的第9位，并进行发送。</p><p>串行通道的接收寄存器是一个输入移位寄存器。在方式0时它的字长为8位，其他方式时位9位。当一帧接收完毕，移位寄存器中的数据字节装入串行数据缓冲器SBUF中，其第9位则装入SCON寄存器中的RB8位。如果由于SM2使得已接受到的数据无效时，RB8和SBUF中的内容不变。</p><p>由于接收通道内设有输入移位寄存器和SBUF缓冲器，从而能使一帧接收完将数据由移位寄存器装入SBUF后，可立即接收下一帧信息，主机应在该帧接收结束前从SBUF缓冲器中将数据取走，否则前一帧数据将丢失。SBUF以并行方式送往内部数据总线。</p></blockquote><h3 id="串口通信的具体实现"><a href="#串口通信的具体实现" class="headerlink" title="串口通信的具体实现"></a>串口通信的具体实现</h3><p>步骤大致如下：</p><ol><li>配置串行口控制寄存器SCON</li><li>配置定时器 T1 为自动重装模式，禁用 T1 中断</li><li>根据baud计算TH1、TL1初值</li><li>TR1置1，启动定时器</li></ol><p>2019年8月14日</p><h3 id="两种不同的换行符"><a href="#两种不同的换行符" class="headerlink" title="两种不同的换行符"></a>两种不同的换行符</h3><p>在VS Code右下角可以选择行尾序列LF或CRLF，一直以来只知道是两种不同的换行符但没有去深入了解。但在用8051做串口通讯时遇到了问题，直接发送ASCII表的第十一位LF（0x10）时上位机显示的文本并未将其理解为换行符，于是去查了一些相关资料：</p><p>不同的编辑器使用的换行符往往不同，这是一个历史问题。采用的换行标记一般为以下五种，后两种挺少见的，可以忽略：</p><ul><li>ASCII standard<ul><li>LF: line feed 换行</li><li>CR: carriage return 回车</li><li>CRLF: carriage return + line feed 换行 + 回车</li></ul></li><li>Unicode standard<ul><li>LS: Line Separator</li><li>PS: Paragraph Separator</li></ul></li></ul><p>多数Unix和类Unix系统（macOS、Linux、FreeBSD etc.）都使用LF作为换行符。而Windows系统使用的换行符是CRLF，选择二者组合的原因还挺有意思的，这和上世纪时广泛使用的电传打印机(teleprinter)有关。</p><p>这篇文章<a href="https://devblogs.microsoft.com/oldnewthing/?p=40193" target="_blank" rel="noopener">Why is the line terminator CR+LF?</a>对原因解释的很清楚：</p><blockquote><p>This protocol dates back to the days of teletypewriters.</p><p>CR stands for “carriage return” – the CR control character returned the print head (“carriage”) to column 0 without advancing the paper. LF stands for “linefeed” – the LF control character advanced the paper one line without moving the print head.So if you wanted to return the print head to column zero (ready to print the next line) and advance the paper (so it prints on fresh paper), you need both CR and LF.</p><p>If you go to the various internet protocol documents, such as RFC 0821 (SMTP), RFC 1939 (POP), RFC 2060 (IMAP), or RFC 2616 (HTTP), you’ll see that they all specify CR+LF as the line termination sequence.</p><p>So the the real question is not “Why do CP/M, MS-DOS, and Win32 use CR+LF as the line terminator?” but rather “Why did other people choose to differ from these standards documents and use some other line terminator?”</p></blockquote><p>读到这自然也会好奇为什么C语言中只使用<code>\n</code>就能实现换行，事实上这篇文章也提到了原因：</p><blockquote><p>The unix ancestry of the C language carried this convention into the C language standard, which requires only “\n” (which encodes LF) to terminate lines, putting the burden on the runtime libraries to convert raw file data into logical lines.</p><p>The C language also introduced the term “newline” to express the concept of “generic line terminator”. I’m told that the ASCII committee changed the name of character 0x0A to “newline” around 1996, so the confusion level has been raised even higher.</p></blockquote><p>2019年8月15日</p><hr><h2 id="Cx51中的坑"><a href="#Cx51中的坑" class="headerlink" title="Cx51中的坑"></a>Cx51中的坑</h2><p>不到十行的程序莫名其妙的报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C141: syntax error near &apos;int&apos;, expected &apos;__asm&apos;</span><br></pre></td></tr></table></figure></p><p>翻来覆去看对应的语句，怎么都没找到错误，查了一下才知道到底是什么问题。</p><p>确切的讲，这个问题是C89的锅，C89规定变量必须声明在块的开头，也就是其他执行语句的前面。而C99标准放宽了这一限制。</p><p>2019年8月9日</p><hr><h2 id="MCS-51的寻址方式"><a href="#MCS-51的寻址方式" class="headerlink" title="MCS-51的寻址方式"></a>MCS-51的寻址方式</h2><p>一共有七种寻址方式：</p><ul><li>直接寻址</li><li>立即寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>基址寄存器加变址寄存器间接寻址</li><li>相对寻址</li><li>位寻址</li></ul><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址的概念比较简单，就是该指令执行时会从寄存器中读取一个立即数。立即数是编写程序时写入程序指令的常数。为了区分这个数是操作数（即参与运算的数）还是地址，会在这个数字之前加上<code>#</code>标志，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, #30H</span><br></pre></td></tr></table></figure><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>顾名思义，直接在指令中给出操作数的真实地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, 30H</span><br></pre></td></tr></table></figure><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>寄存器寻址，其实就是，假定有一个立即数存放在工作寄存器里，然后从该工作寄存器读取这个立即数的过程就是寄存器寻址，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R1</span><br></pre></td></tr></table></figure><p>至于R1属于哪一个工作寄存器区，这个由执行该语句时，PSW寄存器中的RS1和RS0的值来决定。</p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器间接寻址的概念很类似于C语言中的指针，先看下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, R1</span><br></pre></td></tr></table></figure><p>显然，该语句为上面所提到的寄存器寻址，单片机首先从R1中读取一个数，并认为这个数是立即数，然后将这个数储存到A中。而对于下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A, @R1</span><br></pre></td></tr></table></figure><p>则是指：单片机从R1中读取一个数，但认为这个数不是一个立即数，而是指向另一个存储单元的地址。单片机会继续到这个存储单元去读取保存在里面的数据，并把这个数保存在累加器A中。</p><h3 id="基址寄存器加变址寄存器间接寻址"><a href="#基址寄存器加变址寄存器间接寻址" class="headerlink" title="基址寄存器加变址寄存器间接寻址"></a>基址寄存器加变址寄存器间接寻址</h3><p>名字很长，但是联系到8086汇编就很容易理解了，说白了就是把段地址+偏移地址的模式稍微简化一下，不对段地址进行移位操作，而是直接和偏移地址相加，没什么意思。</p><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>这个就更简单了，就是说，假如程序执行到了语句X，现在想跳转到X前面的某一个语句或者后面的某一个语句，那么就可以用相对寻址来实现。这个就有点类似于C语言里的goto语句（复习一下，goto语句的标签具有函数作用域）。</p><p>只不过更准确的说，相对寻址改变的是程序计数器PC中的值，进而实现语句跳转。</p><h3 id="位寻址"><a href="#位寻址" class="headerlink" title="位寻址"></a>位寻址</h3><p>位寻址的概念已经很熟悉了，C51里就已经经常使用，还有一个相对的概念是“不可位寻址”。</p><p>现在可以回过头来看一看<code>reg52.h</code>里都有哪些内容了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">REG52.H</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Header file for generic 80C52 and 80C32 microcontroller.</span></span><br><span class="line"><span class="comment">Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.</span></span><br><span class="line"><span class="comment">All rights reserved.</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __REG52_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __REG52_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BYTE Registers  */</span></span><br><span class="line">sfr P0    = <span class="number">0x80</span>;</span><br><span class="line">sfr P1    = <span class="number">0x90</span>;/</span><br><span class="line">sfr P2    = <span class="number">0xA0</span>;</span><br><span class="line">sfr P3    = <span class="number">0xB0</span>;/</span><br><span class="line">sfr PSW   = <span class="number">0xD0</span>;/</span><br><span class="line">sfr ACC   = <span class="number">0xE0</span>;</span><br><span class="line">sfr B     = <span class="number">0xF0</span>;</span><br><span class="line">sfr SP    = <span class="number">0x81</span>;</span><br><span class="line">sfr DPL   = <span class="number">0x82</span>;</span><br><span class="line">sfr DPH   = <span class="number">0x83</span>;</span><br><span class="line">sfr PCON  = <span class="number">0x87</span>;</span><br><span class="line">sfr TCON  = <span class="number">0x88</span>;/</span><br><span class="line">sfr TMOD  = <span class="number">0x89</span>;</span><br><span class="line">sfr TL0   = <span class="number">0x8A</span>;</span><br><span class="line">sfr TL1   = <span class="number">0x8B</span>;</span><br><span class="line">sfr TH0   = <span class="number">0x8C</span>;</span><br><span class="line">sfr TH1   = <span class="number">0x8D</span>;</span><br><span class="line">sfr IE    = <span class="number">0xA8</span>;/</span><br><span class="line">sfr IP    = <span class="number">0xB8</span>;/</span><br><span class="line">sfr SCON  = <span class="number">0x98</span>;/</span><br><span class="line">sfr SBUF  = <span class="number">0x99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  8052 Extensions  */</span></span><br><span class="line">sfr T2CON  = <span class="number">0xC8</span>;/</span><br><span class="line">sfr RCAP2L = <span class="number">0xCA</span>;</span><br><span class="line">sfr RCAP2H = <span class="number">0xCB</span>;</span><br><span class="line">sfr TL2    = <span class="number">0xCC</span>;</span><br><span class="line">sfr TH2    = <span class="number">0xCD</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  BIT Registers  */</span></span><br><span class="line"><span class="comment">/*  PSW  */</span></span><br><span class="line">sbit CY    = PSW^<span class="number">7</span>;</span><br><span class="line">sbit AC    = PSW^<span class="number">6</span>;</span><br><span class="line">sbit F0    = PSW^<span class="number">5</span>;</span><br><span class="line">sbit RS1   = PSW^<span class="number">4</span>;</span><br><span class="line">sbit RS0   = PSW^<span class="number">3</span>;</span><br><span class="line">sbit OV    = PSW^<span class="number">2</span>;</span><br><span class="line">sbit P     = PSW^<span class="number">0</span>; <span class="comment">//8052 only</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  TCON  */</span></span><br><span class="line">sbit TF1   = TCON^<span class="number">7</span>;</span><br><span class="line">sbit TR1   = TCON^<span class="number">6</span>;</span><br><span class="line">sbit TF0   = TCON^<span class="number">5</span>;</span><br><span class="line">sbit TR0   = TCON^<span class="number">4</span>;</span><br><span class="line">sbit IE1   = TCON^<span class="number">3</span>;</span><br><span class="line">sbit IT1   = TCON^<span class="number">2</span>;</span><br><span class="line">sbit IE0   = TCON^<span class="number">1</span>;</span><br><span class="line">sbit IT0   = TCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IE  */</span></span><br><span class="line">sbit EA    = IE^<span class="number">7</span>;</span><br><span class="line">sbit ET2   = IE^<span class="number">5</span>; <span class="comment">//8052 only</span></span><br><span class="line">sbit ES    = IE^<span class="number">4</span>;</span><br><span class="line">sbit ET1   = IE^<span class="number">3</span>;</span><br><span class="line">sbit EX1   = IE^<span class="number">2</span>;</span><br><span class="line">sbit ET0   = IE^<span class="number">1</span>;</span><br><span class="line">sbit EX0   = IE^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  IP  */</span></span><br><span class="line">sbit PT2   = IP^<span class="number">5</span>;</span><br><span class="line">sbit PS    = IP^<span class="number">4</span>;</span><br><span class="line">sbit PT1   = IP^<span class="number">3</span>;</span><br><span class="line">sbit PX1   = IP^<span class="number">2</span>;</span><br><span class="line">sbit PT0   = IP^<span class="number">1</span>;</span><br><span class="line">sbit PX0   = IP^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P3  */</span></span><br><span class="line">sbit RD    = P3^<span class="number">7</span>;</span><br><span class="line">sbit WR    = P3^<span class="number">6</span>;</span><br><span class="line">sbit T1    = P3^<span class="number">5</span>;</span><br><span class="line">sbit T0    = P3^<span class="number">4</span>;</span><br><span class="line">sbit INT1  = P3^<span class="number">3</span>;</span><br><span class="line">sbit INT0  = P3^<span class="number">2</span>;</span><br><span class="line">sbit TXD   = P3^<span class="number">1</span>;</span><br><span class="line">sbit RXD   = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  SCON  */</span></span><br><span class="line">sbit SM0   = SCON^<span class="number">7</span>;</span><br><span class="line">sbit SM1   = SCON^<span class="number">6</span>;</span><br><span class="line">sbit SM2   = SCON^<span class="number">5</span>;</span><br><span class="line">sbit REN   = SCON^<span class="number">4</span>;</span><br><span class="line">sbit TB8   = SCON^<span class="number">3</span>;</span><br><span class="line">sbit RB8   = SCON^<span class="number">2</span>;</span><br><span class="line">sbit TI    = SCON^<span class="number">1</span>;</span><br><span class="line">sbit RI    = SCON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  P1  */</span></span><br><span class="line">sbit T2EX  = P1^<span class="number">1</span>; <span class="comment">// 8052 only</span></span><br><span class="line">sbit T2    = P1^<span class="number">0</span>; <span class="comment">// 8052 only</span></span><br><span class="line">             </span><br><span class="line"><span class="comment">/*  T2CON  */</span></span><br><span class="line">sbit TF2    = T2CON^<span class="number">7</span>;</span><br><span class="line">sbit EXF2   = T2CON^<span class="number">6</span>;</span><br><span class="line">sbit RCLK   = T2CON^<span class="number">5</span>;</span><br><span class="line">sbit TCLK   = T2CON^<span class="number">4</span>;</span><br><span class="line">sbit EXEN2  = T2CON^<span class="number">3</span>;</span><br><span class="line">sbit TR2    = T2CON^<span class="number">2</span>;</span><br><span class="line">sbit C_T2   = T2CON^<span class="number">1</span>;</span><br><span class="line">sbit CP_RL2 = T2CON^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>2019年9月18日</p><hr><h2 id="MCS-51-的存储器结构"><a href="#MCS-51-的存储器结构" class="headerlink" title="MCS-51 的存储器结构"></a>MCS-51 的存储器结构</h2><p>学习8086汇编时，可以了解到8086采用的是Von Neumann架构，正如王爽在《汇编语言》中反复强调的一样，指令和数据是完全相同的概念，程序和数据共用同一条总线。</p><p>不同于8086，一般认为，MCS-51是采用Harvard架构的MCU，其程序存储器（ROM）和数据存储器（RAM）的Adress Space相互独立。</p><p>扩展阅读：<a href="https://www.zhihu.com/question/22406681/answer/21264994" target="_blank" rel="noopener">为什么电脑还沿用冯·诺伊曼结构而不使用哈佛结构？</a></p><p>从物理上分，即从电路的实际物理结构来区分，MCS-51的存储空间可分为四个部分：</p><ul><li>程序存储器<ul><li>片内程序存储器</li><li>片外程序存储器</li></ul></li><li>数据存储器<ul><li>片内数据存储器</li><li>片外数据存储器</li></ul></li></ul><p>从逻辑上分，即按照实际使用时的角度来区分，则可分为三个部分：</p><ul><li>程序存储器（片内片外统一编址）</li><li>数据存储器（片内片外独立编址）<ul><li>片内数据存储器</li><li>片外数据存储器</li></ul></li></ul><p>这里又牵扯出了两个概念——统一编址和独立编址。<br>实际上是很简单的概念，可参考<a href="https://blog.csdn.net/zhandoushi1982/article/details/5976898" target="_blank" rel="noopener">内存和外设的统一编址及独立编址</a>和<a href="https://www.cnblogs.com/armlinux/archive/2010/11/26/2396888.html" target="_blank" rel="noopener">理解“统一编址与独立编址、I/O端口与I/O内存”</a></p><h3 id="MCS-51-的程序存储器"><a href="#MCS-51-的程序存储器" class="headerlink" title="MCS-51 的程序存储器"></a>MCS-51 的程序存储器</h3><p>MCS-51的程序计数器是16位，即地址空间可达2^16 bit = 64KB。</p><p>正常工作模式下（即<span style="TEXT-DECORATION: overline">EA</span>端接高电平），PC从内部ROM的0x0000开始计数。当PC的值大于0x0FFF时，会自动转至片外程序存储器的0x1000处，直到片外存储器的0xFFFF为止。所以逻辑上对片内程序存储器和片外程序存储器不做区分。</p><p>不过实际使用时，为了某些特殊目的，还可以将<span style="TEXT-DECORATION: overline">EA</span>端接低电平，此时单片机会直接从片外ROM的0x0000开始计数，而不再使用片内程序存储器。</p><p>程序存储器中有七个地址较为特殊，分别为复位时PC指向的地址0000H和六个中断源入口地址（参见中断部分内容）。</p><h3 id="MCS-51-的数据存储器"><a href="#MCS-51-的数据存储器" class="headerlink" title="MCS-51 的数据存储器"></a>MCS-51 的数据存储器</h3><p>正如前面提到的那样，MCS-51单片机的片内、片外数据存储器是独立编址的。</p><ul><li>片内数据存储器的地址空间：0x00 ~ 0xFF</li><li>片外数据存储器的地址空间：0x0000 ~ 0xFFFF</li></ul><p>对于MCS-51系列的MCU而言，片内数据存储器又可以分为两块：</p><ul><li>0x00 ~ 0x7F: 工作寄存器区 + 位寻址区 + 数据缓冲区</li><li>0x80 ~ 0xFF: 特殊功能寄存器SFR</li></ul><p>而对于MCS-52系列的MCU，实际上有两块区域被映射到了0x80 ~ 0xFF的地址空间，即可认为这两块区域是独立编址的。这两块区域一个是特殊功能寄存器SFR块，另一个则是一个普通的数据存储器块。</p><p>这两块区域有着完全相同的地址，那么实际在写程序时，如何才能区分这两块区域呢？这个是通过不同的寻址方式实现的，访问SFR块必须采用直接寻址的方式，而访问重叠部分的普通RAM则采用寄存器间接寻址来实现。</p><p>工作寄存器区一共分为四个区（0区~3区，首地址分别为0、8、16和24），对应四个通用寄存器组。每个通用寄存器组由8个通用寄存器R0~R7构成，使用时具体访问哪一组通用寄存器由PSW寄存器中的RS1和RS0决定。</p><p>这里就可以回答一个问题，为什么51单片机上电复位后堆栈指针SP指向0007H而不是0000H？</p><p>这是因为，单片机上电复位后，PSW寄存器被重置为0x00，因此也就是默认选择了工作寄存器区0区。因此通用寄存器R0~R7被映射到了地址0x00~0x07，为了避免进行堆栈操作时将该区域的数据破坏，故将堆栈指针SP复位值设计为0007H。</p><p>复位后CPU内部RAM的各单元内容<strong>并不会</strong>被清除，但长时间掉电会造成数据存储器内数据的丢失。</p><p>位寻址区就是指该区域中的每一位均可位寻址，需要注意的就是RAM中并不是只有该区域可以位寻址，SFR中的部分单元也可位寻址。</p><p>用户RAM区，需要注意的就是在汇编时，要把单片机的堆栈指针SP指向该区域。否则由于SP复位后指向0007H，在栈向上生长时会破坏工作寄存器区（1区~3区）和位寻址区内的数据。</p><h3 id="Keil-uVision5-查看和修改程序-数据存储器"><a href="#Keil-uVision5-查看和修改程序-数据存储器" class="headerlink" title="Keil uVision5 查看和修改程序\数据存储器"></a>Keil uVision5 查看和修改程序\数据存储器</h3><p>进入调试状态后点击Memory Window，并在Address内填入对应地址即可查看存储器内数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看 ROM 的 CODE 区</span></span><br><span class="line">C:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 DATA 区</span></span><br><span class="line">D:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片内 RAM 的 IDATA 区</span></span><br><span class="line">I:<span class="number">0x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看片外 RAM 的 XDATA 区</span></span><br><span class="line">X:<span class="number">0x00</span></span><br></pre></td></tr></table></figure><ul><li>code 代码存储区</li><li>data 直接寻址片内数据存储区</li><li>bdata 可位寻址片内数据存储区</li><li>idata 间接寻址片内数据存储区</li><li>pdata 分页寻址片外数据存储区</li><li>xdata 片外数据存储区</li></ul><p>关于code、idata等详细含义，可查看<a href="http://www.keil.com/support/man/docs/c51/c51_le_memtypes.htm" target="_blank" rel="noopener">Memory Types</a><br>2019年10月7日 重阳节</p><hr><h2 id="MCS-51的伪指令"><a href="#MCS-51的伪指令" class="headerlink" title="MCS-51的伪指令"></a>MCS-51的伪指令</h2><p>伪指令主要有以下八个：</p><ul><li>ORG</li><li>END</li><li>DB</li><li>DW</li><li>DS</li><li>EQU</li><li>DATA</li><li>BIT</li></ul><p>这八条指令大致可分为三类，下分类记录。</p><h3 id="ORG和END"><a href="#ORG和END" class="headerlink" title="ORG和END"></a>ORG和END</h3><p><code>ORG</code>指令指定了其后面第一条指令在ROM中存储时的起始位置，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG 0030H</span><br><span class="line">INC A</span><br></pre></td></tr></table></figure><p>这里<code>INC A</code>在ROM中就是从0030H开始存储的。</p><p>顺便复习一下标号，标号是代表着其后面第一条指令的地址，因此下面两种写法是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP:  INC A</span><br><span class="line"></span><br><span class="line">; 等价于</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">       INC A</span><br></pre></td></tr></table></figure><p>不要错误的认为标号代表当前行所在的地址。</p><p><code>END</code>就是结束标志，没什么意思。</p><h3 id="DB、DW和DS"><a href="#DB、DW和DS" class="headerlink" title="DB、DW和DS"></a>DB、DW和DS</h3><ul><li>DB：从指定单元开始，定义n个字节，并在每个字节中存放1个数</li><li>DW：从指定单元开始，定义n个字（对于MCS-51，1个word = 2个byte），并在每个字中存放1个数</li><li>DS：从指定单元开始，定义n个空字节</li></ul><p>这里的“指定单元”的地址按以下两种方法确定：</p><ol><li>由<code>ORG</code>指令确定</li><li>在前一条指令末地址的下一个地址确定</li></ol><p>对应代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORG     8051H</span><br><span class="line">DB      &apos;A&apos;                  ; (8051H) = &apos;A&apos; = 05H</span><br><span class="line"></span><br><span class="line">ORG     8086H</span><br><span class="line">NOP                          ; NOP 为单字节指令</span><br><span class="line">DB      &apos;B&apos;                  ; (8087H) = &apos;B&apos; = 06H</span><br></pre></td></tr></table></figure><p><code>DB</code>指令在保存字符串时会非常方便，可以直接写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB      &apos;To be or not to be&apos;</span><br><span class="line">DB      &apos;That is the question&apos;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB      &apos;T&apos;, &apos;o&apos;, &apos; &apos;, &apos;b&apos;, &apos;e&apos;</span><br><span class="line">; ......</span><br></pre></td></tr></table></figure><p>但对于<code>DW</code>指令而言，一次只能定义两个字节的单元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 是错误的！</span><br><span class="line">DW      &apos;To be or not to be&apos;</span><br><span class="line">DW      &apos;That is the question&apos;</span><br><span class="line"></span><br><span class="line">; 必须写为：</span><br><span class="line">DW      &apos;To&apos;, &apos; b&apos;, &apos;e &apos;, &apos;or&apos;</span><br><span class="line">; ......</span><br></pre></td></tr></table></figure><p>另外，<code>DB</code>，<code>DW</code>和<code>DS</code>后可以跟表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DB      128 + 127</span><br><span class="line">DW      1024 + 255</span><br><span class="line">DS      1 + 1</span><br><span class="line"></span><br><span class="line">; 等价于：</span><br><span class="line">DB      255</span><br><span class="line">DW      1279</span><br><span class="line">DS      2</span><br></pre></td></tr></table></figure><p>在使用<code>DB</code>、<code>DW</code>和<code>DS</code>时有一点需要注意，以这段程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORG     8000H</span><br><span class="line">DB      &apos;A&apos;, 00H</span><br></pre></td></tr></table></figure><p>这段代码本意是在8000H单元中存放字母A对应的ASCII码0x41，8001H单元中存放00H</p><p>即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8000H:  0100 0001</span><br><span class="line">8001H:  0000 0000</span><br></pre></td></tr></table></figure><p>但利用Keil调试功能提供的反汇编代码来观察一下，上面的<code>DB</code>指令会被翻译为双字节指令<code>AJMP 20H</code>，为什么会出现这种情况？这就要回顾一下AJMP指令的机器码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; AJMP addr11</span><br><span class="line"></span><br><span class="line">A10A9A8    00001</span><br><span class="line">A7A6A5A4A3A2A1A0</span><br></pre></td></tr></table></figure><p>对比一下不难发现，前面的<code>DB</code>指令及其存放的数据，恰好为<code>AJMP 20H</code>指令对应的机器码，因此反汇编的结果也就不难理解了。</p><p>因此这里也就需要注意，如果写程序时不慎将<code>DB</code>和<code>DW</code>指令及其定义的数据写为程序需要执行的代码，有可能会引发莫名其妙的错误（且编译器不提示），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">MAIN:</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure><p>正确写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        ORG     0000H</span><br><span class="line">        LJMP    MAIN</span><br><span class="line"></span><br><span class="line">        ORG     0030H</span><br><span class="line">TAB:    DB      &apos;A&apos;, 00H</span><br><span class="line"></span><br><span class="line">        ORG     0060H</span><br><span class="line">MAIN:</span><br><span class="line">        MOV     A, 60H</span><br><span class="line">        MOV     R0, 61H</span><br><span class="line">        ADD     A, R0</span><br><span class="line">        END</span><br></pre></td></tr></table></figure><p>当然，由于<code>NOP</code>指令的机器码就是<code>0000 0000</code>，因此<code>DS</code>指令并不会导致错误，只是相当于额外增加了几微秒的延时。</p><p>另外，所有的资料都会说，DS指令是用来划分出一部分空间备用，包括Keil的文档也只是简单的提了这么几句话:</p><blockquote><p>The DS statement reserves the specified number of bytes in the current memory space. label is a symbol that is assigned the current memory address. expression is the number of bytes to reserve.<br>This statement reserves space and increments the location counter by the number of bytes reserved.</p></blockquote><p>但是，DB、DW和DS只对程序存储器起作用，而ROM在单片机运行时是不可能被修改的，既然如此，为什么还会需要DS指令？</p><p>只查到<code>startup.a51</code>文件中用到了DS指令，其它情况均未检索到。</p><h3 id="EQU、DATA和BIT"><a href="#EQU、DATA和BIT" class="headerlink" title="EQU、DATA和BIT"></a>EQU、DATA和BIT</h3><ul><li>EQU：类似#define，但必须先定义后使用，可跟表达式</li><li>DATA：类似#define，可以先使用再定义（类似goto的函数作用域），可跟表达式</li><li>BIT：类似#define，可以先使用再定义</li></ul><p>EQU的用法要留意一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 正确的</span><br><span class="line">Alpha   EQU     0FFH</span><br><span class="line">MOV     A, #Alpha</span><br><span class="line"></span><br><span class="line">; 亦可  MOV     A, Alpha  , 此时Alpha为地址</span><br><span class="line"></span><br><span class="line">; 错误的</span><br><span class="line">Alpha   EQU     #0FFH</span><br></pre></td></tr></table></figure><p>EQU后可跟表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alpha   EQU     90 + 9</span><br><span class="line"></span><br><span class="line">; 等价于</span><br><span class="line">Alpha   EQU     99</span><br></pre></td></tr></table></figure><p>2019年10月21日</p><hr><h2 id="MCS-51的指令"><a href="#MCS-51的指令" class="headerlink" title="MCS-51的指令"></a>MCS-51的指令</h2><p>根据《MCS-51单片机原理、系统设计与应用》一书，111条指令可按以下三种方式分类：</p><p>按字节数分：</p><ul><li>单字节指令</li><li>双字节指令</li><li>三字节指令</li></ul><p>按执行时间分：</p><ul><li>单周期指令</li><li>双周期指令</li><li>四周期指令</li></ul><p>按功能分：</p><ul><li>数据传送类</li><li>算术运算类</li><li>逻辑运算类</li><li>控制转移类</li><li>布尔处理类</li></ul><p>虽然说有111条指令，但操作码助记符也就这45个：</p><ul><li>数据传送类<ul><li>MOV</li><li>MOVC</li><li>MOVX</li><li>PUSH</li><li>POP</li><li>XCH</li><li>XCHD</li></ul></li><li>算术运算类<ul><li>ADD</li><li>ADDC</li><li>SUBB</li><li>INC</li><li>DEC</li><li>MUL</li><li>DIV</li><li>DA</li></ul></li><li>逻辑运算和移位指令<ul><li>ANL</li><li>ORL</li><li>XRL</li><li>CLR</li><li>CPL</li><li>RL</li><li>RR</li><li>RLC</li><li>RRC</li><li>SWAP</li></ul></li><li>控制转移类<ul><li>AJMP</li><li>LJMP</li><li>SJMP</li><li>JMP</li><li>JZ</li><li>JNZ</li><li>CJNE</li><li>DJNZ</li><li>ACALL</li><li>LCALL</li><li>RET</li><li>RETI</li><li>NOP</li></ul></li><li>布尔处理类<ul><li>CLR</li><li>SETB</li><li>CPL</li><li>ANL</li><li>ORL</li><li>JC</li><li>JNC</li><li>JBC</li></ul></li></ul><p>用的比较少的指令：</p><ul><li>XCH：内部RAM、SFR或寄存器内容与累加器内容互换</li><li>XCHD：内部RAM低4位内容与累加器低4位内容交换</li><li>SWAP：累加器高4位与低4位交换</li><li>DA：十进制调整指令</li></ul><p>2019年10月24日 霜降</p><hr><h2 id="关于MCS-51汇编中有符号数和无符号数的问题"><a href="#关于MCS-51汇编中有符号数和无符号数的问题" class="headerlink" title="关于MCS-51汇编中有符号数和无符号数的问题"></a>关于MCS-51汇编中有符号数和无符号数的问题</h2><p>在C语言中，有符号数和无符号数利用signed和unsigned关键字来区分，简洁明了。</p><p>但在汇编层面，不存在变量的概念，一切操作都是直接对寄存器中二进制数进行运算。此时CPU如何区分一个数是有符号数还是无符号数？如果两有符号数相加，那么就可能发生溢出的问题，这个时候单片机的溢出标志位就可能会发生改变。</p><p>但如果两个无符号数相加，那么溢出的概念就毫无意义，那么对于无符号数的运算，单片机的溢出标志位是否还会改变呢？在keil中测试即可发现，无符号数运算时溢出标志位依然是会改变的，至于为什么，有必要弄明白CPU是如何处理这一问题的。</p><p>查阅了相关资料，得出的结论是，CPU并不区分一个数有无符号，或者也可以说，CPU在运算时把所有数都看作有符号数，例如，如果我想计算129 + 1的值，则应写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV A, #10000001B</span><br><span class="line">ADD A, #1</span><br></pre></td></tr></table></figure><p>而如果我想计算-127 + 1，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; -127的补码为1000 0001B</span><br><span class="line">MOV A, #10000001B</span><br><span class="line">ADD A, #1</span><br></pre></td></tr></table></figure><p>可以看到两种计算的指令是完全相同的，结果均为<code>1000 0010B</code>，如果认为两个数为无符号，则答案就是130，反之，则为<code>1000 0010B</code>的原码-126，寄存器中的数到底有无符号，完全取决于使用者看待问题的方式，使用者认为这是有符号，那么它就是有符号数。</p><p>如果有符号数参与计算时发生了溢出，OV标志位自然也就会被置为1。但由于CPU不区分有符号数和无符号数（有符号和无符号的指令是相同的），因此，即使OV发生了变化，如果使用者认为这两个数是无符号数，那么OV的变化对于使用者而言就毫无意义，忽略即可。</p><p>扩展阅读：<br>王爽《汇编语言》 11.3 SF标志 第215页</p><p>2019年10月26日</p><hr><h2 id="线译码、部分译码和全译码"><a href="#线译码、部分译码和全译码" class="headerlink" title="线译码、部分译码和全译码"></a>线译码、部分译码和全译码</h2><p><del>暑假跟着张老师做实验箱时就没搞的很清楚，上课时听懂以后没复习又全忘了Orz</del><br>回顾一下，MCS-51有三条总线——地址总线（P0和P2）、数据总线（P0）和控制总线（P3）。如果想要让单片机连接存储器或其它芯片，只需将三条总线直接和芯片上对应的引脚连在一起即可，大致按照以下规则：</p><p><strong>数据总线连接外围芯片用于传输数据的引脚</strong><br><del>废话</del></p><p><strong>控制总线连接外围芯片控制信号的相关引脚</strong></p><span style="TEXT-DECORATION: overline">RD</span>连接数据存储器芯片的读有效信号引脚<span style="TEXT-DECORATION: overline">RD</span>或<span style="TEXT-DECORATION: overline">OE</span><br><span style="TEXT-DECORATION: overline">WR</span>连接数据存储器芯片的写有效信号引脚<span style="TEXT-DECORATION: overline">WR</span>或<span style="TEXT-DECORATION: overline">WE</span><br><span style="TEXT-DECORATION: overline">PSEN</span>连接程序存储器芯片的输出有效有信号引脚<span style="TEXT-DECORATION: overline">OE</span><p><strong>地址总线连接外围芯片片选和字选相关引脚</strong><br>引入两个概念：<em>片选</em>和<em>字选</em></p><p><strong>片选</strong>：假设有多个芯片连接在总线上，选中某个芯片（从而允许其工作），<span style="TEXT-DECORATION: overline">CS</span>或<span style="TEXT-DECORATION: overline">CE</span>引脚一般作为片选引脚。<br><strong>字选</strong>：在已经选中了某个芯片的前提下，选择该芯片内的某个存储单元。</p><p>显然，对于所有要挂载在总线上工作的芯片，字选可以没有，但片选是必须的。但对于存储器等内部具有多个存储单元的芯片，或是8255、ADC0809这样需要选择通道的芯片，字选是必须的。</p><p>更具体一点，片选如何实现呢？</p><p>实际操作时，外接芯片的片选和字选引脚都用地址线来实现，被称之为片选地址线。假设51单片机外连接了1个4K容量的数据存储器和<code>n-1</code>个只需片选不需要字选的芯片，则单片机就需要10条地址线作为字选地址线。而剩下的6条地址线则用作片选地址线来选中其他芯片。</p><p>片选地址线可以直接悬空，也可以直接连接芯片的片选端，还可以先连接一个译码器，再将译码器的输出端连接到芯片的片选端。因而可分为三种方式连接地址线：线译码方式、部分译码方式和全译码方式。</p><p><strong>线译码方式</strong><br>片选地址线中的某一条地址线直接与芯片的片选引脚连接，其它片选引脚根据需要可悬空。</p><p><strong>部分译码方式</strong><br>片选地址线一部分参与译码，其余部分悬空。</p><p><strong>全译码方式</strong><br>所有片选地址线全部参与译码。</p><p>参考资料：<br><a href="http://www2.hhstu.edu.cn/dzsfzx/upload/2013/9/e/1.02%20MCS-51%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86%E3%80%81%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%BA%94%E7%94%A81.pdf" target="_blank" rel="noopener">王质朴, 吕运朋. MCS-51单片机原理、接口及应用</a><br><a href="https://books.google.com/books?id=MQ8oDwAAQBAJ&amp;pg=PA183&amp;lpg=PA183&amp;dq=%E7%BA%BF%E8%AF%91%E7%A0%81+%E9%83%A8%E5%88%86%E8%AF%91%E7%A0%81&amp;source=bl&amp;ots=Aa0YiN-AgE&amp;sig=ACfU3U0WTCIGW3zZa57U3pZaX11MLCwy3g&amp;hl=zh-CN&amp;sa=X&amp;ved=2ahUKEwiq6b-Prp7mAhVFs54KHd3iBjMQ6AEwAnoECAcQAQ#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">王欣飞, 谢龙汉, 谢锋然. 51单片机原理与程序设计</a></p><p>2019年12月5日</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正式开始学习8051及C51。&lt;/p&gt;
&lt;h2 id=&quot;Cx51-的数据类型&quot;&gt;&lt;a href=&quot;#Cx51-的数据类型&quot; class=&quot;headerlink&quot; title=&quot;Cx51 的数据类型&quot;&gt;&lt;/a&gt;Cx51 的数据类型&lt;/h2&gt;&lt;p&gt;摘自&lt;a href=&quot;http://www.keil.com/support/man/docs/c51/c51_le_datatypes.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cx51 User’s Guide&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔记</title>
    <link href="http://wangyuyang.me/2019/07/20/%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangyuyang.me/2019/07/20/笔记/</id>
    <published>2019-07-20T14:28:11.000Z</published>
    <updated>2020-04-25T03:27:15.611Z</updated>
    
    <content type="html"><![CDATA[<p>学一些东西时遇到的问题。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">目录</span><br><span class="line">1. Assembly Language</span><br><span class="line">    1.1 DOSBox 窗口大小调整无反应</span><br><span class="line"></span><br><span class="line">2. LabVIEW</span><br><span class="line">    2.1 Control Design 效率问题</span><br><span class="line">    2.2 隐藏标题栏后前面板顶部依然有一个白色长条？</span><br><span class="line">    2.3 设置启动动画</span><br><span class="line">    2.4 设置淡入淡出效果</span><br><span class="line">    2.5 子面板 VI 显示位置不正确的问题</span><br><span class="line"></span><br><span class="line">3. OpenCV</span><br><span class="line">    3.1 imread() 函数用法</span><br><span class="line">    3.2 使用 Matplotlib 正确显示彩色图像</span><br><span class="line"></span><br><span class="line">4.Tasking</span><br><span class="line">    4.1 查看 Eclipse 版本</span><br><span class="line">    4.2 安装 Eclipse Marketplace</span><br><span class="line">    4.3 更换界面主题</span><br></pre></td></tr></table></figure><h2 id="Assembly-Language"><a href="#Assembly-Language" class="headerlink" title="Assembly Language"></a>Assembly Language</h2><h3 id="DOSBox-窗口大小调整无反应"><a href="#DOSBox-窗口大小调整无反应" class="headerlink" title="DOSBox 窗口大小调整无反应"></a>DOSBox 窗口大小调整无反应</h3><p>根据网络上的说法，调整安装目录下<code>dosbox-0.74-3.conf</code>下的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=original</span><br><span class="line">output=surface</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution = 1536*864</span><br><span class="line">output = overlay</span><br></pre></td></tr></table></figure></p><p>发现没有变化，Google一下，建议改<code>scaler</code>为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[render]</span><br><span class="line"></span><br><span class="line">frameskip = 0</span><br><span class="line">aspect = false</span><br><span class="line">scaler = normal2x forced</span><br></pre></td></tr></table></figure></p><p>然而强制缩放太糊，我还是改成了<code>scaler=none</code>。<br>又折腾半小时才解决，发现是<code>1536x864</code>而不是<code>1536*864</code>，即字母<code>x</code>而不是乘号<code>*</code>…..<del>mdzz，配置文件的注释也不写清楚</del><br>另外之所以改为<code>1536x864</code>而不是<code>1920x1080</code>是因为笔记本本来就开了125%缩放。<br>另另外，感觉<code>output = overlay</code>比<code>opengl</code>更锐利一点？</p><hr><h2 id="LabVIEW"><a href="#LabVIEW" class="headerlink" title="LabVIEW"></a>LabVIEW</h2><h3 id="Control-Design效率问题"><a href="#Control-Design效率问题" class="headerlink" title="Control Design效率问题"></a>Control Design效率问题</h3><p>用LabVIEW做了一个二阶LTI系统的单位阶跃响应曲线绘制VI，系统初始参数由滑动杆输入，计算结果捆绑成簇，输出到front panel的XY图控件。</p><p>计算这一块有两种解决办法，一种是直接调用<code>Control and Simulation &gt;&gt; Control Design &gt;&gt; Model Construction &gt;&gt; CD Construct Second Order Model.vi</code>和<code>CD Step Response Model.vi</code>。另一种方法是调用公式节点直接写C进行计算。</p><p>前一种方法实现最简单，只需要点一点鼠标就可以了，但问题在于，不知道该VI及其子VI的执行策略。每次程序循环执行时，即使不做数据更新操作，CPU占用率也会飙到50%以上。</p><p>而直接用C语言实现计算，虽然写起来很麻烦，但速度反而非常快，CPU占用率只要不到5%。</p><p>2019.7.31更新：问题解决一半，将控件放置在while循环内，同时在循环内放置一个<code>Wait For Front Panel Activity</code>控件即可解决数据未更新时占用率过高的问题，但在反复拖动滑动杆时CPU占用率依然远远高于C语言实现方案。LabVIEW本身提供的例程<code>CDEx Adjust Second Order System Parameters.vi</code>也存在一样的问题。所以这应该是LabVIEW的问题？</p><h3 id="隐藏标题栏后前面板顶部依然有一个白色长条？"><a href="#隐藏标题栏后前面板顶部依然有一个白色长条？" class="headerlink" title="隐藏标题栏后前面板顶部依然有一个白色长条？"></a>隐藏标题栏后前面板顶部依然有一个白色长条？</h3><p>属性-&gt;窗口外观-&gt;自定义-&gt;禁止用户调整窗口大小。</p><h3 id="设置启动动画"><a href="#设置启动动画" class="headerlink" title="设置启动动画"></a>设置启动动画</h3><p>不知道有没有更好的方法，主要思路是主VI程序框图中先调用一个子VI，并修改设置保证子VI的前面板能够被显示出来（参见<a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z0000019MBISA2&amp;l=zh-CN" target="_blank" rel="noopener">如何控制在LabVIEW中打开子VI的前面板</a>————解决方案一）。</p><p>然后在子VI中设置2s后自动关闭（或者搞一个全局变量，当主VI加载完成后，通知启动动画VI退出，另外最好在启动动画中搞一个延时，保证启动动画不会因主VI加载过快而瞬间关闭）。</p><h3 id="设置淡入淡出效果"><a href="#设置淡入淡出效果" class="headerlink" title="设置淡入淡出效果"></a>设置淡入淡出效果</h3><p>思路很简单，使用程序调整窗口初始透明度为0，然后每5ms透明度+1，直至100结束，从而实现淡出效果。</p><p>具体步骤：首先，在VI中放置属性节点，右键，选择类-&gt;VI服务器-&gt;VI-&gt;VI。</p><p>然后再给这个属性节点添加元素，同样的，右键，选择属性-&gt;前面板窗口，然后添加“以透明方式运行VI”和“透明度”即可。</p><p>对于上面添加的两个元素，分别传入一个布尔变量和0~100以内的整型变量，这里整型变量可以直接用for循环中的计数器i来代替。设置for循环<code>n = 100</code>，每次循环用定时器延时5ms即可。</p><p>配合启动动画效果还是非常漂亮的，已经很接近UWP的效果了。</p><p>很好奇LabVIEW能不能实现背景高斯模糊（类似UWP里Acrylic的那种），抽空折腾一下。<br><del>要是真能做出来我吹爆LabVIEW！！</del></p><h3 id="子面板-VI-显示位置不正确的问题"><a href="#子面板-VI-显示位置不正确的问题" class="headerlink" title="子面板 VI 显示位置不正确的问题"></a>子面板 VI 显示位置不正确的问题</h3><p>尝试在子面板中显示一个子VI前面板，结果前面板的位置始终在子面板的显示区外，且尝试以下方法均未解决问题：</p><ol><li>调整子VI前面板运行时尺寸和子面板尺寸精确相同（完全无效）</li><li>调整子VI前面板最小尺寸和子面板尺寸精确相同（完全无效）</li><li>在子VI图标右键，属性，设置启动时窗格滚动到原点（仅2019有该选项，且完全无效）</li><li>在子VI图标右键，设置前面板不显示工具栏和菜单栏（偶尔有效？玄学？？）</li><li>上述4条的组合也完全无效</li></ol><p>经过多次截图测试，发现子VI显示位置不正确的根本原因还是窗格没有滚动到原点，也就是说LabVIEW 2019的这个选项就是个摆设（或者有bug？）。于是决定用属性节点强制子面板载入VI时滚动到原点，方法可以参考<a href="https://forums.ni.com/t5/LabVIEW/subpanel-position-of-displayed-VI/td-p/693673/page/2?profile.language=zh-CN" target="_blank" rel="noopener">subpanel: position of displayed VI</a>中的<a href="https://forums.ni.com/ni/attachments/ni/170/318054/1/Example_VI_BD4.png" target="_blank" rel="noopener">这张图片</a>。</p><hr><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h3 id="imread-函数用法"><a href="#imread-函数用法" class="headerlink" title="imread()函数用法"></a>imread()函数用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imread(path, flag)</span><br></pre></td></tr></table></figure><!-- more --> <p>path为图片路径，未找到指定文件时返回值None<br>flag为读取图片的方式，具体取值含义可以参考官方文档。</p><h3 id="使用Matplotlib正确显示彩色图像"><a href="#使用Matplotlib正确显示彩色图像" class="headerlink" title="使用Matplotlib正确显示彩色图像"></a>使用Matplotlib正确显示彩色图像</h3><p>尝试直接使用下面代码显示图像时发现颜色不正常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">pyplot.imgshow(img)</span><br></pre></td></tr></table></figure></p><p>查阅资料，<a href="https://stackoverflow.com/questions/15072736/extracting-a-region-from-an-image-using-slicing-in-python-opencv/15074748#15074748" target="_blank" rel="noopener">Extracting a region from an image using slicing in Python, OpenCV</a>里提到：<br><blockquote><p>There is a slight difference in pixel ordering in OpenCV and Matplotlib.</p><p>OpenCV follows BGR order, while matplotlib likely follows RGB order.</p><p>So when you display an image loaded in OpenCV using pylab functions, you may need to convert it into RGB mode. </p></blockquote><br>关于为什么OpenCV选择BGR而不是RGB这个问题，可以看这里<a href="https://www.zhihu.com/question/264044792" target="_blank" rel="noopener">深度学习中为什么普遍使用BGR而不用RGB？</a><br>另附上Stackoverflow中给出的两种解决方案：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">img = img[::,::<span class="number">-1</span>]</span><br><span class="line">pyplot.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">img = cv2.imread(<span class="string">'xxoo.png'</span>)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">pyplot.imshow(img)</span><br></pre></td></tr></table></figure></p><hr><h2 id="Tasking"><a href="#Tasking" class="headerlink" title="Tasking"></a>Tasking</h2><h3 id="查看-Eclipse-版本"><a href="#查看-Eclipse-版本" class="headerlink" title="查看 Eclipse 版本"></a>查看 Eclipse 版本</h3><p><code>Help-&gt;Welcome-&gt;What&#39;s New-&gt;Eclipse Platform</code></p><p>这里可以看到我安装的数字版本号为Eclipse 4.5，对应版本名称Mars。</p><p>下附Eclipse版本代号对应关系。</p><table><thead><tr><th>Platfrom version</th><th>Version name</th><th>Date</th></tr></thead><tbody><tr><td>Eclipse 3.1</td><td>IO</td><td>2005</td></tr><tr><td>Eclipse 3.2</td><td>Callisto</td><td>2006</td></tr><tr><td>Eclipse 3.3</td><td>Europa</td><td>2007</td></tr><tr><td>Eclipse 3.4</td><td>Ganymede</td><td>2008</td></tr><tr><td>Eclipse 3.5</td><td>Galileo</td><td>2009</td></tr><tr><td>Eclipse 3.6</td><td>Helios</td><td>2010</td></tr><tr><td>Eclipse 3.7</td><td>Indigo</td><td>2011</td></tr><tr><td>Eclipse 4.2</td><td>Juno</td><td>2012</td></tr><tr><td>Eclipse 4.3</td><td>Kepler</td><td>2013</td></tr><tr><td>Eclipse 4.4</td><td>Luna</td><td>2014</td></tr><tr><td>Eclipse 4.5</td><td>Mars</td><td>2015</td></tr><tr><td>Eclipse 4.6</td><td>Neon</td><td>2016</td></tr><tr><td>Eclipse 4.7</td><td>Oxygen</td><td>2017</td></tr><tr><td>Eclipse 4.8</td><td>Photon</td><td>2018</td></tr></tbody></table><p><del>Eclipse 4.9之后更新频率变高，名字就很土了，直接就是发行日期，详见Wiki</del></p><h3 id="安装-Eclipse-Marketplace"><a href="#安装-Eclipse-Marketplace" class="headerlink" title="安装 Eclipse Marketplace"></a>安装 Eclipse Marketplace</h3><p>类似Visual Studio Code中的扩展管理工具，如果在Help菜单下找不到该工具需要手动安装。</p><p>安装方法：<code>Help-&gt;Install New Software</code>，在Work with中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://download.eclipse.org/mpc/mars</span><br><span class="line"># &apos;/mars&apos; 应替换为自己Eclipse版本代号，如4.8版本替换为&apos;/photon&apos;</span><br></pre></td></tr></table></figure><p>然后勾选EPP MarketplaceClient即可。</p><h3 id="更换界面主题"><a href="#更换界面主题" class="headerlink" title="更换界面主题"></a>更换界面主题</h3><p>在MarketPlace里搜索theme即可，一个比一个丑，放弃了。</p><h3 id="使用-VS-Code-作为编辑器"><a href="#使用-VS-Code-作为编辑器" class="headerlink" title="使用 VS Code 作为编辑器"></a>使用 VS Code 作为编辑器</h3><p>鉴于Eclipse丑到极致，以后一律默认使用VS Code作为文本编辑器。</p><p>设置外部编辑器修改文件后Eclipse自动刷新，<code>Window-&gt;Preferences-&gt;General-&gt;Workspace</code>，然后选中右侧<code>Refresh using native hooks or polling</code>和<code>Refresh on access</code>即可，如果需要也可勾选<code>Build automatically</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学一些东西时遇到的问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二十</title>
    <link href="http://wangyuyang.me/2019/04/11/%E4%BA%8C%E5%8D%81/"/>
    <id>http://wangyuyang.me/2019/04/11/二十/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-11T11:21:25.267Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.Net/Matlab混合编程</title>
    <link href="http://wangyuyang.me/2019/03/17/CSharp-Matlab%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    <id>http://wangyuyang.me/2019/03/17/CSharp-Matlab混合编程/</id>
    <published>2019-03-17T05:22:26.000Z</published>
    <updated>2019-03-17T06:34:12.751Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便的使用Matlab中自定义的函数，需要制作一个简单的界面。但Matlab难以做出一个漂亮的GUI。因此希望利用C#制作出一个界面。</p><p>Matlab版本为R2018a<br><a id="more"></a><br>在C#中调用Matlab函数大体上分为以下几个步骤：</p><ol><li>首先创建一个函数的M文件。</li><li>将函数文件编译为dll文件。</li><li>在C#工程中添加对dll文件引用，并在程序中加入对命名空间的引用。</li><li>愉快的敲代码。</li></ol><p>具体描述一下过程：</p><h2 id="创建M文件"><a href="#创建M文件" class="headerlink" title="创建M文件"></a>创建M文件</h2><p>没什么好说的，需要了解一些Matlab基础知识和语法。</p><h2 id="将函数编译为dll文件"><a href="#将函数编译为dll文件" class="headerlink" title="将函数编译为dll文件"></a>将函数编译为dll文件</h2><p>这一块主要分为两部分：</p><h3 id="创建一个编译dll库的工程-prj"><a href="#创建一个编译dll库的工程-prj" class="headerlink" title="创建一个编译dll库的工程.prj"></a>创建一个编译dll库的工程.prj</h3><p>在Command Window中输入deploytool</p><p>在弹出的Matlab Compiler窗口中，有五个选项：</p><ul><li>Application Compiler</li><li>Hadoop Compiler</li><li>Library Compiler</li><li>Production Server Compiler</li><li>Web App Compiler</li></ul><p>这里选择Library Compiler，然后在上方的Type内选择.Net Assembly，并在旁边的Exported Functions中添加前面创建的M文件。</p><p>接下来需要填写窗口下方的信息，Namespace, Class Name, Method Name按需添加、填写即可。</p><h3 id="编译函数"><a href="#编译函数" class="headerlink" title="编译函数"></a>编译函数</h3><p>必要信息填写完成后直接点击Package，选择保存位置即可。等待数分钟后即完成编译。</p><h2 id="在C-工程中添加对dll文件引用"><a href="#在C-工程中添加对dll文件引用" class="headerlink" title="在C#工程中添加对dll文件引用"></a>在C#工程中添加对dll文件引用</h2><p>首先添加对dll库引用：</p><p>解决方案资源管理器 -&gt; 引用-（右键） -&gt; 添加引用 -&gt; 程序集 -&gt; 浏览 -（选择生成的dll库）-&gt; 添加</p><p>然后使用using引用对应的命名空间即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便的使用Matlab中自定义的函数，需要制作一个简单的界面。但Matlab难以做出一个漂亮的GUI。因此希望利用C#制作出一个界面。&lt;/p&gt;
&lt;p&gt;Matlab版本为R2018a&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模拟登录HFUT新教务系统-C#</title>
    <link href="http://wangyuyang.me/2019/02/16/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E6%96%B0%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F-csharp/"/>
    <id>http://wangyuyang.me/2019/02/16/模拟登录HFUT新教务系统-csharp/</id>
    <published>2019-02-16T09:10:23.000Z</published>
    <updated>2019-02-22T16:23:22.441Z</updated>
    
    <content type="html"><![CDATA[<p>希望利用C#写一个GUI，方便起见抓取数据部分也由C#实现，先写一个小程序试一试。</p><p>爬虫主体是借助System.Net.Http.HttpClient实现的。<br><a id="more"></a><br><blockquote><p>System.Net.Http是什么？</p><p>Provides a programming interface for modern HTTP applications, including HTTP client components that allow applications to consume web services over HTTP and HTTP components that can be used by both clients and servers for parsing HTTP headers.</p><p>Commonly Used Types:<br>System.Net.Http.HttpResponseMessage<br>System.Net.Http.DelegatingHandler<br>System.Net.Http.HttpRequestException<br>System.Net.Http.HttpClient<br>System.Net.Http.MultipartContent<br>System.Net.Http.Headers.HttpContentHeaders<br>System.Net.Http.HttpClientHandler<br>System.Net.Http.StreamContent<br>System.Net.Http.FormUrlEncodedContent<br>System.Net.Http.HttpMessageHandler</p></blockquote></p><p>主要思路和<a href="https://wangyuyang.me/2019/01/20/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95HFUT%E6%96%B0%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/#more">这篇文章</a>相同。</p><p>Post Json数据部分代码则参考了<a href="https://blogs.msdn.microsoft.com/wsdevsol/2013/02/05/how-to-use-httpclient-to-post-json-data/" target="_blank" rel="noopener">How to use HttpClient to post JSON data</a>。<br><del>完全没看懂“Add code to serialize the object to a string and…”这一部分代码到底干了啥，反正能用Orz</del></p><p><del>学了几天的C#，回过头来再看代码写的好烂啊emmm…</del></p><p>下附源码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Json;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">jwxt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">            LoginJwxt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DataContract</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post_Payload</span></span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"username"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"password"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            [<span class="meta">DataMember(Name = <span class="meta-string">"captcha"</span>)</span>]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> captcha &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoginJwxt</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">string</span> login_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/login"</span>;</span><br><span class="line">            <span class="keyword">string</span> login_salt_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/login-salt"</span>;</span><br><span class="line">            <span class="keyword">string</span> student_info_url = <span class="string">"http://jxglstu.hfut.edu.cn/eams5-student/for-std/student-info/"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> username = <span class="string">"2019123456"</span>;</span><br><span class="line">            <span class="keyword">string</span> password = <span class="string">"123456"</span>;</span><br><span class="line">            <span class="keyword">string</span> encryptpassword;</span><br><span class="line">            <span class="keyword">string</span> salt = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">            httpClient.DefaultRequestHeaders.Add(<span class="string">"user-agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取salt</span></span><br><span class="line">            salt = httpClient.GetStringAsync(login_salt_url).Result;</span><br><span class="line">            password = salt + <span class="string">"-"</span> + password;</span><br><span class="line"></span><br><span class="line">            SHA1 sha = <span class="keyword">new</span> SHA1CryptoServiceProvider();</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sha.ComputeHash(Encoding.UTF8.GetBytes(password)).Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                builder.Append(sha.ComputeHash(Encoding.UTF8.GetBytes(password))[i].ToString(<span class="string">"x2"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            encryptpassword = builder.ToString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Create and Populate the Post_Payload class with data</span></span><br><span class="line">            Post_Payload post_Payload = <span class="keyword">new</span> Post_Payload();</span><br><span class="line">            post_Payload.username = username;</span><br><span class="line">            post_Payload.password = encryptpassword;</span><br><span class="line">            post_Payload.captcha = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Create a Json Serializer for our type </span></span><br><span class="line">            DataContractJsonSerializer jsonSer = <span class="keyword">new</span> DataContractJsonSerializer(<span class="keyword">typeof</span>(Post_Payload));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the serializer to write the object to a MemoryStream </span></span><br><span class="line">            MemoryStream ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">            jsonSer.WriteObject(ms, post_Payload);</span><br><span class="line">            ms.Position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//use a Stream reader to construct the StringContent (Json) </span></span><br><span class="line">            StreamReader sr = <span class="keyword">new</span> StreamReader(ms);</span><br><span class="line">            StringContent theContent = <span class="keyword">new</span> StringContent(sr.ReadToEnd(), System.Text.Encoding.UTF8, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">            httpClient.PostAsync(login_url, theContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证是否登录成功，保存学籍信息页到本地</span></span><br><span class="line">            FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">"E:\\abc.txt"</span>, FileMode.Create);</span><br><span class="line">            <span class="comment">//获得字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = System.Text.Encoding.Default.GetBytes(httpClient.GetStringAsync(student_info_url).Result);</span><br><span class="line">            <span class="comment">//开始写入</span></span><br><span class="line">            fs.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">            <span class="comment">//清空缓冲区、关闭流</span></span><br><span class="line">            fs.Flush();</span><br><span class="line">            fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望利用C#写一个GUI，方便起见抓取数据部分也由C#实现，先写一个小程序试一试。&lt;/p&gt;
&lt;p&gt;爬虫主体是借助System.Net.Http.HttpClient实现的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
